Project Structure:
└── /
    ├── .dockerignore
    ├── .env
    ├── .gitignore
    ├── Dockerfile
    ├── README.md
    ├── TODO.md
    ├── app/
    │   ├── __init__.py
    │   ├── auth/
    │   │   ├── __init__.py
    │   │   ├── forms.py
    │   │   └── routes.py
    │   ├── config.py
    │   ├── main/
    │   │   ├── __init__.py
    │   │   ├── api.py
    │   │   └── routes.py
    │   ├── models.py
    │   ├── public/
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── scheduler/
    │   │   ├── __init__.py
    │   │   └── tasks.py
    │   ├── services/
    │   │   ├── __init__.py
    │   │   ├── apple_data_service.py
    │   │   ├── notification_service.py
    │   │   └── user_data_service.py
    │   ├── static/
    │   │   ├── css/
    │   │   │   └── style.css
    │   │   ├── favicon.ico
    │   │   ├── fonts/
    │   │   │   ├── flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2
    │   │   │   └── kJEhBvYX7BgnkSrUwT8OhrdQw4oELdPIeeII9v6oFsI.woff2
    │   │   ├── icons/
    │   │   │   ├── apple-touch-icon.png
    │   │   │   ├── badge-icon.png
    │   │   │   ├── devices_16dp.png
    │   │   │   ├── devices_24dp.png
    │   │   │   ├── favicon-96x96.png
    │   │   │   ├── favicon.svg
    │   │   │   ├── icon.svg
    │   │   │   ├── map_16dp.png
    │   │   │   ├── map_24dp.png
    │   │   │   ├── web-app-manifest-192x192.png
    │   │   │   └── web-app-manifest-512x512.png
    │   │   ├── js/
    │   │   │   ├── api.js
    │   │   │   ├── app.js
    │   │   │   ├── config.js
    │   │   │   ├── map.js
    │   │   │   ├── notifications.js
    │   │   │   ├── share_page.js
    │   │   │   ├── state.js
    │   │   │   ├── ui.js
    │   │   │   └── utils.js
    │   │   ├── manifest.json
    │   │   ├── styles/
    │   │   │   ├── leaflet/
    │   │   │   │   ├── images/
    │   │   │   │       ├── marker-icon-2x.png
    │   │   │   │       ├── marker-icon.png
    │   │   │   │       └── marker-shadow.png
    │   │   │   ├── material-icons/
    │   │   │   │   └── material-icons.css
    │   │   │   ├── material-symbols/
    │   │   │       └── material-symbols-outlined.css
    │   │   └── sw.js
    │   ├── templates/
    │   │   ├── index.html
    │   │   ├── login.html
    │   │   ├── logout_success.html
    │   │   ├── manage_apple_creds.html
    │   │   ├── register.html
    │   │   └── share_map.html
    │   ├── utils/
    │       ├── __init__.py
    │       ├── data_formatting.py
    │       ├── helpers.py
    │       ├── json_utils.py
    │       └── key_utils.py
    ├── data/
    │   ├── AAA/
    │   │   └── cache.json
    │   ├── Ghed/
    │   │   ├── AIY.plist
    │   │   ├── AUTO.keys
    │   │   ├── BICI.keys
    │   │   ├── apple_credentials.json
    │   │   ├── battery_state.json
    │   │   ├── cache.json
    │   │   ├── devices.json
    │   │   ├── geofence_state.json
    │   │   ├── geofences.json
    │   │   ├── notification_times.json
    │   │   ├── notifications_history.json
    │   │   └── subscriptions.json
    │   ├── shares.json
    │   └── users.json
    ├── docker-compose.yaml
    ├── docker-compose.yml
    ├── portainer_docker-compose.yaml
    ├── portainer_docker-compose.yml
    ├── requirements.txt
    ├── run.py
    ├── scripts/
    │   ├── __init__.py
    │   ├── generate_vapid.py
    │   └── hashed_pw.py
    └── test_import.py


// --------------------
// .dockerignore
# .dockerignore
# Define files and directories to exclude from the Docker build context.

# --- Git & Docker ---
# Git repository files
.git
.gitignore

# Docker related files (not needed inside the image itself)
Dockerfile
.dockerignore
docker-compose.yml
portainer_docker-compose.yml
.yaml

# Add any other docker-compose variations here

# --- Python Virtual Environments ---
# Common names for virtual environments
venv/
.venv/
ENV/
env/
env.bak/
venv.bak/

# --- Python Cache & Compiled Files ---
# Bytecode and cache directories/files
__pycache__/
*.py[cod]
*.so

# --- IDE / Editor Specific ---
# Configuration directories for common IDEs
.idea/
.vscode/
*.sublime-*
*.iml

# --- Testing Artifacts ---
# Cache, coverage reports, etc.
.pytest_cache/
.coverage*
htmlcov/
nosetests.xml
coverage.xml

# --- Build Artifacts ---
# Files and directories generated by build processes
dist/
build/
*.egg-info/
*.egg
wheels/

# --- Data Directory (CRITICAL) ---
# This directory contains user data and MUST be handled by a Docker Volume Mount.
# NEVER copy the host's data directory into the image during build.
data/

# --- Environment Files ---
# These contain secrets and configuration, handled by Volume Mount or Docker Environment variables.
# They are not needed during the image build process itself.
.env
*.env.*
.envrc

# --- OS Specific Junk Files ---
# macOS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
# Windows
Thumbs.db
ehthumbs.db
desktop.ini
# Linux temporary files
*~

# --- Documentation / Project Files ---
# These are generally not needed inside the running container image.
README.md
LICENSE # Or your specific license file name
docs/ # If you have a documentation folder

# --- Development/Utility Scripts ---
# Scripts used for setup/dev tasks, not needed by the running application.
# Ignoring the whole directory is usually safe unless a script IS needed at runtime.
# scripts/

# --- Instance Folder (If used by Flask) ---
# Although not explicitly in your structure, it's a common pattern.
instance/

# --- Node Modules (If frontend dependencies are ever managed by npm/yarn) ---
# node_modules/
# package-lock.json
# yarn.lock

# --- Other Cache/Temp Files ---
# MyPy cache
.mypy_cache/
# Ruff cache
.ruff_cache/
# pytype cache
.pytype/
# Celery schedule file (if Celery added later)
celerybeat-schedule
# Process ID files
*.pid
codebase.txt
// --------------------
// .gitignore
# .gitignore for FindMy WebApp

# --- Python Bytecode and Cache ---
__pycache__/
*.py[cod]
*$py.class
*.so

# --- Python Virtual Environments ---
# Common names for virtual environments
venv/
.venv/
ENV/
env/
env.bak/
venv.bak/

# --- Configuration / Secrets ---
# Environment variable files (use seeds in docker-compose.yml instead)
.env
*.env.*
.envrc

# User-specific sensitive data (Apple credentials are saved here)
# IMPORTANT: Do NOT commit the contents of the data directory!
data/

# Explicitly ignore credential files if accidentally placed outside data/
apple_credentials.json
*.pem
*.key

# --- IDE / Editor Configuration ---
.idea/
.vscode/
*.iml
*.sublime-project
*.sublime-workspace

# --- Build / Distribution Artifacts ---
dist/
build/
*.egg-info/
*.egg
wheels/
htmlcov/ # Coverage reports

# --- Testing Artifacts ---
.pytest_cache/
.coverage
*.cover
nosetests.xml
coverage.xml

# --- Runtime / Temporary Files ---
*.log
*.log.*
*.sqlite
*.sqlite3
# Celery / Task Queue files (if added later)
celerybeat-schedule
*.pid

# --- OS Specific Files ---
# macOS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
# Windows
Thumbs.db
ehthumbs.db
desktop.ini
# Linux
*~
# KDE temp files
.~\$.*

# --- Instance Folder (Common Flask Pattern) ---
# Ignore instance folder if used (though not explicitly in structure now)
/instance/

# --- Node Modules (If frontend build tools are ever added) ---
# node_modules/
# npm-debug.log*
# yarn-debug.log*
# yarn-error.log*
# package-lock.json # Sometimes ignored, sometimes committed
# yarn.lock         # Sometimes ignored, sometimes committed

# --- Jupyter Notebook Checkpoints ---
.ipynb_checkpoints

# --- Miscellaneous ---
# If you use MyPy type checking
.mypy_cache/
.dmypy.json
dmypy.json

# If you use pyenv
.python-version

# If you use Ruff cache
.ruff_cache/

# If you use pytype cache
.pytype/

# --- Docker ---
# Ignore docker contexts unless needed
.docker/contexts/

# ignore docker-compose files
*.yaml
codebase.txt
codebase.py
// --------------------
// docker-compose.yml
# docker-compose.yml

services:
  findmyapp:
    # Build the image using the Dockerfile in the current directory
    build:
      context: .
      dockerfile: Dockerfile
    # Specify the target platform
    platform: linux/arm64/v8
    # Optional: Explicitly name the image built by compose
    image: ghd182/findmy-app:latest
    # Sets a specific container name
    container_name: findmyapp
    # Restart policy
    restart: unless-stopped
    ports:
      # Map host port 5000 to container port 5000
      # Change host port (left side) if 5000 is already in use on your Pi
      - "5000:5000"
    volumes:
      # Mount the local ./data directory into the container for persistence
      # IMPORTANT: Use ABSOLUTE path on your Raspberry Pi host when deploying via Portainer Stack editor
      # Example for user 'pi': /home/username/findmy-app/data:/app/data
      - ./data:/app/data
      # Mount the .env file for configuration secrets
      # IMPORTANT: Use ABSOLUTE path on your Raspberry Pi host when deploying via Portainer Stack editor
      # Example for user 'pi': /home/username/findmy-app/.env:/app/.env
      # - ./.env:/app/.env
      # Mount the private key file if needed by your app (e.g., VAPID requires it)
      # IMPORTANT: Use ABSOLUTE path on your Raspberry Pi host when deploying via Portainer Stack editor
      # Example for user 'pi': /home/username/findmy-app/private_key.pem:/app/private_key.pem
      # - ./private_key.pem:/app/private_key.pem # Uncomment if needed

      # Mount the public key file if needed by your app
      # IMPORTANT: Use ABSOLUTE path on your Raspberry Pi host when deploying via Portainer Stack editor
      # Example for user 'pi': /home/username/findmy-app/public_key.pem:/app/public_key.pem
      # - ./public_key.pem:/app/public_key.pem # Uncomment if needed
    environment:
      # --- Core Flask/App Settings ---
      # IMPORTANT for production
      FLASK_ENV: production
      # Or DEBUG, WARNING, ERROR
      LOG_LEVEL: INFO
      # Set your timezone
      TZ: Europe/Amsterdam
      # Override if needed
      WAITRESS_THREADS: 8

      # --- SEED Variables (DEFINE THESE WITH STRONG SECRETS!) ---
      # These seeds will be used to generate the actual keys internally.
      # KEEP THESE SEEDS SECRET!
      SECRET_SEED: "your-very-long-random-secret-phrase-for-sessions-portainer"
      FERNET_SEED: "another-different-long-random-secret-phrase-for-encryption-portainer"
      VAPID_SEED: "a-third-unique-long-random-phrase-for-push-keys-portainer"
      VAPID_CLAIMS_EMAIL: "mailto:user@email.com"
    
      
      # You can override .env variables here if needed, but mounting .env is usually sufficient
      # Example: Override log level
      # LOG_LEVEL: DEBUG
      # Set timezone if needed by scheduler/logs
      # User default is 10 mins
      DEFAULT_FETCH_INTERVAL_MINUTES: 15
      # Master job runs every 2 mins
      SCHEDULER_MASTER_JOB_INTERVAL_MINUTES: 2
      # Override fetch interval
      FETCH_INTERVAL_MINUTES: 15
      # Override battery threshold
      LOW_BATTERY_THRESHOLD: 20
      # Override notification cooldown (10 minutes)
      NOTIFICATION_COOLDOWN_SECONDS: 600
      # Override history retention
      NOTIFICATION_HISTORY_DAYS: 60
      # Override location history fetch duration     
      HISTORY_DURATION_DAYS: 14
      # Optionally set here
      # ANISETTE_SERVERS: "https://anisette.example.com,http://localhost:6969"
// --------------------
// Dockerfile
# Dockerfile

# Use an official Python runtime as a parent image - choose ARM-compatible base
# Bookworm is current Debian stable, often good for Raspberry Pi OS compatibility
# Specify arm64 architecture explicitly for Pi 4
FROM --platform=linux/arm64/v8 python:3.11-slim-bookworm

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1
ENV FLASK_APP=run.py
ENV FLASK_ENV=production
# Default Waitress threads (can be overridden in docker-compose or .env)
ENV WAITRESS_THREADS=4
# Default Port (can be overridden)
ENV PORT=5000
# Define timezone data path
ENV TZDIR=/usr/share/zoneinfo

# Set the working directory in the container
WORKDIR /app

# Install system dependencies that might be needed by Python packages
# build-essential: For compiling C extensions (e.g., cryptography)
# libffi-dev: Foreign Function Interface library dev files
# libbluetooth-dev: Might be needed by findmy library if it uses BLE directly (add if necessary)
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libffi-dev \
    # libbluetooth-dev \ # Uncomment if Bluetooth features cause issues
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first to leverage Docker cache
COPY requirements.txt /app/requirements.txt

# Install Python dependencies
# Using --no-cache-dir makes the image smaller
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application code into the container
COPY ./app /app/app
# Copy scripts, run.py, config files etc. to '/app'
COPY ./scripts /app/scripts
COPY run.py /app/run.py
COPY test_import.py /app/test_import.py

# Ensure the data directory exists within the container (volume mount will overlay this)
# Set appropriate permissions if running as non-root later
RUN mkdir -p /app/data

# Expose the port the app runs on (defined by PORT env var)
EXPOSE ${PORT}

# Define the command to run the application using Waitress
# Uses environment variables for host, port, and threads
CMD waitress-serve --host=0.0.0.0 --port=${PORT} --threads=${WAITRESS_THREADS} run:app
// --------------------
// portainer_docker-compose.yml
# docker-compose.yml (Modified for Portainer Stack Editor)

services:
  findmyapp:
    # Use the image you built and pushed (or built locally)
    # Make sure this image exists locally or on Docker Hub
    image: ghd182/findmy-app:latest
    container_name: findmyapp
    restart: unless-stopped
    ports:
      - "5000:5000" # Host:Container
    volumes:
      # --- USE ABSOLUTE HOST PATHS ---
      # /absolute_path_to_findmy_app_folder/data:/app/data 
      - /home/username/findmy-app/data:/app/data
    environment:
      FLASK_ENV: production
      # Override if needed
      LOG_LEVEL: DEBUG
      # Set your timezone
      TZ: Europe/Amsterdam
      # Override if needed
      WAITRESS_THREADS: 8

      # --- Key Generation Seeds (KEEP THESE SECRET!) ---
      SECRET_SEED: "your-very-long-random-secret-phrase-for-sessions-portainer"
      FERNET_SEED: "another-different-long-random-secret-phrase-for-encryption-portainer"
      VAPID_SEED: "a-third-unique-long-random-phrase-for-push-keys-portainer"
      VAPID_CLAIMS_EMAIL: "mailto:user@email.com"
      
      # User default is 10 mins
      DEFAULT_FETCH_INTERVAL_MINUTES: 15
      # Master job runs every 2 mins
      SCHEDULER_MASTER_JOB_INTERVAL_MINUTES: 2
      # Override fetch interval
      FETCH_INTERVAL_MINUTES: 15
      # Override battery threshold
      LOW_BATTERY_THRESHOLD: 20
      # Override notification cooldown (10 minutes)
      NOTIFICATION_COOLDOWN_SECONDS: 600
      # Override history retention
      NOTIFICATION_HISTORY_DAYS: 60
      # Override location history fetch duration     
      HISTORY_DURATION_DAYS: 14
      # ANISETTE_SERVERS: "https://anisette.example.com,http://localhost:6969"
// --------------------
// README.md
# FindMy WebApp - A Multi-User Find My Alternative

[![Build Status](https://img.shields.io/github/actions/workflow/status/ghd182/findmy-multiuser/ci.yml?branch=main&style=flat-square)](https://github.com/ghd182/findmy-multiuser/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg?style=flat-square)](https://opensource.org/licenses/MIT)
<!-- Add other relevant badges like code coverage, version, etc. -->

A self-hosted, multi-user web application designed as an alternative to Apple's Find My service, focusing on tracking Apple devices (like AirTags, iPhones, MacBooks using `pyfindmy`) with a modern Material 3 interface.

![Screenshot Placeholder](docs/screenshot-placeholder.png)
*(Add screenshots of the app here)*

## Overview

This project provides a web interface accessible from any device to locate your Apple accessories. It fetches location data periodically using the `pyfindmy` library and presents it on an interactive map. Key features include multi-user support, geofencing with notifications, low battery alerts, location history, and a responsive Material 3 design inspired by recent Android UI. It's designed to be easily deployable via Docker, especially suitable for home servers like a Raspberry Pi.

## Key Features

*   **Multi-User Support:** Secure user registration and login. Each user manages their own Apple credentials and device data independently.
*   **Apple Device Tracking:** Locates accessories linked to an Apple ID using the `pyfindmy` library. Supports devices using `.plist` or `.keys` files.
*   **Interactive Map:** Displays device locations on an OpenStreetMap base layer using Leaflet.js. Includes device icons, popups with details, and map controls.
*   **Location History:** View the recent location history trail for devices on the map, with a time filter slider.
*   **Material 3 Design:** Modern, responsive interface adhering to Material 3 guidelines, including Light/Dark modes and dynamic color theming based on user preference.
*   **Geofencing:** Create custom circular geofence zones on the map.
*   **Geofence Notifications:** Link geofences to specific devices and receive push notifications upon entry or exit.
*   **Low Battery Alerts:** Receive push notifications when a device's battery level falls below a configurable threshold.
*   **Push Notifications:** Uses Web Push API for real-time alerts (requires VAPID key setup and user permission).
*   **Notification History:** View a history of notifications sent by the backend.
*   **PWA Support:** Installable as a Progressive Web App for a more native feel, with basic offline support for the app shell.
*   **Device Configuration:** Customize device display names, map icon labels (emojis), and colors.
*   **Secure Credential Storage:** Apple passwords are encrypted using Fernet (requires `FERNET_SEED` or `FERNET_KEY`).
*   **Configuration Import/Export:** Backup and restore user configuration (devices, geofences, settings) via JSON.
*   **Account Management:** Users can delete their account and all associated data.
*   **Dockerized:** Easy deployment using Docker and Docker Compose, optimized for `linux/arm64/v8` (Raspberry Pi 4/5).
*   **Seed-Based Key Generation:** Deterministically generates `SECRET_KEY`, `FERNET_KEY`, and VAPID keys from user-provided seed environment variables for easier secret management.

## Technology Stack

*   **Backend:** Python 3.11+, Flask
*   **Device Interaction:** `pyfindmy` library
*   **Frontend:** Vanilla JavaScript (ES Modules), HTML5, CSS3
*   **Mapping:** Leaflet.js
*   **Styling:** Material 3 Design principles (manual CSS variables), Material Icons/Symbols
*   **WSGI Server:** Waitress
*   **Push Notifications:** `pywebpush`
*   **Security/Encryption:** `cryptography` (Fernet, HKDF), Flask-Login, Flask-WTF (CSRF)
*   **Deployment:** Docker, Docker Compose

## Getting Started

### Prerequisites

*   **Python:** Version 3.11 or higher recommended.
*   **Pip:** Python package installer.
*   **Git:** For cloning the repository.
*   **Docker & Docker Compose:** (Required for Docker/Portainer deployment) Install Docker Engine and Docker Compose V2.
*   **(Optional) Anisette Server:** Required by `pyfindmy` for authentication. Public servers are configured by default, but running your own instance is more reliable.
*   **Apple ID with 2FA:** You will need an Apple ID. **Crucially, if 2FA is enabled (highly recommended), you MUST generate and use an App-Specific Password (ASP).** Your regular Apple ID password will *not* work due to 2FA prompts.
*   **Device Files:** `.plist` or `.keys` files for the Apple devices you want to track.

### Configuration (Environment Variables & Seeds)

This application relies on environment variables for configuration, especially secrets. **It's strongly recommended to use the SEED variables for generating keys.**

1.  **Generate Seeds:** You need three unique, strong, secret phrases. Keep these secure!
    *   **Secret Seed (for Flask `SECRET_KEY`):**
        ```bash
        # Generate a strong hex string (e.g., 64 chars)
        python -c "import secrets; print(secrets.token_hex(32))"
        ```
    *   **Fernet Seed (for `FERNET_KEY`):**
        ```bash
        # Generate another strong hex string
        python -c "import secrets; print(secrets.token_hex(32))"
        ```
    *   **VAPID Seed (for VAPID Keys):**
        ```bash
        # Generate a third strong hex string
        python -c "import secrets; print(secrets.token_hex(32))"
        ```
    *   **Important:** Use *different*, long, unpredictable strings for each seed.

2.  **Set Environment Variables:** Provide these seeds and other required variables depending on your deployment method (see below).

    **Required Variables:**
    *   `FLASK_ENV`: Set to `production` (recommended for Docker/Portainer) or `development` (for local).
    *   `SECRET_SEED`: Your generated seed for the Flask secret key.
    *   `FERNET_SEED`: Your generated seed for the encryption key.
    *   `VAPID_SEED`: Your generated seed for VAPID push notification keys.
    *   `VAPID_CLAIMS_EMAIL`: Your email address, prefixed with `mailto:` (e.g., `mailto:your_email@example.com`). Required for VAPID.
    *   `TZ`: Your timezone (e.g., `Europe/Amsterdam`, `America/New_York`). See [List of tz database time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).

    **Optional Variables (Defaults are in `config.py`):**
    *   `LOG_LEVEL`: `DEBUG`, `INFO`, `WARNING`, `ERROR` (Default: `INFO`).
    *   `WAITRESS_THREADS`: Number of worker threads for Waitress (Default: `4`).
    *   `LOW_BATTERY_THRESHOLD`: Battery percentage to trigger low battery alert (Default: `15`).
    *   `DEFAULT_FETCH_INTERVAL_MINUTES`: Default background fetch interval per user (Default: `10`).
    *   `FETCH_INTERVAL_MINUTES`: Global background fetch interval trigger (Default: `5`). *Note: User-specific interval overrides this if set.*
    *   `HISTORY_DURATION_DAYS`: How many days of location history to fetch from Apple (Default: `7`).
    *   `NOTIFICATION_COOLDOWN_SECONDS`: Min seconds between similar notifications per device (Default: `300`).
    *   `NOTIFICATION_HISTORY_DAYS`: How many days of notification history to keep (Default: `30`).
    *   `ANISETTE_SERVERS`: Comma-separated list of Anisette server URLs (Default: `https://anisette.ghed.ovh`).

### 1. Local Development Setup

1.  **Clone:** `git clone https://github.com/ghd182/findmy-multiuser.git && cd findmy-multiuser`
2.  **Virtual Env:**
    ```bash
    python -m venv venv
    # Activate:
    # Windows: venv\Scripts\activate
    # Linux/macOS: source venv/bin/activate
    ```
3.  **Install:** `pip install -r requirements.txt`
4.  **Configure:** Create a `.env` file in the project root:
    ```dotenv
    # .env (for local development)
    FLASK_ENV=development
    LOG_LEVEL=DEBUG
    TZ=Europe/Amsterdam # CHANGE ME

    # --- Key Generation Seeds (REPLACE WITH YOUR GENERATED SECRETS!) ---
    SECRET_SEED="replace-this-with-your-very-long-and-random-secret-phrase-for-sessions"
    FERNET_SEED="replace-this-with-your-another-different-long-random-secret-phrase-for-encryption"
    VAPID_SEED="replace-this-with-your-a-third-unique-long-random-phrase-for-push-keys"

    # --- Other Required Variables ---
    VAPID_CLAIMS_EMAIL="mailto:your_email@example.com" # CHANGE ME

    # --- Optional Overrides ---
    # LOW_BATTERY_THRESHOLD=20
    # FETCH_INTERVAL_MINUTES=10
    ```
5.  **Run:** `python run.py`
6.  **Access:** Open `http://localhost:5000` in your browser.

### 2. Docker Setup (using Docker Compose)

1.  **Clone:** `git clone https://github.com/ghd182/findmy-multiuser.git && cd findmy-multiuser`
2.  **Configure `docker-compose.yml`:** Edit the `environment:` section in `docker-compose.yml`. Set `FLASK_ENV=production`, `TZ`, `VAPID_CLAIMS_EMAIL`, and **replace the placeholder seed values** with your generated secrets. Adjust other optional variables as needed.
    ```yaml
      # ... inside services: findmyapp: ...
      volumes:
        - ./data:/app/data # Ensure this path works for you, or use absolute
      environment:
        FLASK_ENV: production
        LOG_LEVEL: INFO
        TZ: Europe/Amsterdam # CHANGE ME
        WAITRESS_THREADS: 8

        # --- Key Generation Seeds (REPLACE THESE!) ---
        SECRET_SEED: "replace-this-with-your-very-long-and-random-secret-phrase-for-sessions"
        FERNET_SEED: "replace-this-with-your-another-different-long-random-secret-phrase-for-encryption"
        VAPID_SEED: "replace-this-with-your-a-third-unique-long-random-phrase-for-push-keys"

        # --- Other Required Variables ---
        VAPID_CLAIMS_EMAIL: "mailto:your_email@example.com" # CHANGE ME
        # ... other optional variables ...
    ```
3.  **Build (Optional):** `docker compose build` (needed if you change Python code or `requirements.txt`)
4.  **Run:** `docker compose up -d`
5.  **Access:** Open `http://<your-docker-host-ip>:5000` (or `http://localhost:5000` if running Docker locally).
6.  **Data:** User data is stored in the `./data` directory on your host, mapped into the container.

### 3. Portainer Setup (Stack Deployment)

1.  **Prepare Host:** Ensure Docker is running on the host managed by Portainer. Clone the repository onto that host (e.g., `/home/user/findmy-webapp`).
2.  **Prepare Stack Definition:**
    *   Copy the contents of `docker-compose.yml`.
    *   **Crucially, change the `volumes:` path to an *absolute path* on the host machine** where you cloned the repo (e.g., `- /home/user/findmy-webapp/data:/app/data`).
    *   Verify/Set all environment variables under `environment:`, especially the **SEED variables** and `TZ`, `VAPID_CLAIMS_EMAIL`.
3.  **Deploy in Portainer:**
    *   Go to "Stacks" -> "Add stack".
    *   Give it a name (e.g., `findmyapp`).
    *   Select "Web editor".
    *   Paste your modified stack definition (YAML) into the editor.
    *   Click "Deploy the stack".
4.  **Access:** Open `http://<your-host-ip>:5000`.

## Usage

1.  **Access:** Open the web application URL in your browser.
2.  **Register/Login:** Create a user account or log in.
3.  **Set Apple Credentials:** Navigate to `Settings` -> `Apple Credentials`. Enter your Apple ID email and **App-Specific Password (ASP)**. Save. An initial data fetch will be triggered.
4.  **Upload Device Files:** Navigate to `Settings` -> `Manage Device Files`. Upload the `.plist` or `.keys` files for your Apple accessories. The app will attempt another fetch.
5.  **View Map:** Go to the `Map` tab to see device locations. Use controls to zoom, center, show all, or toggle history.
6.  **View Devices:** Go to the `Devices` tab for a list view. Click a device to center the map on it. Use the menu (`...`) for options like editing display info or managing geofence links.
7.  **Manage Geofences:** Go to the `Geofences` tab. Create global geofences, then link them to specific devices and configure entry/exit notifications.
8.  **Configure Settings:** Explore the `Settings` page to manage theme, map defaults, notification preferences, import/export configuration, and manage your account.

## Troubleshooting / FAQ

*   **Login Failed / Background Fetch Errors / 2FA Required:**
    *   **Most Common Cause:** You are likely using your regular Apple ID password instead of an **App-Specific Password (ASP)**. If your Apple ID has 2FA enabled, you *must* generate an ASP via `appleid.apple.com` (Sign-In and Security -> App-Specific Passwords) and use that ASP in the password field within this app.
*   **No Devices Showing:**
    *   Ensure you have saved valid Apple credentials (ASP!).
    *   Ensure you have uploaded the correct `.plist` or `.keys` files for your devices in Settings.
    *   Wait for the background fetch interval (`FETCH_INTERVAL_MINUTES`) or trigger a manual refresh on the "Devices" page. Check server logs (`docker compose logs findmyapp`) for fetch errors.
*   **Notifications Not Working:**
    *   Did you grant notification permission in your browser for this site? Check Settings -> Notifications.
    *   Are VAPID keys generated/configured correctly via seeds or env vars? Is `VAPID_CLAIMS_EMAIL` set? Check server startup logs.
    *   Did you subscribe successfully? Check Settings -> Notifications status.
    *   Are Geofence entry/exit notifications enabled for the specific device/geofence link?
    *   Is the Low Battery Threshold set appropriately?
    *   Is the Notification Cooldown period active?
*   **Map Issues (Blank, Not Loading):**
    *   Try clearing your browser cache and reloading.
    *   Check your internet connection.
    *   Check the browser's developer console (F12) for JavaScript errors related to Leaflet or map tiles.
*   **Docker: Permission Denied errors related to `./data`:**
    *   The Docker container runs as a non-root user internally. The host directory (`./data`) needs to be writable by the user ID the container runs as (or be world-writable, less secure). You might need to adjust permissions on the host: `sudo chown -R <UID>:<GID> ./data` (find UID/GID via `id -u` / `id -g` on the host if needed, or check Dockerfile) or use Docker volume management strategies.
*   **VAPID Keys Failed to Generate from Seed:**
    *   The error log might mention "Derived VAPID private key scalar... outside the valid range". This is a rare but possible outcome of deriving EC keys from arbitrary seeds. **Solution:** Choose a *different* strong random string for `VAPID_SEED` and restart the application.
*   **How to Update the App?**
    *   **Local:** `git pull origin main`, activate venv, `pip install -r requirements.txt`, restart `python run.py`.
    *   **Docker:** `git pull origin main`, `docker compose build` (if code changed), `docker compose up -d`.
    *   **Portainer:** `git pull origin main` on the host, then go to your Stack in Portainer, click "Editor", ensure the image tag is correct (e.g., `ghd182/findmy-app:latest` or your build tag), and click "Update the stack" (select "Re-pull image and redeploy" if using a `:latest` tag or if the image was rebuilt).
*   **Where is my data stored?**
    *   User accounts, device configs, geofences, states, credentials, etc., are stored as JSON files within the `data/` directory, organized by username. In Docker/Portainer, this corresponds to the host directory mapped to `/app/data`.

## Contributing

Contributions are welcome! Please feel free to open an issue to report bugs or suggest features. If you'd like to contribute code:

1.  Fork the repository.
2.  Create a new branch (`git checkout -b feature/your-feature-name`).
3.  Make your changes.
4.  Ensure code follows basic Python/JS standards (consider adding linters like Flake8, Prettier).
5.  Write tests if applicable (tests are currently minimal).
6.  Commit your changes (`git commit -am 'Add some feature'`).
7.  Push to the branch (`git push origin feature/your-feature-name`).
8.  Open a Pull Request.

## Future Improvements / Roadmap

*   **Database Backend:** Migrate from JSON files to SQLite or PostgreSQL for better performance, scalability, and reduced risk of race conditions.
*   **Play Sound / Lost Mode:** Implement actions available via `pyfindmy` if permissions allow.
*   **API Optimizations:** Implement pagination or filtering for device history endpoints.
*   **Async Operations:** Refactor I/O bound tasks (fetching, potentially DB access) using `asyncio`.
*   **Security Enhancements:** Implement Rate Limiting (Flask-Limiter) and Content Security Policy (CSP).
*   **UI/UX Polish:** Add skeleton loaders, improve map marker clustering (Leaflet.markercluster), enhance accessibility.
*   **Device Sharing:** Allow users to securely share the location of specific devices with other users.
*   **Improved Offline Cache:** Use Service Worker to cache last known locations for offline map viewing.
*   **Custom Map Layers:** Allow users to switch between different map tile providers (OSM, Satellite etc.).
*   **Battery History:** Store and visualize battery level history.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details (or choose another license and update).

## Credits & Acknowledgements
*   **OpenHaystack:** For the inspiration and the initial idea of a self-hosted Find My alternative. ([https://github.com/seemoo-lab/openhaystack](https://github.com/seemoo-lab/openhaystack))
*   **Dadoum:** For providing the necessary services to authenticate with Apple. ([https://github.com/Dadoum/anisette-v3-server](https://github.com/Dadoum/anisette-v3-server))
*   **`FindMy.py`:** The core library enabling interaction with Apple's Find My network. ([https://github.com/malmeloo/FindMy.py](https://github.com/malmeloo/FindMy.py))
*   **Flask:** The Python web framework. ([https://flask.palletsprojects.com/](https://flask.palletsprojects.com/))
*   **Leaflet:** The interactive JavaScript map library. ([https://leafletjs.com/](https://leafletjs.com/))
*   **Material Design:** Google's design system inspiring the UI.
*   **pywebpush & VAPID:** For enabling Web Push notifications.
*   **Cryptography:** For Fernet encryption and HKDF.
*   **Waitress:** WSGI server.
*   **(Inspiration):** Apple's Find My service (❤️‍🩹).
// --------------------
// requirements.txt
# requirements.txt (Ensure these versions, especially cryptography)
aiohappyeyeballs==2.4.4
aiohttp==3.11.11
aiosignal==1.3.2
asgiref==3.8.1
attrs==25.1.0
beautifulsoup4==4.12.3
bleak==0.22.3
blinker==1.9.0
certifi==2024.12.14
cffi==1.17.1
charset-normalizer==3.4.1
click==8.1.8
colorama==0.4.6
cryptography==44.0.0
email_validator>=1.1
filelock==3.18.0
FindMy==0.7.6
Flask==3.1.0
Flask-Executor==1.0.0
Flask-Login==0.6.3
Flask-WTF>=1.0.0
frozenlist==1.5.0
h11==0.14.0
http_ece==1.2.1
idna==3.10
itsdangerous==2.2.0
Jinja2==3.1.5
MarkupSafe==3.0.2
multidict==6.1.0
propcache==0.2.1
py-vapid==1.9.2
pycparser==2.22
python-dotenv==1.0.1
pywebpush==2.0.3
requests==2.32.3
six==1.17.0
soupsieve==2.6
srp==1.0.22
typing_extensions==4.12.2
urllib3==2.3.0
# uvicorn not strictly needed if using Waitress/Gunicorn
waitress==3.0.2
Werkzeug==3.1.3
yarl==1.18.3
APScheduler>=3.9.0 # Ensure version
regex==2024.11.6 # optional for generate_svg, can be added if needed
# geopy removed, using manual haversine
// --------------------
// run.py
# run.py
import os
import logging
import signal
import sys
import time
from dotenv import load_dotenv

load_dotenv()

# Import create_app and the background_scheduler instance
from app import create_app, background_scheduler

# --- Logging Setup ---
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
numeric_level = getattr(logging, LOG_LEVEL, None)
if not isinstance(numeric_level, int):
    logging.warning(f"Invalid LOG_LEVEL '{LOG_LEVEL}'. Defaulting to INFO.")
    LOG_LEVEL = "INFO"
    numeric_level = logging.INFO
logging.basicConfig(
    level=numeric_level,
    format="%(asctime)s - %(levelname)s - [%(threadName)s:%(name)s] - %(message)s",
)
logging.getLogger("urllib3").setLevel(logging.WARNING)
logging.getLogger("apscheduler").setLevel(
    logging.INFO
)  # Keep INFO level for debugging startup
logging.getLogger("pywebpush").setLevel(logging.INFO)
logging.getLogger("findmy").setLevel(logging.INFO)
log = logging.getLogger(__name__)
log.critical(
    f"########## LOGGING LEVEL IS SET TO: {LOG_LEVEL} ({logging.getLogger().getEffectiveLevel()}) ##########"
)
# --- End Logging Setup ---

# --- Create the Flask App ---
# This adds the jobs via create_app -> schedule_jobs
log.info("Creating Flask app instance...")
app = create_app()
log.info("Flask app instance created.")

# --- Start Scheduler (Moved Here) ---
# This logic now runs whether run.py is executed directly or imported by WSGI server
if not app.config.get("TESTING", False):
    log.info(
        f"Checking scheduler status before start. Is running: {background_scheduler.running}, State: {background_scheduler.state}"
    )
    if not background_scheduler.running:
        try:
            log.info("Attempting to start the background scheduler...")
            background_scheduler.start()
            time.sleep(0.1)  # Give a moment for state update
            log.info(
                f"Scheduler start() called. Current state: {background_scheduler.state}, Is running: {background_scheduler.running}"
            )
        except Exception as e:
            log.error(f"Failed to start scheduler: {e}", exc_info=True)
    else:
        # This might happen if the WSGI server somehow restarts the worker/thread
        # without restarting the main process where the scheduler was initially started.
        # It's less common with Waitress but good to log.
        log.warning("Scheduler reported as already running before explicit start call.")
else:
    log.info("Detected TESTING environment, scheduler start skipped.")
# --- End Scheduler Start ---


# --- Signal Handling for Graceful Shutdown ---
def shutdown_handler(signum, frame):
    log.warning(f"Received signal {signum}. Shutting down scheduler...")
    # Check if scheduler exists and is running before trying to shut down
    if "background_scheduler" in globals() and background_scheduler.running:
        try:
            background_scheduler.shutdown(wait=False)
            log.info("Scheduler shut down.")
        except Exception as e:
            log.error(f"Error shutting down scheduler: {e}")
    else:
        log.info("Scheduler not running or not initialized, skipping shutdown.")
    log.warning("Exiting application.")
    sys.exit(0)


signal.signal(signal.SIGTERM, shutdown_handler)
signal.signal(signal.SIGINT, shutdown_handler)


# --- Main Execution Block ---
# This block now *only* runs when executing 'python run.py' directly.
# It's primarily for local development or if the Docker CMD was 'python run.py'.
if __name__ == "__main__":
    log.info("Entered __main__ block (direct execution).")
    # The scheduler is already started above. We just need to start Waitress.
    try:
        from waitress import serve

        host = os.getenv("HOST", "0.0.0.0")
        port = int(os.getenv("PORT", 5000))
        threads = int(os.getenv("WAITRESS_THREADS", 4))
        log.info(
            f"Starting Waitress server via __main__ on http://{host}:{port} with {threads} threads..."
        )

        serve(app, host=host, port=port, threads=threads, backlog=2048)

    except ImportError:
        log.critical("Waitress not found! Cannot start server.")
        sys.exit(1)
    except Exception as e:
        log.exception(f"An error occurred starting Waitress via __main__: {e}")
        # Attempt to shut down scheduler before exiting
        if "background_scheduler" in globals() and background_scheduler.running:
            try:
                background_scheduler.shutdown(wait=False)
            except:
                pass
        sys.exit(1)

# This 'else' block runs when the script is imported (e.g., by Waitress via Docker CMD 'run:app')
else:
    log.info(
        "Script imported, not run directly. Assuming WSGI server manages execution. Scheduler started above."
    )
    # No need to do anything here, the scheduler was started globally above,
    # and the WSGI server (Waitress) will serve the 'app' object created earlier.

// --------------------
// test_import.py
# test_import.py
try:
    import flask_wtf
    print("Flask-WTF imported successfully")
    print(f"Version: {flask_wtf.__version__}")
    print(f"Path: {flask_wtf.__file__}")
except ImportError as e:
    print(f"Import error: {e}")
// --------------------
// TODO.md
**Potential Improvements & New Features:**

1.  **Security:**
    *   **CSRF Protection:** Implement CSRF tokens (e.g., using Flask-WTF or Flask-SeaSurf) for all forms (Login, Register, Credentials, potentially API actions modifying data) to prevent cross-site request forgery. This involves adding a hidden token field to forms and validating it on the server.
    *   **Rate Limiting:** Consider adding rate limiting to login attempts and potentially API endpoints to mitigate brute-force attacks (e.g., using Flask-Limiter).
    *   **Content Security Policy (CSP):** Implement a strict CSP header to reduce the risk of XSS attacks by defining allowed sources for scripts, styles, images, etc.
    *   **Session Cookie Security:** Ensure session cookies use `HttpOnly`, `Secure` (if HTTPS is enforced), and `SameSite=Lax` or `SameSite=Strict` attributes. Flask's defaults are usually good, but verify.

2.  **UX/UI:**
    *   **Loading States:** Provide more granular loading feedback. Instead of just a spinner on the device list, perhaps show skeleton loaders or disable interactions more selectively. Show a spinner or progress indicator in the app bar during background refreshes triggered by the scheduler.
    *   **Error Handling:** Make error messages in dialogs more user-friendly and less technical where appropriate. Perhaps add a "Retry" button for network errors.
    *   **Map Interactions:**
        *   Consider clustering markers if many devices are close together (e.g., using `Leaflet.markercluster`).
        *   Highlight the selected device's marker more prominently on the map.
        *   Allow clicking on a history point on the map to show its details.
    *   **Accessibility:** Review ARIA attributes, keyboard navigation (especially for custom elements like menus and map controls), and color contrast ratios to ensure better accessibility. Add `aria-live` regions for status updates (like "Last Updated").
    *   **Smooth Transitions:** Use CSS transitions more consistently for elements appearing/disappearing (like the history slider, search results) for a smoother feel.

3.  **Performance:**
    *   **Code Splitting:** For larger applications, consider splitting the JavaScript into smaller chunks that are loaded on demand (though maybe overkill for this size yet).
    *   **Image Optimization:** Ensure icons are reasonably sized. SVG is generally good.
    *   **API Payload Size:** If device history becomes very large, consider options for the `/api/devices` endpoint:
        *   Return only the *latest* report by default.
        *   Add a separate endpoint `/api/devices/<id>/history` to fetch full history on demand when the user views history details.
        *   Add parameters to `/api/devices` to request history within a specific time range.

4.  **New Features:**
    *   **Play Sound / Lost Mode:** Add buttons in the device menu dialog (if the `findmy` library and Apple account permissions allow these actions). This requires adding corresponding API endpoints and backend logic in `apple_data_service.py` to interact with the `findmy` library functions for these actions.
    *   **Manual Location Refresh:** Add a dedicated "Refresh Location Now" button per device (in the menu?) that triggers an immediate fetch *just for that device* (might require adjusting backend task triggering).
    *   **Custom Map Layers:** Add a map layer control (e.g., Leaflet's built-in control) allowing users to switch between OpenStreetMap, satellite imagery (if a provider is chosen, e.g., Mapbox with an API key), or potentially other tile layers.
    *   **Battery History:** Store and visualize battery level history for devices (similar to location history).
    *   **Offline Cache:** Improve the service worker to cache the last known locations from the `/api/devices` response, allowing the map to display *something* even when offline. The SW's fetch handler would need to intercept `/api/devices` requests, try the network, and fall back to the cache if offline.



Okay, let's continue the development, focusing on analyzing the existing structure, identifying issues, fixing them, and planning improvements based on your requirements (Material 3, Find My alternative, new features).

**Phase 1: Analysis and Immediate Fixes**

**1. Analysis of Existing Code & Structure:**

*   **Overall Structure:** The Flask application structure is logical, separating concerns into blueprints (auth, main/api), services, models, utils, etc. This is good practice for maintainability.
*   **Dockerization:** Good setup for containerization and deployment, especially targeting ARM64 for Raspberry Pi. `ProxyFix` is correctly included in `app/__init__.py`, which is crucial when running behind a reverse proxy (like Nginx or Traefik, common with Docker).
*   **Configuration (`config.py`):** Centralized config using environment variables and `.env` is good. Separate configs for dev/prod/test are standard. The inclusion of `FILE_LOCKS` directly in the config is a bit unusual but workable for initializing locks centrally. CSRF protection is now explicitly enabled (`WTF_CSRF_ENABLED = True`). Encryption via Fernet is included and conditional, which is good, with appropriate warnings if disabled.
*   **Authentication (`auth/`, `models.py`):** Uses Flask-Login and WTForms, which is standard and secure. Password hashing is correctly implemented. The `User.get` method correctly uses `UserDataService`. The `before_request` hook in `app/__init__.py` handles auth checks and credential requirements effectively, redirecting appropriately. CSRF protection is integrated via `form.validate_on_submit()`. Logout now clears credentials and redirects directly to login.
*   **Core App (`main/routes.py`, `main/api.py`):**
    *   `routes.py`: Serves the main app shell (`index.html`) and the Apple credentials management page. The `manage_apple_creds` route correctly uses the `AppleCredentialsForm` and triggers an immediate fetch on save. `sw.js` and `favicon.ico` serving looks standard.
    *   `api.py`: Provides endpoints for core data (devices, geofences), actions (subscribe, file upload), configuration management, and utilities. Uses `UserDataService` and `NotificationService`. **Crucially, it now formats device data using `format_latest_report_for_api` which relies on the config loaded by `UserDataService`.** Includes new endpoints for user preferences, notification history, and account deletion.
*   **Services (`services/`):**
    *   `UserDataService`: This is the backbone for data persistence. It handles JSON loading/saving with **atomic writes** and **locks**, which is essential for preventing data corruption with concurrent access (e.g., from scheduler and web requests). It correctly validates and structures data on load/save (e.g., device config merging, geofence validation). Encryption/decryption logic is centralized. Notification history and user preference CRUD operations are added. Account deletion logic seems robust (removes user entry *then* directory). **The change to store full history in `cache.json` via `apple_data_service` is reflected here.**
    *   `AppleDataService`: Properly interacts with the `findmy` library. Handles login (including 2FA errors), fetches accessory data (now fetches **full history** within the configured duration), and parses reports into a standardized format.
    *   `NotificationService`: Encapsulates notification logic (geofence/battery checks), cooldowns, and sending via `pywebpush`. Uses `UserDataService` for state management and subscription loading. Saves notifications to history. Icon/badge logic is refined based on notification type.
*   **Scheduler (`scheduler/tasks.py`):** The `master_fetch_scheduler_job` iterates users and spawns threads for `run_fetch_for_user_task`, which is a good approach for parallel I/O-bound tasks. Handles missing credentials gracefully. Includes a job for pruning old notification history.
*   **Frontend (`static/`):**
    *   JS modules (`state.js`, `utils.js`, `api.js`, `ui.js`, `map.js`, `notifications.js`, `app.js`) provide good separation.
    *   `state.js` manages client-side state using `localStorage`.
    *   `api.js` wraps fetch calls and now includes CSRF token handling.
    *   `ui.js` handles rendering, dialogs, page changes.
    *   `map.js` handles Leaflet map logic, markers, history trails. **Includes logic for map placeholder.**
    *   `notifications.js` handles SW registration and push subscriptions.
    *   `app.js` orchestrates frontend initialization, including dynamic theme loading using `material-color-utilities` (with fallback).
    *   `style.css`: Implements Material 3 theming using CSS variables, including light/dark modes based on body class. Defines styles for components. **Includes placeholder styles.**
    *   `sw.js`: Provides offline caching for core assets and handles push notifications/clicks.

**2. Identified Issues & Fixes:**

*   **Issue:** Map placeholder displays incorrectly (side-by-side) and doesn't disappear smoothly.
    *   **Analysis:** The HTML structure (`#map-placeholder` inside `.map-container`) is correct, but the CSS likely needs adjustment for absolute positioning. The JS logic for hiding it needs to be tied correctly to map readiness (`invalidateSize`).
    *   **Fix:**
        *   **`style.css`:** Updated `#map-placeholder` styles to use `position: absolute`, cover the container (`top/left/width/height`), use `z-index` to be above the map but below controls, and added `opacity`/`visibility` transitions controlled by a `.visible` class. Added background color using CSS variable with alpha.
        *   **`map.js` (`initMap`, `invalidateMapSize`):**
            *   `initMap`: Calls `showMapPlaceholder` at the start. The `onMapReady` function (triggered by `load` or timeout) now calls `hideMapPlaceholder`.
            *   `invalidateMapSize`: Calls `showMapPlaceholder`. Uses `requestAnimationFrame` and a short `setTimeout` to ensure `invalidateSize` completes rendering *before* hiding the placeholder, creating a smoother transition.
*   **Issue:** Potential race condition or complex locking in `UserDataService.save_user_preferences` when multiple requests/threads try to update `users.json`.
    *   **Analysis:** The original implementation might have held the lock for too long, or concurrent reads/writes could lead to lost updates.
    *   **Fix:** Refactored `save_user_preferences` in `user_data_service.py` to use an optimistic locking approach: load data outside lock -> modify -> acquire lock -> re-read data inside lock -> check for conflicts -> save if no conflict -> retry on conflict. This minimizes lock duration.
*   **Issue:** Notification history file (`notifications_history.json`) was likely being treated as a dictionary by `load_json_file`/`save_json_atomic`, but it should be a list (newest first).
    *   **Analysis:** The generic JSON helpers assumed dictionaries. Saving a new entry likely overwrote the whole file instead of appending/prepending.
    *   **Fix:** Modified `UserDataService` methods (`load_notification_history`, `save_notification_history`, `update_notification_read_status`, `delete_notification_history`, `prune_notification_history`) to explicitly handle a **list** structure for this specific file. Loading checks if the loaded data is a list, saving prepends to the list, and pruning/updating iterates the list.
*   **Issue:** VAPID claims might not use the user's registered email.
    *   **Analysis:** The fallback email from config was used if fetching user data failed.
    *   **Fix:** Refined `_get_vapid_claims` in `notification_service.py` to reliably fetch the user's email from `UserDataService` and only fall back to the config email if the user has no email set.
*   **Issue:** CSRF protection wasn't explicitly handled for API calls made via JS fetch.
    *   **Analysis:** Flask-WTF protects form submissions, but AJAX calls need the token sent in a header.
    *   **Fix:** Added logic to `api.js` (`_fetch` function) to retrieve the CSRF token from the `<meta>` tag (rendered by `{{ csrf_token() }}` in templates) and include it in the `X-CSRFToken` header for non-GET requests. Added CSRF error handler in `app/__init__.py`.
*   **Issue:** Logout flow was slightly awkward (redirecting to a dedicated `/logged-out` page).
    *   **Analysis:** While functional, a direct redirect back to login after logout is more standard UX.
    *   **Fix:** Modified `auth/routes.py` (`logout_route`) to flash the logout message and redirect directly to `auth.login_route`. Removed the `/logged-out` route and `logout_success.html` template.
*   **Issue:** File upload API allowed any file type if the `.keys` or `.plist` check was bypassed (e.g., incorrect check logic).
    *   **Analysis:** The `allowed_file` check in `api.py` needed verification.
    *   **Fix:** Corrected the `allowed_file` check logic in `api.py`'s `upload_device_file` route to correctly check against the allowed extensions set.
*   **Issue:** Service worker registration might fail silently or cause confusion if not served from root or if scope/headers are wrong. Push notification icons weren't using backend-provided URLs.
    *   **Analysis:** The `sw.js` path and scope need to be correct. The push event handler was generating icon URLs client-side.
    *   **Fix:**
        *   Ensured `sw.js` is served from `/sw.js` via `main/routes.py`.
        *   Added `Service-Worker-Allowed: /` header in the route serving `sw.js`.
        *   Modified `sw.js` push event handler to use the `icon` and `badge` URLs directly from the push payload (sent by `notification_service.py`).
        *   Refined error handling in `notifications.js` `registerServiceWorker`.
*   **Issue:** Theme initialization could have race conditions with loading user preferences and Material Color Utilities library.
    *   **Analysis:** `app.js` needed to ensure state/prefs were loaded *before* initializing the theme, and that the color library was available.
    *   **Fix:** Restructured `initializeApp` in `app.js`: Load state -> Fetch prefs -> Load/Check color lib -> Initialize Theme -> Setup UI -> Register SW -> Fetch Data. Added robust fallback loading for the color library.
*   **Issue:** Device marker SVG icons might not generate correctly if `label` or `color` is missing/invalid, or if the `regex` library isn't available.
    *   **Analysis:** The `generate_device_icon_svg` helper needed hardening.
    *   **Fix:** Updated `utils/helpers.py` `generate_device_icon_svg` to handle missing/invalid inputs gracefully, provide fallbacks, use default colors, and conditionally use the `regex` library for better multi-character emoji handling if available. Updated `map.js` `getDeviceLeafletIcon` to use the backend-provided SVG or call the JS fallback `AppUtils.generateDeviceIconSVG`.

**3. Code Implementation (Incorporated into the provided file structure):**

The code provided in the prompt now reflects the implementation of these fixes. Key changes highlighted include:

*   `app/static/css/style.css`: Updated `#map-placeholder` styles.
*   `app/static/js/map.js`: Updated `initMap`, `invalidateMapSize`, `showMapPlaceholder`, `hideMapPlaceholder`.
*   `app/services/user_data_service.py`: Refactored `save_user_preferences`, fixed notification history list handling, refined `delete_user_data` locking.
*   `app/services/notification_service.py`: Updated `_get_vapid_claims`, push handler icon/badge logic.
*   `app/static/js/api.js`: Added CSRF header logic.
*   `app/auth/routes.py`: Updated `logout_route`.
*   `app/main/api.py`: Corrected `allowed_file` check. Added `re` import.
*   `app/__init__.py`: Added CSRF error handler, refined `before_request`.
*   `app/main/routes.py`: Updated `service_worker` route.
*   `app/utils/helpers.py`: Updated `generate_device_icon_svg`.
*   `app/static/js/app.js`: Refactored initialization sequence, `AppTheme` logic.
*   `app/static/sw.js`: Updated push event handler icon logic.
*   Relevant `templates/*.html` files updated for CSRF tokens and form handling.

---

**Phase 2: Potential Improvements & New Features**

Based on the analysis and your request, here are potential improvements and new features (expanding on the README):

**Improvements & Optimizations:**

1.  **Database Backend:**
    *   **Problem:** File-based storage (JSON, plist, keys) can be slow, prone to race conditions (despite locks), and doesn't scale well for many users or large histories. Searching/querying is inefficient.
    *   **Solution:** Migrate to a database.
        *   **SQLite:** Simple, good for single-server deployments (like a Pi), handles concurrency better than file locks. Store user accounts, device configs, geofences, push subscriptions, states, and potentially history reports. Add `Flask-SQLAlchemy` or use the `sqlite3` module directly.
        *   **PostgreSQL/MySQL:** More robust, better for potential future scaling, network access.
        *   **Redis:** Could be used for caching frequently accessed data (like latest locations, session data) instead of or alongside JSON cache files.
    *   **Impact:** Requires significant refactoring of `UserDataService` and potentially parts of other services/API endpoints. Improves performance, reliability, and scalability.
2.  **API Payload Optimization:**
    *   **Problem:** `/api/devices` currently sends the *entire* history for all devices every time, which can be large and slow.
    *   **Solution:**
        *   Modify `/api/devices` to accept parameters like `?history=latest` (default) or `?history_since=<timestamp>` or `?history_limit=N`. Only return the requested amount of history.
        *   Add a new endpoint like `/api/devices/<device_id>/history?start=<ts>&end=<ts>` to fetch detailed history on demand (e.g., when the user opens the history view for a specific device).
    *   **Impact:** Changes in `api.py`, `apple_data_service.py` (to filter reports before returning), and frontend JS (`api.js`, `state.js`, `map.js`) to fetch history separately when needed.
3.  **Asynchronous Operations:**
    *   **Problem:** The `findmy` library calls are likely blocking I/O. While threading helps, `asyncio` might be more efficient for high I/O workloads.
    *   **Solution:** If `findmy` supports async or can be run in a thread pool executor using `asyncio`, refactor `apple_data_service.py` and `scheduler/tasks.py` to use `async/await`. Use an async web framework/server (like `uvicorn` with Flask or switching to FastAPI/Quart). Use `aiohttp` for external requests (like Anisette).
    *   **Impact:** Major refactoring, potentially changing the web framework. Significant performance gain potential for I/O-bound tasks.
4.  **Rate Limiting:**
    *   **Problem:** Login/registration and potentially some API endpoints are vulnerable to brute-force or denial-of-service attacks.
    *   **Solution:** Implement rate limiting using `Flask-Limiter`. Apply limits to `auth` routes and sensitive/expensive API endpoints.
    *   **Impact:** Add dependency, configure extension in `app/__init__.py`, apply decorators to routes. Increases security.
5.  **Content Security Policy (CSP):**
    *   **Problem:** Risk of Cross-Site Scripting (XSS) if any user input is ever rendered improperly or if external scripts are compromised.
    *   **Solution:** Define a strict CSP header (e.g., using `Flask-Talisman` or manually setting the header). Specify allowed sources for scripts, styles, images, fonts, connections, etc.
    *   **Impact:** Add configuration/middleware. Might require adjusting how inline scripts/styles are handled (move to static files) or using nonces/hashes. Improves security significantly.
6.  **Frontend Performance:**
    *   **Problem:** As the app grows, JS/CSS file sizes might increase load times.
    *   **Solution:** Consider JS code splitting (dynamic imports), CSS optimization/purging, image optimization (SVGs are good, ensure PNGs are optimized).
    *   **Impact:** Build process changes (e.g., using Webpack/Vite if scaling significantly), minor CSS/JS refactoring.
7.  **Error Reporting:**
    *   **Problem:** Need better visibility into production errors.
    *   **Solution:** Integrate an error tracking service (e.g., Sentry, Rollbar).
    *   **Impact:** Add dependency, configure service key in `.env`/config, initialize in `app/__init__.py`.

**New Features:**

1.  **Play Sound / Lost Mode (High Priority - Core Find My Feature):**
    *   **UI:** Add buttons within the device menu dialog (`AppUI.openDeviceMenu`).
    *   **API:** Create new endpoints in `api.py`, e.g., `POST /api/devices/<device_id>/play_sound` and `POST /api/devices/<device_id>/lost_mode`.
    *   **Backend:** Add corresponding methods in `AppleDataService` that use the `findmy` library's functions (e.g., `account.play_sound(device_id)`, `account.lost_device(...)`). Ensure necessary parameters (like message/phone for lost mode) are passed. Requires careful error handling.
2.  **Manual Location Refresh (Per Device):**
    *   **UI:** Add a "Refresh Now" button to the device menu dialog or device list item. Show a loading state on the button/item.
    *   **API:** Create `POST /api/devices/<device_id>/refresh`.
    *   **Backend:** The API endpoint should trigger `run_fetch_for_user_task` *only for that user*, perhaps with a flag to prioritize or even attempt a targeted refresh if the `findmy` library supports it (unlikely, full fetch is usually needed). Might need adjustments to how the scheduler interacts or a separate ad-hoc task runner (Flask-Executor could be useful here if not already used effectively by the scheduler).
3.  **Custom Map Tile Layers:**
    *   **UI:** Add a Leaflet layer control (`L.control.layers`). Define base layers (e.g., OSM Street, Satellite).
    *   **Backend/Config:** May need API keys for satellite providers (e.g., Mapbox, Stadia Maps - check terms/pricing). Store chosen layer preference in `AppState`/`localStorage`.
    *   **JS:** Update `map.js` to initialize the layer control and add the different `L.tileLayer` instances.
4.  **Battery Level History:**
    *   **Backend:** Modify `AppleDataService` to extract battery level and timestamp from each report. Modify `UserDataService` to store this history (e.g., in `cache.json` alongside location reports, or a separate `battery_history.json`).
    *   **API:** Add endpoint `/api/devices/<device_id>/battery_history` or include it in the history payload of `/api/devices`.
    *   **UI:** Add a chart/graph (e.g., using Chart.js or similar) in the device details view/dialog to visualize battery level over time.
5.  **Enhanced Offline Cache (Service Worker):**
    *   **Problem:** Currently caches app shell, but not dynamic data.
    *   **Solution:** Modify `sw.js`'s `fetch` handler:
        *   Intercept requests to `/api/devices`.
        *   Try fetching from the network first.
        *   If successful, cache the response (e.g., in a separate 'data-cache').
        *   If network fails, attempt to serve the response from the 'data-cache'.
    *   **Impact:** Requires careful cache management (naming, updating, expiration) in `sw.js`. Provides basic offline viewing of last known locations.
6.  **Device Sharing (Multi-User Aspect):**
    *   **Concept:** Allow User A to share the location of one of their devices with User B.
    *   **Implementation:** This is complex.
        *   Need a data model for sharing permissions (e.g., which user shared which device ID with whom, expiry?). Store in database/JSON.
        *   Modify `/api/devices` to return devices owned by the user *plus* devices shared with them.
        *   Modify `run_fetch_for_user_task`: When User A fetches data, if a device is shared, somehow make that latest data available to User B (e.g., write to a shared cache key, push update via WebSocket, or User B fetches it via API knowing the permission exists). Requires careful access control.
        *   UI to manage sharing requests/permissions.
7.  **More Granular Notifications:**
    *   Allow users to configure cooldown periods per device/geofence.
    *   Add options for "left behind" alerts (notify if user's phone moves far away from a specific device).
    *   Allow custom notification sounds (if web push supports it reliably).
8.  **Improved Search:**
    *   Add fuzzy search capabilities.
    *   Allow searching by device model or status.
9.  **UI/UX Polish:**
    *   Skeleton loaders for lists while data fetches.
    *   Smoother transitions (CSS) for dialogs, menus, page changes.
    *   Map marker clustering (`Leaflet.markercluster`) when many devices are shown.
    *   Accessibility review (ARIA attributes, keyboard navigation, color contrast).

---

**Next Steps:**

1.  **Prioritize:** Decide which improvements/features are most important (e.g., Play Sound/Lost Mode seems core).
2.  **Implement Incrementally:** Tackle changes one by one, testing thoroughly.
3.  **Database:** Strongly consider migrating from files to a database (like SQLite initially) sooner rather than later, especially before implementing complex features like device sharing. This will simplify locking and improve performance.
4.  **API Design:** Refine the `/api/devices` endpoint for history handling.
5.  **Share Devices with Others:** Allow users to share the location of one of their devices with others in a path like `/api/devices/<device_id>/share`.
6. **Demo App:** Create a demo app that can be used to showcase the features of the app.
7. **Safety:** Improving overall safety of the app
// --------------------
// app\config.py
# app/config.py

import os
import logging
from dotenv import load_dotenv
from pathlib import Path
import threading  # Keep for locks
from datetime import timedelta  # Add

# Import the new key generation utilities
from .utils.key_utils import (
    generate_fernet_key_from_seed,
    generate_secret_key_bytes_from_seed,
    generate_vapid_keys_from_seed,
)

load_dotenv()
log = logging.getLogger(__name__)

# --- Environment Variable Seeds ---
# Read seed values from the environment
# Provide empty string default to handle unset variables gracefully in logic below
VAPID_SEED = os.getenv("VAPID_SEED", "")
FERNET_SEED = os.getenv("FERNET_SEED", "")
SECRET_SEED = os.getenv("SECRET_SEED", "")

# --- Generate Keys from Seeds (if seeds are provided) ---
# Initialize generated keys to None
generated_vapid_private = None
generated_vapid_public = None
generated_fernet_key = None
generated_secret_key_bytes = None

# Attempt generation only if seed exists
if VAPID_SEED:
    log.info("VAPID_SEED found, attempting to generate VAPID keys...")
    vapid_pair = generate_vapid_keys_from_seed(VAPID_SEED)
    if vapid_pair:
        generated_vapid_private, generated_vapid_public = vapid_pair
        log.info("Successfully generated VAPID keys from seed.")
    # Error is logged within generate_vapid_keys_from_seed

if FERNET_SEED:
    log.info("FERNET_SEED found, attempting to generate Fernet key...")
    generated_fernet_key = generate_fernet_key_from_seed(FERNET_SEED)
    if generated_fernet_key:
        log.info("Successfully generated Fernet key from seed.")
    # Error is logged within generate_fernet_key_from_seed

if SECRET_SEED:
    log.info("SECRET_SEED found, attempting to generate SECRET_KEY...")
    generated_secret_key_bytes = generate_secret_key_bytes_from_seed(SECRET_SEED)
    if generated_secret_key_bytes:
        log.info("Successfully generated SECRET_KEY from seed.")
    # Error is logged within generate_secret_key_bytes_from_seed


class Config:
    """Base configuration."""

    # --- Key Loading Logic (Seed > Environment Variable > Fallback/Disable) ---

    # SECRET_KEY
    _secret_key_env = os.getenv("SECRET_KEY")
    SECRET_KEY = generated_secret_key_bytes or (
        _secret_key_env.encode("utf-8") if _secret_key_env else None
    )
    _using_fallback_secret = False
    if SECRET_KEY:
        if generated_secret_key_bytes:
            log.info("Using SECRET_KEY generated from SECRET_SEED.")
        elif _secret_key_env:
            log.info("Using SECRET_KEY from environment variable.")
    else:
        log.warning(
            "SECRET_KEY not found via seed or env var. Falling back to insecure os.urandom()."
        )
        SECRET_KEY = os.urandom(32)  # Fallback - DO NOT USE IN PRODUCTION
        _using_fallback_secret = True

    # FERNET_KEY
    _fernet_key_env = os.getenv("FERNET_KEY")
    FERNET_KEY = generated_fernet_key or _fernet_key_env
    ENCRYPTION_ENABLED = bool(FERNET_KEY)
    if FERNET_KEY:
        if generated_fernet_key:
            log.info("Using Fernet key generated from FERNET_SEED. Encryption ENABLED.")
        elif _fernet_key_env:
            log.info("Using Fernet key from environment variable. Encryption ENABLED.")
    else:
        log.warning(
            "FERNET_KEY not found via seed or env var. Encryption DISABLED (Using Base64 fallback)!"
        )

    # VAPID Keys
    _vapid_private_env = os.getenv("VAPID_PRIVATE_KEY")
    _vapid_public_env = os.getenv("VAPID_PUBLIC_KEY")
    VAPID_PRIVATE_KEY = generated_vapid_private or _vapid_private_env
    VAPID_PUBLIC_KEY = generated_vapid_public or _vapid_public_env
    VAPID_CLAIMS_EMAIL = os.getenv("VAPID_CLAIMS_EMAIL")  # Still required directly

    VAPID_ENABLED = bool(VAPID_PUBLIC_KEY and VAPID_PRIVATE_KEY and VAPID_CLAIMS_EMAIL)

    if VAPID_PRIVATE_KEY and VAPID_PUBLIC_KEY:
        if generated_vapid_private:
            log.info("Using VAPID keys generated from VAPID_SEED.")
        elif _vapid_private_env:
            log.info("Using VAPID keys from environment variables.")

    if not VAPID_ENABLED:
        log.warning(
            "VAPID keys (from seed or env) or claims email not found/incomplete. "
            "Push notifications DISABLED."
        )
    elif not VAPID_CLAIMS_EMAIL:
        log.warning(
            "VAPID keys are set, but VAPID_CLAIMS_EMAIL is missing. "
            "Push notifications might fail."
        )
    else:
        log.info(
            f"VAPID push notifications ENABLED (Claims Email: {VAPID_CLAIMS_EMAIL})."
        )

    # --- Other Config Variables ---
    DEBUG = False
    TESTING = False
    WTF_CSRF_ENABLED = True
    # ... (rest of the config variables: paths, thresholds, etc. as before) ...
    BASE_DIR = Path(__file__).resolve().parent.parent
    DATA_DIRECTORY = BASE_DIR / "data"
    USERS_FILE = DATA_DIRECTORY / "users.json"
    SHARES_FILE = DATA_DIRECTORY / "shares.json"
    DEFAULT_SHARE_DURATION_HOURS = int(os.getenv("DEFAULT_SHARE_DURATION_HOURS", 24))
    USER_DEVICES_FILENAME = "devices.json"
    USER_GEOFENCES_FILENAME = "geofences.json"
    USER_SUBSCRIPTIONS_FILENAME = "subscriptions.json"
    USER_CACHE_FILENAME = "cache.json"
    USER_GEOFENCE_STATE_FILENAME = "geofence_state.json"
    USER_BATTERY_STATE_FILENAME = "battery_state.json"
    USER_NOTIFICATION_TIMES_FILENAME = "notification_times.json"
    USER_APPLE_CREDS_FILENAME = "apple_credentials.json"
    USER_NOTIFICATIONS_HISTORY_FILENAME = "notifications_history.json"
    NOTIFICATION_HISTORY_DAYS = int(os.getenv("NOTIFICATION_HISTORY_DAYS", 30))
    LOW_BATTERY_THRESHOLD = int(os.getenv("LOW_BATTERY_THRESHOLD", 15))
    NOTIFICATION_COOLDOWN_SECONDS = int(os.getenv("NOTIFICATION_COOLDOWN_SECONDS", 300))
    DEFAULT_FETCH_INTERVAL_MINUTES = int(
        os.getenv("DEFAULT_FETCH_INTERVAL_MINUTES", 15)
    )
    FETCH_INTERVAL_MINUTES = int(os.getenv("FETCH_INTERVAL_MINUTES", 15))
    HISTORY_DURATION_DAYS = int(os.getenv("HISTORY_DURATION_DAYS", 7))
    ANISETTE_SERVERS = [
        s.strip()
        for s in os.getenv("ANISETTE_SERVERS", "http://localhost:6969").split(",")
        if s.strip()
    ]
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
    APP_VERSION = "2.1.1-seed-keys-refined"  # Update version
    SCHEDULER_API_ENABLED = True
    FILE_LOCKS = {  # Initialize structure, locks created in __init__.py
        "users": None,
        "shares": None,
        USER_DEVICES_FILENAME: None,
        USER_GEOFENCES_FILENAME: None,
        USER_SUBSCRIPTIONS_FILENAME: None,
        USER_CACHE_FILENAME: None,
        USER_GEOFENCE_STATE_FILENAME: None,
        USER_BATTERY_STATE_FILENAME: None,
        USER_NOTIFICATION_TIMES_FILENAME: None,
        USER_APPLE_CREDS_FILENAME: None,
        USER_NOTIFICATIONS_HISTORY_FILENAME: None,
    }


class DevelopmentConfig(Config):
    DEBUG = True
    LOG_LEVEL = "DEBUG"
    # SECRET_KEY is handled by base Config logic
    # WTF_CSRF_ENABLED = False # Keep True or False depending on needs
    if not Config.ENCRYPTION_ENABLED:
        log.warning(
            "Running Development without FERNET_KEY (seed or env). Passwords stored insecurely."
        )


class ProductionConfig(Config):
    # --- Stricter Production Checks ---
    if not Config.SECRET_KEY or Config._using_fallback_secret:
        # Fail HARD if secret key is missing or the insecure fallback in production
        log.critical(
            "CRITICAL STARTUP FAILURE: No valid SECRET_KEY found via SECRET_SEED or environment variable for production environment!"
        )
        raise RuntimeError(
            "Missing or insecure SECRET_KEY configuration for production."
        )
    if not Config.ENCRYPTION_ENABLED:
        # Fail HARD if encryption isn't enabled in production
        log.critical(
            "CRITICAL STARTUP FAILURE: Encryption is DISABLED (FERNET_KEY missing via FERNET_SEED or environment variable) in production environment!"
        )
        raise RuntimeError("Missing FERNET_KEY configuration for production.")
    # --- End Stricter Checks ---

    # Ensure CSRF is enabled
    WTF_CSRF_ENABLED = True


class TestingConfig(Config):
    TESTING = True
    # Use fixed test keys or seeds for testing predictability if needed
    SECRET_KEY = (
        generate_secret_key_bytes_from_seed("test-secret-seed")
        or b"fallback-test-key-thirty-two-b"
    )  # Use derived or fixed bytes
    FERNET_KEY = generate_fernet_key_from_seed(
        "test-fernet-seed"
    )  # Deterministic test key
    VAPID_ENABLED = False  # Usually disable push in tests
    ENCRYPTION_ENABLED = bool(FERNET_KEY)
    FETCH_INTERVAL_MINUTES = 9999
    DATA_DIRECTORY = Config.BASE_DIR / "test_data"
    USERS_FILE = DATA_DIRECTORY / "test_users.json"
    WTF_CSRF_ENABLED = False


# --- get_config and lock initialization (Keep as before) ---
def get_config():
    config_name = os.getenv("FLASK_ENV", "production").lower()
    log.info(f"Loading config for FLASK_ENV='{config_name}'")
    if config_name == "development":
        return DevelopmentConfig()
    elif config_name == "production":
        return ProductionConfig()
    elif config_name == "testing":
        return TestingConfig()
    else:
        log.warning(f"Unknown FLASK_ENV='{config_name}'. Defaulting to Production.")
        return ProductionConfig()


config = get_config()

# Initialize locks based on the loaded config context (only once)
# Ensure threading is imported if not already
if (
    config.FILE_LOCKS.get("shares") is None
):  # Check specifically for 'shares' if others might exist
    log.info("Initializing file locks (including shares)...")
    import threading

    for key in config.FILE_LOCKS:
        if config.FILE_LOCKS[key] is None:
            config.FILE_LOCKS[key] = threading.Lock()
            log.debug(f"Initialized lock for '{key}'")
    log.info("File locks initialization complete.")

// --------------------
// app\models.py
# app/models.py
from werkzeug.security import check_password_hash
from flask_login import UserMixin
from flask import current_app
import logging

# Import the user data service (we'll create this next)
# Use a structure that avoids circular imports, e.g., import within methods or pass service instance
# For now, we'll keep the static 'get' method similar to before, but it will use the service internally.

log = logging.getLogger(__name__)

class User(UserMixin):
    """User model for Flask-Login."""
    def __init__(self, id, email=None, password_hash=None):
        self.id = id
        self.email = email
        self.password_hash = password_hash
        log.debug(f"User object created: id={self.id}, email={self.email is not None}")

    @staticmethod
    def get(user_id):
        """Load user by ID using the user data service."""
        # This dynamic import is one way to handle dependencies during initialization
        # A better way is dependency injection but more complex setup
        try:
            from .services.user_data_service import UserDataService
            uds = UserDataService(current_app.config)
            user_data = uds.load_single_user(user_id)
            if user_data:
                log.debug(f"User.get: Found user data for {user_id}")
                return User(
                    id=user_id,
                    email=user_data.get("email"),
                    password_hash=user_data.get("password_hash"),
                )
            else:
                log.debug(f"User.get: No user data found for {user_id}")
                return None
        except ImportError:
            log.error("User.get: Could not import UserDataService. Is the service defined?")
            return None
        except Exception as e:
            log.error(f"User.get: Error loading user {user_id}: {e}")
            return None


    def check_password(self, password):
        """Check password hash."""
        if not self.password_hash or not password:
            log.debug(f"check_password for {self.id}: Hash or provided password empty.")
            return False
        is_valid = check_password_hash(self.password_hash, password)
        log.debug(f"check_password for {self.id}: Password validation result: {is_valid}")
        return is_valid

    # You might add methods here later to interact with user-specific data
    # e.g., get_devices_config(self), get_geofences(self)
    # These would internally call the UserDataService
// --------------------
// app\__init__.py
# app/__init__.py

import os
import logging
import threading
from flask import (
    Flask,
    url_for,
    g,
    request,
    redirect,
    flash,
    current_app,
    session,
    render_template,
)
from flask_login import LoginManager, current_user
from apscheduler.schedulers.background import BackgroundScheduler
from flask_wtf.csrf import CSRFProtect
from werkzeug.middleware.proxy_fix import ProxyFix

# Import the centrally loaded config object
from .config import config

# Import UserDataService (used in before_request)
from .services.user_data_service import UserDataService

# Initialize extensions without app context
login_manager = LoginManager()
login_manager.login_view = "auth.login_route"
login_manager.login_message_category = "info"
login_manager.login_message = "Please log in to access this page."

csrf = CSRFProtect()


# Scheduler instance
background_scheduler = BackgroundScheduler(daemon=True)

log = logging.getLogger(__name__)


def create_app():
    # Explicitly define base directory assuming __init__.py is in 'app/'
    APP_DIR = os.path.dirname(os.path.abspath(__file__))
    STATIC_DIR = os.path.join(APP_DIR, "static")
    TEMPLATE_DIR = os.path.join(APP_DIR, "templates")

    app = Flask(
        __name__,
        # Use absolute paths derived above
        template_folder=TEMPLATE_DIR,
        static_folder=STATIC_DIR,
        # Define the URL path for static files explicitly
        static_url_path="/static",
    )

    # Load Configuration
    app.config.from_object(config)
    log.info(f"Flask App Created with config: {type(config).__name__}")
    log.info(f"App Root Path: {app.root_path}")  # Log the detected root
    log.info(f"Static Folder: {app.static_folder}")  # Log the detected static folder
    log.info(f"Static URL Path: {app.static_url_path}")  # Log the URL path
    log.info(f"Data Directory: {app.config['DATA_DIRECTORY']}")
    log.info(
        f"CSRF Protection Enabled (Config): {app.config.get('WTF_CSRF_ENABLED', 'Not Set')}"
    )

    # Apply ProxyFix BEFORE other things
    app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_prefix=0)
    log.info("ProxyFix middleware applied (x_for=1, x_proto=1, x_host=1)")

    # --- Initialize Extensions with App Context ---
    login_manager.init_app(app)
    csrf.init_app(app)

    # --- Initialize File Locks (Centralized) ---
    # This ensures locks are created once when the app context is available.
    # It relies on the `config` object having been loaded and its FILE_LOCKS initialized.
    if "users" in config.FILE_LOCKS and config.FILE_LOCKS["users"] is None:
        log.info("Initializing file locks within create_app...")
        for key in config.FILE_LOCKS:
            # Check if the lock for this key specifically needs initialization
            if config.FILE_LOCKS[key] is None:
                config.FILE_LOCKS[key] = threading.Lock()
                log.debug(f"Initialized lock for '{key}'")
        log.info("File locks initialization complete.")
    elif "users" not in config.FILE_LOCKS:
        log.error(
            "FILE_LOCKS dictionary missing 'users' key in config. Locks not initialized."
        )
    # else: Locks were likely already initialized by a previous call or direct config loading.

    # --- Ensure Data Directory and Users File Exist ---
    try:
        app.config["DATA_DIRECTORY"].mkdir(parents=True, exist_ok=True)
        log.info(f"Ensured data directory exists: {app.config['DATA_DIRECTORY']}")
        users_file = app.config["USERS_FILE"]
        if not users_file.exists():
            users_lock = config.FILE_LOCKS.get("users")
            if users_lock:
                with users_lock:  # Lock before checking/creating
                    if not users_file.exists():  # Double-check inside lock
                        log.warning(
                            f"{users_file.name} not found. Creating empty user file at {users_file}"
                        )
                        try:
                            with open(users_file, "w", encoding="utf-8") as f:
                                f.write("{}")
                        except Exception as e:
                            log.error(f"Failed to create {users_file.name}: {e}")
            else:
                log.error("Cannot create users file: Lock for 'users' not found.")
    except Exception as e:
        log.error(
            f"Failed to create or access data directory {app.config['DATA_DIRECTORY']}: {e}"
        )

    # --- Register Blueprints ---
    from .auth.routes import bp as auth_bp

    app.register_blueprint(auth_bp)  # No prefix, handled in routes

    from .main.routes import bp as main_bp

    app.register_blueprint(main_bp)  # No prefix

    from .main.api import bp as api_bp

    app.register_blueprint(api_bp, url_prefix="/api")  # API endpoints under /api/

    # --- Register NEW Public Blueprint ---
    from .public.routes import bp as public_bp

    app.register_blueprint(public_bp, url_prefix="/public")  # Add

    # --- Initialize Scheduler (Carefully) ---
    # This adds jobs but doesn't start the scheduler here.
    # run.py or the WSGI server (like Waitress/Gunicorn) should start it.
    if not app.config.get("TESTING", False):
        # Use a flag to prevent adding jobs multiple times if create_app is called more than once
        # in the same process (e.g., some development server reloads)
        scheduler_init_flag = f"SCHEDULER_INITIALIZED_{os.getpid()}_{id(app)}"
        if (
            not background_scheduler.running  # Check if already running
            and not hasattr(
                app, "_scheduler_jobs_added"
            )  # Check custom flag on app instance
            # os.environ.get(scheduler_init_flag) != "1" # Alternative: check env var
        ):
            log.info(
                "Scheduler not running and not marked initialized, initializing jobs..."
            )
            try:
                from .scheduler.tasks import schedule_jobs

                schedule_jobs(app, background_scheduler)
                app._scheduler_jobs_added = True  # Set custom flag
                # os.environ[scheduler_init_flag] = "1" # Alternative: set env var
                log.info(
                    "Scheduler jobs added. Start will be called by run.py or WSGI server."
                )
            except ImportError:
                log.error("Could not import schedule_jobs. Scheduler tasks not loaded.")
            except Exception as e:
                log.error(f"Error scheduling jobs: {e}")
        elif background_scheduler.running:
            log.info("Scheduler already running. Skipping job scheduling.")
        else:
            log.info(
                "Scheduler marked as initialized previously (or another thread initialized it)."
            )
    else:
        log.info("Testing environment detected. Scheduler jobs will not be scheduled.")

    # --- Request Hook for Authentication/Credential Checks ---
    @app.before_request
    def check_auth_and_creds():
        log.debug(
            f"------ Start before_request ({request.method} {request.path}) ------"
        )
        log.debug(
            f"Endpoint: {request.endpoint}, Is Secure: {request.is_secure}, Scheme: {request.scheme}, Host: {request.host}"
        )
        # Avoid logging sensitive headers in production if possible
        if app.config.get("DEBUG"):
            log.debug(f"Headers: {dict(request.headers)}")
        log.debug(f"---------------------------------")

        # Endpoints accessible without login
        allowed_endpoints_public = {
            'static',               # Keep: Serves CSS, JS, images etc. from /static/
            'auth.login_route',     # Keep
            'auth.register_route',  # Keep
            'auth.logout_route',    # Keep
            # 'auth.logged_out_route', # Removed this route previously
            'api.get_vapid_public_key', # Keep (usually okay if key itself isn't secret)

            # --- ADD NEW PUBLIC ENDPOINTS ---
            'public.view_shared_device',  # Public share page
            'public.service_worker',      # Public Service Worker JS
            'public.manifest',            # Public Manifest JSON
            'public.favicon',             # Public Favicon
            'public.get_public_share_data_new',
            # --- KEEP API IF NEEDED ---
            # 'api.get_public_share_data'
            # Add any other public endpoints like password reset later
        }
        endpoint = request.endpoint

        if endpoint in allowed_endpoints_public:
            # If user is logged in, redirect away from login/register
            if current_user.is_authenticated and endpoint in [
                "auth.login_route",
                "auth.register_route",
            ]:
                log.debug(
                    f"Authenticated user accessing public login/register endpoint '{endpoint}'. Redirecting to index."
                )
                flash("You are already logged in.", "info")
                return redirect(url_for("main.index_route"))
            log.debug(f"Allowing public access to endpoint '{endpoint}'.")
            return  # Allow access

        # Check if user is logged in for protected endpoints
        if not current_user.is_authenticated:
            next_url = request.full_path  # Get full path with query string
            log.info(
                f"Unauthenticated access to protected endpoint '{endpoint}'. Redirecting to login (next={next_url})."
            )
            flash("Please log in to access this page.", "info")
            return redirect(
                url_for("auth.login_route", next=next_url)
            )  # Pass the path+query

        # User is authenticated, now check for Apple Credentials if endpoint requires them
        # Endpoints accessible with login but *without* Apple Credentials
        creds_optional_endpoints = {
            "main.manage_apple_creds_route",  # Page to set credentials
            "auth.logout_route",  # Logout should always work if logged in
            "api.config_import_apply",  # Config import
            "api.get_config_part",  # Config export parts
            "api.upload_device_file",  # File upload
            "api.user_preferences",  # GET/PUT user UI preferences
            "api.delete_account",  # Account deletion endpoint
            # Add other endpoints like user profile management later
        }
        if endpoint in creds_optional_endpoints:
            log.debug(
                f"Allowing authenticated access to creds-optional endpoint '{endpoint}'."
            )
            return  # Allow access

        # All other authenticated endpoints require Apple credentials
        try:
            uds = UserDataService(current_app.config)  # Get UDS instance
            if not uds.user_has_apple_credentials(current_user.id):
                log.warning(
                    f"User '{current_user.id}' accessing '{endpoint}' requires Apple credentials. Redirecting."
                )
                flash(
                    "Apple credentials are required to use this feature. Please set them below.",
                    "warning",
                )
                return redirect(url_for("main.manage_apple_creds_route"))

            log.debug(
                f"Allowing authenticated access with credentials to endpoint '{endpoint}'."
            )
        except Exception as e:
            log.error(
                f"Error checking Apple credentials for user '{current_user.id}': {e}",
                exc_info=True,
            )
            flash(
                "Could not verify Apple credentials status due to an internal error.",
                "danger",
            )
            # Decide where to redirect on error - maybe index or logout?
            # Redirecting to index might be less disruptive.
            return redirect(url_for("main.index_route"))

    # --- Global Error Handlers ---
    @app.errorhandler(404)
    def not_found_error(error):
        log.warning(f"404 Not Found: {request.url} - {error}")
        # Try rendering template, fallback to simple HTML
        try:
            return render_template("404.html"), 404
        except Exception:
            return (
                "<h1>404 Not Found</h1><p>The requested URL was not found on the server.</p>",
                404,
            )

    @app.errorhandler(500)
    def internal_error(error):
        log.error(f"500 Internal Server Error: {request.url} - {error}", exc_info=True)
        try:
            # Potentially rollback DB session if using one
            # db.session.rollback()
            return render_template("500.html"), 500
        except Exception:
            # Avoid recursive errors if 500.html itself fails
            return (
                "<h1>500 Internal Server Error</h1><p>An unexpected error occurred.</p>",
                500,
            )

    # CSRF Error Handler
    @app.errorhandler(400)  # Catches general 400, including CSRF errors from Flask-WTF
    def handle_bad_request_error(e):
        from flask_wtf.csrf import (
            CSRFError,
        )  # Import locally to avoid circular dependency issues

        # Check if it's specifically a CSRF error
        if isinstance(e, CSRFError) or (
            hasattr(e, "description") and "CSRF" in e.description
        ):
            log.warning(
                f"CSRF Validation Failed for {request.method} {request.url}. Reason: {getattr(e, 'description', 'No description')}"
            )
            flash(
                "Your request could not be completed due to a security check failure (CSRF). Please try submitting the form or reloading the page.",
                "error",
            )
            # Redirect back to the referring page, or index if referrer is unsafe/missing
            referrer = request.referrer or url_for("main.index_route")
            # Avoid redirect loops if referrer is the same page
            if referrer == request.url:
                referrer = url_for("main.index_route")
            return redirect(referrer)

        # Handle other 400 Bad Request errors
        log.warning(f"400 Bad Request: {request.url} - {e}")
        description = getattr(e, "description", "Invalid request")
        try:
            return render_template("400.html", error=description), 400
        except Exception:
            return f"<h1>400 Bad Request</h1><p>{description}</p>", 400

    log.info(f"VAPID Notifications Enabled: {app.config['VAPID_ENABLED']}")
    log.info(f"Password Encryption Enabled: {app.config['ENCRYPTION_ENABLED']}")

    # --- CONTEXT PROCESSOR ---
    # Make sure url_for('static', ...) works correctly with explicit static_url_path
    @app.context_processor
    def inject_global_vars():
        def get_static_url(config_path):
            if not config_path:
                return None
            try:
                # filename should be relative to the static_folder ('app/static')
                # e.g., 'css/style.css', 'libs/leaflet/leaflet.css'
                return url_for("static", filename=config_path, _external=False)
            except RuntimeError:
                log.warning(
                    f"No app context for url_for({config_path}), returning relative path."
                )
                # Ensure leading slash for relative path fallback
                return f"/static/{config_path}"
            except Exception as e:
                log.error(f"Error generating URL for '{config_path}': {e}")
                return None

        # Use the helper to get URLs defined in config
        default_icon_url = get_static_url(
            app.config.get("DEFAULT_NOTIFICATION_ICON_PATH")
        )
        welcome_icon_url = get_static_url(
            app.config.get("WELCOME_NOTIFICATION_ICON_PATH")
        )
        geofence_badge_url = get_static_url(
            app.config.get("GEOFENCE_NOTIFICATION_ICON_PATH")
        )
        battery_badge_url = get_static_url(
            app.config.get("BATTERY_NOTIFICATION_ICON_PATH")
        )
        test_icon_badge_url = get_static_url(
            app.config.get("TEST_NOTIFICATION_ICON_PATH")
        )
        default_badge_url = get_static_url(
            app.config.get("DEFAULT_NOTIFICATION_BADGE_PATH")
        )

        return dict(
            # Pass VAPID key only if enabled
            VAPID_PUBLIC_KEY=(
                app.config["VAPID_PUBLIC_KEY"] if app.config["VAPID_ENABLED"] else None
            ),
            LOW_BATTERY_THRESHOLD=app.config["LOW_BATTERY_THRESHOLD"],
            APP_VERSION=app.config["APP_VERSION"],
            # Pass username if logged in
            username=(current_user.id if current_user.is_authenticated else None),
            # Pass Specific Icon/Badge URLs needed by frontend JS/Templates
            DEFAULT_NOTIFICATION_ICON_URL=default_icon_url,
            WELCOME_NOTIFICATION_ICON_URL=welcome_icon_url,  # For welcome/test
            GEOFENCE_BADGE_URL=geofence_badge_url,
            BATTERY_BADGE_URL=battery_badge_url,
            TEST_ICON_BADGE_URL=test_icon_badge_url,  # For test notification
            DEFAULT_BADGE_URL=default_badge_url,
        )
    
    return app

// --------------------
// app\auth\forms.py
# app/auth/forms.py
# NEW FILE
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField, EmailField
from wtforms.validators import DataRequired, Length, Email, EqualTo, ValidationError
import logging

from app.models import User  # To check if username/email exists

log = logging.getLogger(__name__)


class LoginForm(FlaskForm):
    username = StringField(
        "Username", validators=[DataRequired(), Length(min=3, max=64)]
    )
    password = PasswordField("Password", validators=[DataRequired()])
    remember = BooleanField("Remember Me")
    submit = SubmitField("Login")


class RegistrationForm(FlaskForm):
    username = StringField(
        "Username", validators=[DataRequired(), Length(min=3, max=64)]
    )
    email = EmailField("Email", validators=[DataRequired(), Email(), Length(max=120)])
    password = PasswordField(
        "Password",
        validators=[
            DataRequired(),
            Length(min=8, message="Password must be at least 8 characters long."),
        ],
    )
    confirm_password = PasswordField(
        "Confirm Password",
        validators=[
            DataRequired(),
            EqualTo("password", message="Passwords must match."),
        ],
    )
    submit = SubmitField("Register")

    # Custom validators to check if username/email already exists
    def validate_username(self, username):
        user = User.get(username.data)
        if user is not None:
            log.warning(
                f"Registration validation failed: Username '{username.data}' already exists."
            )
            raise ValidationError(
                "Username already taken. Please choose a different one."
            )

    def validate_email(self, email):
        # Need access to UserDataService here, which is tricky without app context.
        # For simplicity in this form, we'll skip the email uniqueness check here
        # and rely on the check within the route function (which has app context).
        # A more advanced setup might pass the UDS instance or use application factories.
        log.debug(
            f"Skipping email uniqueness check within RegistrationForm for {email.data}"
        )
        pass


class AppleCredentialsForm(FlaskForm):
    apple_id = EmailField(
        "Apple ID (Email)", validators=[DataRequired(), Email(), Length(max=120)]
    )
    apple_password = PasswordField(
        "Apple Password / App-Specific Password",
        validators=[DataRequired(message="Password is required to save changes.")],
    )
    submit = SubmitField("Save Credentials")

// --------------------
// app\auth\routes.py
# app/auth/routes.py

import logging
from flask import (
    render_template,
    request,
    flash,
    redirect,
    url_for,
    session,
    current_app,
    abort,
)
from flask_login import login_user, logout_user, login_required, current_user
from werkzeug.security import generate_password_hash
from urllib.parse import urlparse, urljoin

# Blueprint, User model, LoginManager instance
from . import bp
from app.models import User
from app import login_manager  # No csrf import needed here anymore

# UserDataService for data operations
from app.services.user_data_service import UserDataService

# Import forms
from .forms import LoginForm, RegistrationForm

log = logging.getLogger(__name__)


# --- Helper for safe redirects ---
def is_safe_url(target):
    """Checks if a redirect target URL is safe."""
    if not isinstance(target, str):
        return False
    ref_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    is_safe = test_url.scheme in ("http", "https") and ref_url.netloc == test_url.netloc
    if not is_safe:
        log.warning(f"Unsafe redirect target detected and blocked: {target}")
    return is_safe


# --- User Loader ---
@login_manager.user_loader
def load_user(user_id):
    """Flask-Login user loader callback."""
    log.debug(f"Flask-Login attempting to load user: {user_id}")
    try:
        user = User.get(user_id)
        if user:
            log.debug(f"User {user_id} loaded successfully by Flask-Login.")
        else:
            log.warning(f"User {user_id} not found during Flask-Login load.")
        return user
    except Exception as e:
        log.error(f"Exception during user load for {user_id}: {e}", exc_info=True)
        return None


# --- Registration Route (Using WTForms) ---
@bp.route("/register", methods=["GET", "POST"])
def register_route():
    if current_user.is_authenticated:
        return redirect(url_for("main.index_route"))
    form = RegistrationForm()
    if form.validate_on_submit():  # CSRF check happens here if enabled globally
        username = form.username.data.strip()
        email = form.email.data.strip().lower()
        password = form.password.data
        uds = UserDataService(current_app.config)
        try:
            existing_users = uds.load_users()
            if any(
                u_data.get("email", "").lower() == email
                for u_data in existing_users.values()
                if u_data.get("email")
            ):
                flash(f"Email address '{email}' is already registered.", "error")
                return render_template("register.html", title="Register", form=form)
        except Exception as e:
            log.error(f"Failed to load users for email uniqueness check: {e}")
            flash("Error checking existing users. Please try again.", "error")
            return render_template("register.html", title="Register", form=form)
        try:
            hashed_password = generate_password_hash(password)
            user_dir = uds._get_user_data_dir(username)
            if not user_dir:
                raise IOError(f"Could not create data directory for user '{username}'.")
            new_user_data = {"email": email, "password_hash": hashed_password}
            existing_users[username] = new_user_data
            uds.save_users(existing_users)
            log.info(f"New user registered: '{username}' ({email})")
            flash(
                f"User '{username}' registered successfully! Please log in.", "success"
            )
            return redirect(url_for(".login_route"))
        except (IOError, TypeError, RuntimeError) as e:
            log.exception(f"Error saving new user '{username}': {e}")
            flash(
                f"An error occurred during registration: {e}. Please try again later.",
                "error",
            )
        except Exception as e:
            log.exception(f"Unexpected error saving new user '{username}': {e}")
            flash(
                "An unexpected error occurred during registration. Please try again later.",
                "error",
            )
    return render_template("register.html", title="Register", form=form)


# --- Login Route (Using WTForms) ---
@bp.route("/login", methods=["GET", "POST"])
# @csrf.exempt # Removed
def login_route():
    uds = UserDataService(current_app.config)
    try:
        existing_users = uds.load_users()
        if not existing_users:
            log.warning("No users found in users.json. Redirecting to registration.")
            flash("No users exist yet. Please register the first user.", "info")
            return redirect(url_for(".register_route"))
    except Exception as e:
        log.error(f"Failed to check user existence before login: {e}")
        flash("Warning: Could not verify user database status.", "warning")

    form = LoginForm()
    if form.validate_on_submit():  # CSRF check happens here if enabled globally
        username = form.username.data
        password = form.password.data
        remember = form.remember.data
        log.info(f"Login attempt for user: '{username}'")
        user_obj = User.get(username)
        if user_obj and user_obj.check_password(password):
            login_user(user_obj, remember=remember)
            log.info(f"User '{username}' logged in successfully.")
            session.permanent = remember
            next_page = request.args.get("next")
            if not is_safe_url(next_page):
                log.warning(
                    f"Unsafe 'next' URL detected during login: {next_page}. Ignoring."
                )
                next_page = None
            has_creds = False
            try:
                has_creds = uds.user_has_apple_credentials(username)
                log.info(
                    f"User '{username}' Apple credentials status after login: {'Found' if has_creds else 'Not Found'}"
                )
            except Exception as e:
                log.error(
                    f"Failed to check Apple credentials status for user '{username}' after login: {e}",
                    exc_info=True,
                )
                flash(
                    "Login successful, but could not verify Apple credentials status.",
                    "warning",
                )
            if next_page:
                log.debug(
                    f"Redirecting logged in user '{username}' to safe next page: {next_page}"
                )
                return redirect(next_page)
            elif not has_creds:
                log.info(
                    f"User '{username}' has no Apple credentials, redirecting to manage_creds."
                )
                flash("Login successful. Please set your Apple credentials.", "info")
                return redirect(url_for("main.manage_apple_creds_route"))
            else:
                log.debug(f"User '{username}' has credentials, redirecting to index.")
                return redirect(url_for("main.index_route"))
        else:
            log.warning(f"Login failed for user '{username}'. Invalid credentials.")
            flash("Invalid username or password.", "error")
    # Render login form for GET request or if validation fails/POST invalid
    return render_template("login.html", title="Login", form=form)


# --- Logout Route (Redirect to intermediate page) ---
@bp.route("/logout")
@login_required
def logout_route():
    user_id = current_user.id
    log.info(f"Logout requested for user '{user_id}'.")
    flash_message = "You have been logged out."  # Keep original message base

    # Clear Apple Credentials first (best effort)
    try:
        uds = UserDataService(current_app.config)
        uds.clear_apple_credentials(user_id)
        log.info(f"Cleared stored Apple credentials for user '{user_id}'.")
        # No need to add to flash message, user is going straight to login
    except Exception as e:
        log.error(
            f"Failed to clear Apple credentials for user '{user_id}' during logout: {e}",
            exc_info=True,
        )
        # Add a different flash message if needed, but maybe keep it simple
        flash("Logged out, but failed to clear stored Apple credentials.", "warning")

    # Perform actual logout (clears session, expires remember cookie)
    try:
        logout_user()
        # session.clear() # logout_user() handles the necessary session keys
        log.info(f"User '{user_id}' logged out via Flask-Login.")
    except Exception as e:
        log.error(
            f"Error during Flask-Login logout for user '{user_id}': {e}", exc_info=True
        )
        flash("An error occurred during logout.", "error")  # Add error flash

    # Flash the logout message before redirecting to login
    flash(flash_message, "success")  # Use success category

    log.info(f"Redirecting user '{user_id}' directly to login page.")
    # --- MODIFIED REDIRECT ---
    return redirect(url_for("auth.login_route"))
    # --- ------------------- ---


# --- Intermediate Logged Out Route ---
@bp.route("/logged-out")
def logged_out_route():
    """Displays a confirmation page after logout before redirecting to login."""
    return render_template("logout_success.html", title="Logged Out")

// --------------------
// app\auth\__init__.py
# app/auth/__init__.py
from flask import Blueprint

# Prefix '/auth' can be added here or during registration in app/__init__.py
# If added here, remove url_prefix from app.register_blueprint
bp = Blueprint('auth', __name__, template_folder='../templates')

# Import routes after blueprint creation to avoid circular imports
from . import routes # noqa
// --------------------
// app\main\api.py
# app/main/api.py
import logging
import time
import re
import os
import threading
import traceback
import shutil
import uuid  # Added for share IDs
from pathlib import Path
from werkzeug.utils import secure_filename
import json
from datetime import datetime, timezone, timedelta  # Ensure timedelta is imported
from app.utils.json_utils import save_json_atomic, load_json_file  # Import JSON helpers

from flask import (
    Blueprint,
    jsonify,
    request,
    current_app,
    abort,
    Response,
    send_file,
    session,  # Import session for logout
    url_for,  # Added for generating share URLs
)
from flask_login import login_required, current_user, logout_user  # Import logout_user

# Import Services
from app.services.user_data_service import UserDataService
from app.services.notification_service import NotificationService

# Import scheduler task (if needed directly, otherwise remove)
# from app.scheduler.tasks import run_fetch_for_user_task

# Import necessary utils
from app.utils.helpers import (
    generate_geofence_id,
    getDefaultColorForId,
    generate_device_icon_svg,
)

from app.utils.data_formatting import (
    format_latest_report_for_api,
    _parse_battery_info,
)

log = logging.getLogger(__name__)

bp = Blueprint("api", __name__)

# --- File Upload API ---
ALLOWED_EXTENSIONS = {"plist", "keys"}
ALLOWED_CONFIG_EXTENSIONS = {"json"}


def allowed_file(filename, allowed_set=ALLOWED_EXTENSIONS):
    # Corrected logic
    return "." in filename and filename.rsplit(".", 1)[1].lower() in allowed_set


@bp.route("/files/upload", methods=["POST"])
@login_required
def upload_device_file():
    user_id = current_user.id
    log.info(f"API POST /files/upload called by user '{user_id}'")
    uploaded_files = request.files.getlist("device_file")
    if not uploaded_files or all(f.filename == "" for f in uploaded_files):
        log.warning(f"User '{user_id}' upload attempt: No files selected.")
        return jsonify({"error": "No files selected."}), 400
    uds = UserDataService(current_app.config)
    user_data_dir = uds._get_user_data_dir(user_id)
    if not user_data_dir:
        log.error(f"User '{user_id}' upload error: Could not get user data directory.")
        return (
            jsonify({"error": "Server error: Could not access user data storage."}),
            500,
        )

    results = {"success": [], "errors": []}
    config_needs_reload = False
    trigger_fetch = False
    for file_storage in uploaded_files:
        original_filename = file_storage.filename
        if not original_filename:
            log.debug(f"User '{user_id}' upload: Skipping empty file part.")
            continue

        if not allowed_file(original_filename, ALLOWED_EXTENSIONS):
            msg = f"File type not allowed: '{original_filename}'. Only .plist and .keys are permitted."
            log.warning(f"User '{user_id}' upload attempt: {msg}")
            results["errors"].append({"filename": original_filename, "error": msg})
            continue

        filename = secure_filename(original_filename)
        if not filename:
            msg = f"Invalid filename provided: '{original_filename}'."
            log.warning(f"User '{user_id}' upload attempt: {msg}")
            results["errors"].append({"filename": original_filename, "error": msg})
            continue
        save_path = user_data_dir / filename
        log.info(
            f"User '{user_id}': Saving uploaded '{original_filename}' as '{filename}'"
        )
        try:
            file_storage.save(save_path)
            log.info(f"User '{user_id}': Successfully saved '{filename}'.")
            results["success"].append(
                {
                    "filename": filename,
                    "original_filename": original_filename,
                    "device_id": Path(filename).stem,
                }
            )
            config_needs_reload = True
            trigger_fetch = True
        except Exception as e:
            log.exception(f"User '{user_id}': Failed to save '{original_filename}'.")
            results["errors"].append(
                {"filename": original_filename, "error": f"Failed to save file: {e}"}
            )

    if config_needs_reload:
        try:
            uds.load_devices_config(user_id)  # Reload config merges new files
            log.info(f"User '{user_id}': Devices config reloaded after uploads.")
            if trigger_fetch and not results["errors"]:
                log.info(
                    f"Triggering immediate fetch for user '{user_id}' after file upload."
                )
                try:
                    # *** Fetch should be triggered by scheduler, but allow manual for immediate feedback ***
                    # This requires run_fetch_for_user_task to be importable or use a different trigger mechanism
                    from app.scheduler.tasks import run_fetch_for_user_task

                    apple_id, apple_password = uds.load_apple_credentials(user_id)
                    if apple_id and apple_password:
                        immediate_fetch_thread = threading.Thread(
                            target=run_fetch_for_user_task,
                            args=(
                                user_id,
                                apple_id,
                                apple_password,
                                current_app.config,
                            ),
                            name=f"ImmediateFetchUpload-{user_id}",
                            daemon=True,
                        )
                        immediate_fetch_thread.start()
                        results["fetch_triggered"] = True
                    else:
                        log.warning(
                            f"User '{user_id}': Cannot trigger fetch after upload, creds missing."
                        )
                        results["fetch_triggered"] = False
                        results["fetch_error"] = "Credentials missing"
                except ImportError:
                    log.error(
                        "Cannot import run_fetch_for_user_task for immediate trigger."
                    )
                    results["fetch_triggered"] = False
                    results["fetch_error"] = "Server cannot trigger immediate fetch."
                except Exception as fetch_trigger_err:
                    log.error(
                        f"Failed to start immediate fetch for '{user_id}': {fetch_trigger_err}"
                    )
                    log.error(traceback.format_exc())
                    results["fetch_triggered"] = False
                    results["fetch_error"] = str(fetch_trigger_err)
        except Exception as post_upload_err:
            log.error(
                f"Error post-upload config reload for {user_id}: {post_upload_err}"
            )
            results["errors"].append(
                {
                    "filename": "N/A",
                    "error": f"Server error during config reload: {post_upload_err}. Devices might not appear.",
                }
            )

    status_code = 200
    response_message = ""
    if not results["success"] and not results["errors"]:
        response_message = "No valid files processed."
        status_code = 400
    elif not results["errors"]:
        response_message = f"Successfully uploaded {len(results['success'])} file(s)."
        status_code = 201
    elif not results["success"]:
        response_message = f"Failed to upload {len(results['errors'])} file(s)."
        status_code = 400
    else:
        response_message = f"Upload complete: {len(results['success'])} succeeded, {len(results['errors'])} failed."
        status_code = 200
    if results.get("fetch_triggered") is True:
        response_message += " Background fetch initiated."
    elif results.get("fetch_triggered") is False:
        response_message += f" Background fetch NOT initiated ({results.get('fetch_error', 'unknown reason')})."

    return jsonify({"message": response_message, "details": results}), status_code


# --- Device API ---
@bp.route("/devices", methods=["GET"])
@login_required
def get_devices():
    user_id = current_user.id
    log.debug(f"API GET /devices called by user '{user_id}'")
    uds = UserDataService(current_app.config)
    response_data = {
        "devices": [],
        "last_updated": None,
        "fetch_errors": None,
        "code": "UNKNOWN",
    }
    status_code = 200

    try:
        current_user_devices_config = uds.load_devices_config(user_id)
        config_device_ids = set(current_user_devices_config.keys())
        all_user_geofences = uds.load_geofences_config(user_id)
        user_cache = uds.load_cache_from_file(user_id)

        # *** Check Shared Status ***
        active_shared_device_ids = set()
        all_shares = uds.load_shares()
        now_utc = datetime.now(timezone.utc)
        for share_id, share_data in all_shares.items():
            if share_data.get("user_id") == user_id and share_data.get("active", False):
                expires_at_str = share_data.get("expires_at")
                is_expired = False
                if expires_at_str:
                    try:
                        expires_at_dt = datetime.fromisoformat(
                            expires_at_str.replace("Z", "+00:00")
                        )
                        if expires_at_dt.tzinfo is None:
                            expires_at_dt = expires_at_dt.replace(tzinfo=timezone.utc)
                        if expires_at_dt < now_utc:
                            is_expired = True
                    except ValueError:
                        is_expired = True
                if not is_expired:
                    active_shared_device_ids.add(share_data.get("device_id"))
        # *** End Check Shared Status ***

        if (
            not user_cache
            or "data" not in user_cache
            or not isinstance(user_cache.get("data"), dict)
        ):
            # Handle Cache Empty/Invalid (Keep existing logic)
            error_detail = (
                user_cache.get("error", "Cache is empty or invalid.")
                if user_cache
                else "Cache file not found or empty."
            )
            log.warning(
                f"User '{user_id}' /api/devices: Cache empty/invalid. Error: {error_detail}"
            )
            response_data["error"] = (
                "Device data not available yet. Waiting for next background fetch."
            )
            response_data["code"] = "CACHE_EMPTY"
            response_data["last_updated"] = (
                user_cache.get("timestamp") if user_cache else None
            )
            response_data["fetch_errors"] = error_detail

            log.info(
                f"User '{user_id}' /api/devices: Cache empty, returning devices based *only* on config."
            )
            for device_id, config_from_file in current_user_devices_config.items():
                formatted_device = format_latest_report_for_api(
                    user_id,
                    device_id,
                    None,
                    config_from_file,
                    all_user_geofences,
                    current_app.config["LOW_BATTERY_THRESHOLD"],
                )
                formatted_device["is_shared"] = (
                    device_id in active_shared_device_ids
                )  # Add flag
                formatted_device["reports"] = []
                response_data["devices"].append(formatted_device)
            response_data["devices"].sort(
                key=lambda d: d.get("name", d.get("id", "")).lower()
            )
            status_code = 200
            response_data["code"] = "CACHE_EMPTY_CONFIG_RETURNED"
            return jsonify(response_data), status_code
        # --- END Cache Empty Handling ---

        # --- Process Valid Cache Data ---
        devices_list = []
        device_data_dict_from_cache = user_cache.get("data", {})
        processed_ids_from_cache = set()

        for device_id, device_info_from_cache in device_data_dict_from_cache.items():
            if device_id not in config_device_ids:
                log.warning(
                    f"User '{user_id}': Device '{device_id}' found in cache but NOT in config. IGNORING."
                )
                continue
            processed_ids_from_cache.add(device_id)
            fresh_config = current_user_devices_config.get(device_id)
            all_reports_for_device = device_info_from_cache.get("reports", [])
            latest_report = (
                all_reports_for_device[0] if all_reports_for_device else None
            )

            formatted_device = format_latest_report_for_api(
                user_id,
                device_id,
                latest_report,
                fresh_config,
                all_user_geofences,
                current_app.config["LOW_BATTERY_THRESHOLD"],
            )
            formatted_device["is_shared"] = (
                device_id in active_shared_device_ids
            )  # Add flag
            formatted_device["reports"] = all_reports_for_device
            devices_list.append(formatted_device)

        # Add devices from Config that weren't in Cache
        for device_id, config_from_file in current_user_devices_config.items():
            if device_id not in processed_ids_from_cache:
                log.warning(
                    f"User '{user_id}': Device '{device_id}' in config but not cache. Displaying with no location."
                )
                formatted_device = format_latest_report_for_api(
                    user_id,
                    device_id,
                    None,
                    config_from_file,
                    all_user_geofences,
                    current_app.config["LOW_BATTERY_THRESHOLD"],
                )
                formatted_device["is_shared"] = (
                    device_id in active_shared_device_ids
                )  # Add flag
                formatted_device["reports"] = []
                devices_list.append(formatted_device)

        # Final Sorting and Response
        devices_list.sort(key=lambda d: d.get("name", d.get("id", "")).lower())
        response_data["devices"] = devices_list
        response_data["last_updated"] = user_cache.get("timestamp")
        response_data["fetch_errors"] = user_cache.get("error")
        response_data["code"] = "OK"
        log.info(
            f"API GET /devices for '{user_id}': Returning {len(devices_list)} devices. Status: {response_data['code']}"
        )
        return jsonify(response_data), status_code

    except Exception as e:
        log.exception(f"Error in GET /api/devices for '{user_id}'")
        abort(500, description="Error fetching devices.")


@bp.route("/devices/<string:device_id>", methods=["PUT"])
@login_required
def update_device_display_config(device_id):
    # Keep existing logic for updating name, label, color
    user_id = current_user.id
    log.debug(f"API PUT /devices/{device_id} by '{user_id}'")
    data = request.get_json()
    uds = UserDataService(current_app.config)
    if not data or not device_id:
        log.warning(f"User '{user_id}' PUT /devices/{device_id}: Invalid request.")
        abort(400, description="Invalid request data.")
    try:
        config_data = uds.load_devices_config(user_id)
        all_user_geofences = uds.load_geofences_config(user_id)
        if device_id not in config_data:
            log.warning(f"User '{user_id}' PUT /devices/{device_id}: Device not found.")
            abort(404, description="Device not found.")
        device_config = config_data[device_id]
        updated_fields_count = 0
        allowed_fields = ["name", "label", "color"]
        if "name" in data:
            new_name = str(data["name"]).strip() if data["name"] else device_id
            if new_name != device_config.get("name"):
                device_config["name"] = new_name
                updated_fields_count += 1
        if "label" in data:
            new_label = str(data["label"]).strip()[:2] if data["label"] else "❓"
            if new_label != device_config.get("label", "❓"):
                device_config["label"] = new_label
                updated_fields_count += 1
        if "color" in data:
            new_color = data["color"]
            if new_color == "":
                new_color = None
            elif isinstance(new_color, str) and not re.match(
                r"^#[0-9a-fA-F]{6}$", new_color
            ):
                abort(400, description="Invalid color format.")
                # return # Ensure exit after abort
            if new_color != device_config.get("color"):
                device_config["color"] = new_color
                updated_fields_count += 1

        ignored_fields = [k for k in data if k not in allowed_fields]
        if ignored_fields:
            log.warning(
                f"User '{user_id}', Device '{device_id}': PUT ignored fields: {ignored_fields}."
            )

        if updated_fields_count > 0:
            uds.save_devices_config(user_id, config_data)
            log.info(f"User '{user_id}': Saved display config for '{device_id}'.")
            config_data = uds.load_devices_config(user_id)  # Reload to get SVG
            device_config = config_data.get(device_id, device_config)
        else:
            log.debug(
                f"User '{user_id}', Device '{device_id}': No display changes detected."
            )

        # Fetch latest report from cache to include in response
        latest_report_from_cache = None
        user_cache = uds.load_cache_from_file(user_id)
        if user_cache and user_cache.get("data"):
            cached_device_data = user_cache["data"].get(device_id)
            if cached_device_data and cached_device_data.get("reports"):
                latest_report_from_cache = cached_device_data["reports"][0]

        # Format response, including shared status
        is_shared = uds.is_device_shared(user_id, device_id)  # Check shared status
        formatted_device = format_latest_report_for_api(
            user_id,
            device_id,
            latest_report_from_cache,
            device_config,
            all_user_geofences,
            current_app.config["LOW_BATTERY_THRESHOLD"],
        )
        formatted_device["is_shared"] = is_shared  # Add flag
        # Include full history from cache in response
        if user_cache and user_cache.get("data") and user_cache["data"].get(device_id):
            formatted_device["reports"] = user_cache["data"][device_id].get(
                "reports", []
            )
        else:
            formatted_device["reports"] = []

        return jsonify(formatted_device), 200
    except ValueError as ve:
        abort(400, description=str(ve))
    except IOError as ioe:
        log.error(f"IOError processing PUT /devices/{device_id} for '{user_id}': {ioe}")
        abort(500, description="Server error saving config.")
    except Exception as e:
        log.exception(f"Error in PUT /api/devices/{device_id} for '{user_id}'")
        abort(500, description="Unexpected error.")


@bp.route("/devices/<string:device_id>/geofence_links", methods=["PUT"])
@login_required
def update_device_geofence_links(device_id):
    # Keep existing logic
    user_id = current_user.id
    log.debug(f"API PUT /devices/{device_id}/geofence_links by '{user_id}'")
    data = request.get_json()
    uds = UserDataService(current_app.config)
    if (
        not data
        or "linked_geofences" not in data
        or not isinstance(data["linked_geofences"], list)
        or not device_id
    ):
        abort(400, description="Invalid payload: 'linked_geofences' array required.")
    try:
        devices_config = uds.load_devices_config(user_id)
        all_user_geofences_map = uds.load_geofences_config(user_id)
        if device_id not in devices_config:
            abort(404, description="Device not found.")
        device_config = devices_config[device_id]
        all_user_geofences_ids = set(all_user_geofences_map.keys())
        validated_new_links = []
        linked_ids_in_payload = set()
        for link_data in data["linked_geofences"]:
            if not isinstance(link_data, dict) or "id" not in link_data:
                raise ValueError("Invalid link structure")
            gf_id = link_data.get("id")
            if (
                not isinstance(gf_id, str)
                or not gf_id
                or gf_id not in all_user_geofences_ids
            ):
                raise ValueError(f"Invalid or unknown geofence ID '{gf_id}'.")
            if gf_id in linked_ids_in_payload:
                log.warning(f"Duplicate geofence ID '{gf_id}' in payload")
                continue
            validated_link = {
                "id": gf_id,
                "notify_entry": bool(link_data.get("notify_entry", False)),
                "notify_exit": bool(link_data.get("notify_exit", False)),
            }
            validated_new_links.append(validated_link)
            linked_ids_in_payload.add(gf_id)
        device_config["linked_geofences"] = validated_new_links
        try:
            uds.save_devices_config(user_id, devices_config)
            log.info(
                f"User '{user_id}': Updated geofence links for '{device_id}'. Links: {validated_new_links}"
            )
        except Exception as e:
            log.exception(
                f"User '{user_id}', Device '{device_id}': Error saving device config after updating links."
            )
            abort(500, description="Failed to save device config.")
        resolved_response_links = []
        for link in validated_new_links:
            gf_definition = all_user_geofences_map.get(link["id"])
            if gf_definition:
                resolved_response_links.append(
                    {
                        **gf_definition,
                        "notify_on_entry": link["notify_entry"],
                        "notify_on_exit": link["notify_exit"],
                    }
                )
        return jsonify({"linked_geofences": resolved_response_links}), 200
    except ValueError as ve:
        abort(400, description=str(ve))
    except IOError as ioe:
        log.error(
            f"IOError processing PUT /devices/{device_id}/geofence_links for '{user_id}': {ioe}"
        )
        abort(500, description="Server error saving config.")
    except Exception as e:
        log.exception(
            f"Error in PUT /api/devices/{device_id}/geofence_links for '{user_id}'"
        )
        abort(500, description="Unexpected error.")


@bp.route("/devices/<string:device_id>", methods=["DELETE"])
@login_required
def delete_device(device_id):
    # Keep existing logic
    user_id = current_user.id
    log.warning(f"API DELETE /devices/{device_id} requested by user '{user_id}'")
    uds = UserDataService(current_app.config)
    try:
        success, message = uds.delete_device_and_data(user_id, device_id)
        status_code = 200 if success else 500
        if not success and (
            "Could not access data directory" in message
            or "Path or lock not found" in message
        ):
            status_code = 500
        response_data = {"message": message}
        if not success:
            response_data["error"] = "Deletion failed or completed with errors."
        log.info(
            f"API DELETE /devices/{device_id} result for '{user_id}': Status={status_code}, Msg={message}"
        )
        return jsonify(response_data), status_code
    except Exception as e:
        log.exception(
            f"Unexpected error during DELETE /api/devices/{device_id} for '{user_id}'"
        )
        return (
            jsonify(
                {
                    "error": "An unexpected server error occurred during deletion.",
                    "message": str(e),
                }
            ),
            500,
        )


# --- Geofence CRUD ---
# Keep existing GET /geofences, POST /geofences, PUT /geofences/<id>, DELETE /geofences/<id> logic
@bp.route("/geofences", methods=["GET"])
@login_required
def get_all_geofences():
    user_id = current_user.id
    log.debug(f"API GET /geofences by '{user_id}'")
    uds = UserDataService(current_app.config)
    try:
        all_user_geofences = uds.load_geofences_config(user_id)
        geofences_list = sorted(
            list(all_user_geofences.values()), key=lambda g: g.get("name", "").lower()
        )
        log.info(
            f"API GET /geofences for '{user_id}': Returning {len(geofences_list)} geofences."
        )
        return jsonify(geofences_list)
    except Exception as e:
        log.exception(f"Error loading geofences for '{user_id}'")
        abort(500, description="Failed to load geofences.")


@bp.route("/geofences", methods=["POST"])
@login_required
def create_geofence():
    user_id = current_user.id
    log.debug(f"API POST /geofences by '{user_id}'")
    data = request.get_json()
    uds = UserDataService(current_app.config)
    required_fields = ["name", "lat", "lng", "radius"]
    if not data or not all(k in data for k in required_fields):
        abort(
            400, description=f"Missing required fields: {', '.join(required_fields)}."
        )
    try:
        new_name = str(data["name"]).strip()
        new_lat = float(data["lat"])
        new_lng = float(data["lng"])
        new_radius = float(data["radius"])
        if (
            not new_name
            or new_radius <= 0
            or not (-90 <= new_lat <= 90)
            or not (-180 <= new_lng <= 180)
        ):
            raise ValueError("Invalid data: Check name, radius (>0), lat/lng.")
        all_user_geofences = uds.load_geofences_config(user_id)
        if any(
            gf["name"].lower() == new_name.lower() for gf in all_user_geofences.values()
        ):
            abort(409, description=f"Geofence name '{new_name}' already exists.")
        new_id = generate_geofence_id()
        new_gf_data_for_save = {
            "name": new_name,
            "lat": new_lat,
            "lng": new_lng,
            "radius": new_radius,
        }
        all_user_geofences[new_id] = {**new_gf_data_for_save, "id": new_id}
        uds.save_geofences_config(user_id, all_user_geofences)
        created_gf_with_id = {**new_gf_data_for_save, "id": new_id}
        log.info(f"User '{user_id}': Created new geofence: {created_gf_with_id}")
        return jsonify(created_gf_with_id), 201
    except ValueError as ve:
        abort(400, description=f"Invalid data: {ve}")
    except Exception as e:
        log.exception(f"User '{user_id}': Error creating geofence")
        abort(500, description="Internal server error.")


@bp.route("/geofences/<string:geofence_id>", methods=["PUT"])
@login_required
def update_geofence(geofence_id):
    user_id = current_user.id
    log.debug(f"API PUT /geofences/{geofence_id} by '{user_id}'")
    data = request.get_json()
    uds = UserDataService(current_app.config)
    if not data:
        abort(400, description="Request body empty.")
    try:
        all_user_geofences = uds.load_geofences_config(user_id)
        if geofence_id not in all_user_geofences:
            abort(404, description="Geofence not found.")
        original_gf = all_user_geofences[geofence_id]
        updated_gf_data = original_gf.copy()
        updated_fields_count = 0
        if "name" in data:
            new_name = str(data["name"]).strip()
            if not new_name:
                raise ValueError("Name cannot be empty.")
            if new_name.lower() != original_gf["name"].lower() and any(
                gf["name"].lower() == new_name.lower() and gf_id != geofence_id
                for gf_id, gf in all_user_geofences.items()
            ):
                abort(409, description=f"Geofence name '{new_name}' already exists.")
            if new_name != original_gf.get("name"):
                updated_gf_data["name"] = new_name
                updated_fields_count += 1
        if "lat" in data:
            new_lat = float(data["lat"])
        if not (-90 <= new_lat <= 90):
            raise ValueError("Invalid latitude.")
        if new_lat != original_gf.get("lat"):
            updated_gf_data["lat"] = new_lat
            updated_fields_count += 1
        if "lng" in data:
            new_lng = float(data["lng"])
        if not (-180 <= new_lng <= 180):
            raise ValueError("Invalid longitude.")
        if new_lng != original_gf.get("lng"):
            updated_gf_data["lng"] = new_lng
            updated_fields_count += 1
        if "radius" in data:
            new_radius = float(data["radius"])
        if new_radius <= 0:
            raise ValueError("Radius must be positive.")
        if new_radius != original_gf.get("radius"):
            updated_gf_data["radius"] = new_radius
            updated_fields_count += 1
        if updated_fields_count > 0:
            all_user_geofences[geofence_id] = updated_gf_data
            uds.save_geofences_config(user_id, all_user_geofences)
            log.info(f"User '{user_id}': Updated geofence {geofence_id}")
        else:
            log.debug(
                f"User '{user_id}', Geofence '{geofence_id}': No changes detected."
            )
        return jsonify(updated_gf_data), 200
    except ValueError as ve:
        abort(400, description=f"Invalid data: {ve}")
    except Exception as e:
        log.exception(f"User '{user_id}': Error updating geofence {geofence_id}")
        abort(500, description="Internal server error.")


@bp.route("/geofences/<string:geofence_id>", methods=["DELETE"])
@login_required
def delete_geofence(geofence_id):
    user_id = current_user.id
    log.debug(f"API DELETE /geofences/{geofence_id} by '{user_id}'")
    uds = UserDataService(current_app.config)
    notifier = NotificationService(current_app.config, uds)
    try:
        all_user_geofences = uds.load_geofences_config(user_id)
        if geofence_id not in all_user_geofences:
            abort(404, description="Geofence not found.")
        deleted_name = all_user_geofences[geofence_id].get("name", geofence_id)
        log.info(
            f"User '{user_id}': Deleting geofence '{deleted_name}' ({geofence_id})"
        )
        del all_user_geofences[geofence_id]
        uds.save_geofences_config(user_id, all_user_geofences)
        devices_config = uds.load_devices_config(user_id)
        updated_devices = False
        for device_id, config in devices_config.items():
            original_links = config.get("linked_geofences", [])
            updated_links = [
                link for link in original_links if link.get("id") != geofence_id
            ]
            if len(updated_links) < len(original_links):
                config["linked_geofences"] = updated_links
                updated_devices = True
                log.info(
                    f"User '{user_id}': Unlinked '{geofence_id}' from '{device_id}'."
                )
        if updated_devices:
            uds.save_devices_config(user_id, devices_config)
        notifier.cleanup_stale_geofence_states_for_geofence(user_id, geofence_id)
        notifier.cleanup_stale_notification_times_for_geofence(user_id, geofence_id)
        log.info(
            f"User '{user_id}': Deleted geofence '{deleted_name}' ({geofence_id}) and cleaned up state/links."
        )
        return (
            jsonify({"message": f"Geofence '{deleted_name}' deleted successfully."}),
            200,
        )
    except ValueError as ve:
        abort(400, description=f"Invalid data: {ve}")
    except Exception as e:
        log.exception(f"User '{user_id}': Error deleting geofence {geofence_id}")
        abort(500, description="Internal server error.")


# --- Push Subscription API ---
# Keep existing GET /vapid_public_key, POST /subscribe, POST /unsubscribe logic
@bp.route("/vapid_public_key", methods=["GET"])
def get_vapid_public_key():
    log.debug("API GET /vapid_public_key called.")
    if (
        not current_app.config["VAPID_ENABLED"]
        or not current_app.config["VAPID_PUBLIC_KEY"]
    ):
        log.error("VAPID public key requested but not configured.")
        abort(503, description="Push notifications not configured.")
    return jsonify({"publicKey": current_app.config["VAPID_PUBLIC_KEY"]})


@bp.route("/subscribe", methods=["POST"])
@login_required
def subscribe():
    user_id = current_user.id
    log.debug(f"API POST /subscribe by '{user_id}'")
    uds = UserDataService(current_app.config)
    notifier = NotificationService(current_app.config, uds)
    if not current_app.config["VAPID_ENABLED"]:
        abort(503, description="Push notifications disabled.")
    subscription_data = request.get_json()
    if not notifier.is_valid_subscription(subscription_data):
        abort(400, description="Invalid subscription data.")
    endpoint = subscription_data["endpoint"]
    new_subscription = False
    try:
        user_subscriptions = uds.load_subscriptions(user_id)
        if endpoint not in user_subscriptions:
            log.info(f"User '{user_id}': New push subscription: {endpoint[:50]}...")
            user_subscriptions[endpoint] = subscription_data
            uds.save_subscriptions(user_id, user_subscriptions)
            new_subscription = True
        else:
            log.info(f"User '{user_id}': Subscription exists: {endpoint[:50]}...")
        if new_subscription:
            notifier.send_welcome_notification(user_id, subscription_data)
        status_code = 201 if new_subscription else 200
        log.info(f"API POST /subscribe for '{user_id}': Responding {status_code}.")
        return jsonify({"message": "Subscription received."}), status_code
    except Exception as e:
        log.exception(
            f"Error processing subscription for '{user_id}', {endpoint[:50]}..."
        )
        abort(500, "Failed to process subscription.")


@bp.route("/unsubscribe", methods=["POST"])
@login_required
def unsubscribe():
    user_id = current_user.id
    log.debug(f"API POST /unsubscribe by '{user_id}'")
    uds = UserDataService(current_app.config)
    data = request.get_json()
    endpoint = data.get("endpoint") if isinstance(data, dict) else None
    if not endpoint or not isinstance(endpoint, str):
        abort(400, description="Invalid request: 'endpoint' (string) required.")
    removed = False
    try:
        user_subscriptions = uds.load_subscriptions(user_id)
        if endpoint in user_subscriptions:
            log.info(
                f"User '{user_id}': Removing subscription via API: {endpoint[:50]}..."
            )
            del user_subscriptions[endpoint]
            uds.save_subscriptions(user_id, user_subscriptions)
            removed = True
            log.info(f"User '{user_id}': Successfully removed {endpoint[:50]}...")
        else:
            log.info(
                f"User '{user_id}': Unsubscribe for non-existent endpoint: {endpoint[:50]}..."
            )
        response_message = (
            "Unsubscription successful" if removed else "Subscription not found"
        )
        log.info(
            f"API POST /unsubscribe for '{user_id}': Responding 200. Msg: {response_message}"
        )
        return jsonify({"message": response_message}), 200
    except Exception as e:
        log.exception(f"Error during unsubscribe for '{user_id}', {endpoint[:50]}...")
        abort(500, "Failed to process unsubscription.")


# --- Utils API ---
# Keep existing GET /utils/generate_icon
@bp.route("/utils/generate_icon", methods=["GET"])
@login_required
def generate_icon():
    label = request.args.get("label", "?")
    color = request.args.get("color", None)
    size = request.args.get("size", 36, type=int)
    if not color:
        color = getDefaultColorForId(label)
    elif not re.match(r"^#[0-9a-fA-F]{6}$", color):
        log.warning(f"Invalid color '{color}' requested, using default.")
        color = "#70757a"
    try:
        svg_content = generate_device_icon_svg(label, color, size)
        return Response(svg_content, mimetype="image/svg+xml")
    except Exception as e:
        log.error(f"Error generating SVG icon via API: {e}")
        abort(500, "Failed to generate icon")


# --- Config Export/Import API ---
# Keep existing GET /config/get_part/<part>, POST /config/import_apply
@bp.route("/config/get_part/<string:part_name>", methods=["GET"])
@login_required
def get_config_part(part_name):
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    data_to_return = None
    try:
        if part_name == "geofences":
            data_to_return = uds.load_geofences_config(user_id)
        elif part_name == "devices":
            devices_conf = uds.load_devices_config(user_id)
            data_to_return = {
                dev_id: {k: v for k, v in conf.items() if k != "svg_icon"}
                for dev_id, conf in devices_conf.items()
            }
        else:
            abort(404, description=f"Unknown config part: {part_name}")
        log.info(f"User '{user_id}': Providing config part '{part_name}'.")
        return jsonify(data_to_return)
    except Exception as e:
        log.exception(f"Error providing config part '{part_name}' for user '{user_id}'")
        abort(500, description=f"Error retrieving configuration part: {part_name}")


@bp.route("/config/import_apply", methods=["POST"])
@login_required
def config_import_apply():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    data = request.get_json()
    if not data or not isinstance(data.get("parts"), dict):
        log.warning(f"User '{user_id}' import apply: Invalid request body.")
        abort(400, description="Invalid request: 'parts' dictionary required.")
    parts_to_import = data["parts"]
    results = {"success": [], "errors": []}
    config_changed = False
    log.info(
        f"User '{user_id}': Applying imported server config parts: {list(parts_to_import.keys())}"
    )
    if "geofences" in parts_to_import:
        geofence_data = parts_to_import["geofences"]
        log.debug(f"User '{user_id}': Found 'geofences' part for import.")
        if isinstance(geofence_data, dict):
            try:
                num_geofences = len(geofence_data)
                log.info(
                    f"User '{user_id}': Attempting to save {num_geofences} imported geofences."
                )
                uds.save_geofences_config(user_id, geofence_data)
                results["success"].append(f"Imported {num_geofences} geofences.")
                config_changed = True
                log.info(f"User '{user_id}': Successfully imported geofences.")
            except Exception as e:
                log.error(
                    f"User '{user_id}': Error importing geofences: {e}", exc_info=True
                )
                results["errors"].append(
                    f"Failed to import geofences: {str(e)[:100]}..."
                )
        else:
            log.warning(
                f"User '{user_id}': Invalid format for geofences data (not dict)."
            )
            results["errors"].append("Invalid format for geofences data.")
    if "devices" in parts_to_import:
        device_data = parts_to_import["devices"]
        log.debug(f"User '{user_id}': Found 'devices' part for import.")
        if isinstance(device_data, dict):
            try:
                num_devices = len(device_data)
                log.info(
                    f"User '{user_id}': Attempting to save {num_devices} imported device configurations."
                )
                uds.save_devices_config(user_id, device_data)
                results["success"].append(
                    f"Imported {num_devices} device configurations."
                )
                config_changed = True
                log.info(
                    f"User '{user_id}': Successfully imported device configurations."
                )
            except Exception as e:
                log.error(
                    f"User '{user_id}': Error importing devices config: {e}",
                    exc_info=True,
                )
                results["errors"].append(
                    f"Failed to import device configurations: {str(e)[:100]}..."
                )
        else:
            log.warning(
                f"User '{user_id}': Invalid format for devices data (not dict)."
            )
            results["errors"].append("Invalid format for devices data.")
    if config_changed and not results["errors"]:
        log.info(f"User '{user_id}': Import successful, configuration changed.")
    if not results["errors"]:
        log.info(f"User '{user_id}': Config import apply finished successfully.")
        return (
            jsonify(
                {
                    "message": "Server configuration imported successfully.",
                    "details": results,
                }
            ),
            200,
        )
    elif results["success"]:
        log.warning(f"User '{user_id}': Config import apply finished with some errors.")
        return (
            jsonify(
                {
                    "message": "Server configuration imported with some errors.",
                    "details": results,
                }
            ),
            207,
        )
    else:
        log.error(f"User '{user_id}': Config import apply failed completely.")
        return (
            jsonify(
                {"error": "Failed to import server configuration.", "details": results}
            ),
            500,
        )


# --- Test Notification API ---
# Keep existing POST /devices/<id>/test_notification/<type>
@bp.route(
    "/devices/<string:device_id>/test_notification/<string:notification_type>",
    methods=["POST"],
)
@login_required
def test_device_notification(device_id, notification_type):
    user_id = current_user.id
    log.info(
        f"API POST /devices/{device_id}/test_notification/{notification_type} by '{user_id}'"
    )
    uds = UserDataService(current_app.config)
    notifier = NotificationService(current_app.config, uds)
    try:
        device_config = uds.load_devices_config(user_id).get(device_id)
        if not device_config:
            abort(404, description="Device configuration not found.")
        device_name = device_config.get("name", device_id)
        device_label = device_config.get("label", "❓")
        device_color = device_config.get("color", getDefaultColorForId(device_id))
        title = f"Test: {device_name}"
        body = ""
        data_payload = {
            "type": "test",
            "deviceId": device_id,
            "testType": notification_type,
        }
        notification_specific_type = "test"
        if notification_type == "geofence_entry":
            test_gf_name = "Test Area"
            title = f"{device_name} Entered {test_gf_name} (Test)"
            body = f"This is a test notification for entering '{test_gf_name}'."
            data_payload["geofenceName"] = test_gf_name
            data_payload["eventType"] = "entry"
            notification_specific_type = "geofence"
        elif notification_type == "geofence_exit":
            test_gf_name = "Test Area"
            title = f"{device_name} Exited {test_gf_name} (Test)"
            body = f"This is a test notification for exiting '{test_gf_name}'."
            data_payload["geofenceName"] = test_gf_name
            data_payload["eventType"] = "exit"
            notification_specific_type = "geofence"
        elif notification_type == "battery_low":
            test_level = current_app.config["LOW_BATTERY_THRESHOLD"] - 1
            title = f"{device_name} Battery Low (Test)"
            body = f"Test: Battery is low ({test_level}%)."
            data_payload["level"] = test_level
            notification_specific_type = "battery"
        elif notification_type == "generic_test":
            title = f"Test Notification for {device_name}"
            body = "This is a generic test push message."
        else:
            abort(
                400,
                description=f"Invalid notification type for testing: {notification_type}",
            )
        log.info(
            f"User '{user_id}': Triggering test notification (type: {notification_type}) for device {device_id}"
        )
        notifier.send_user_notifications(
            user_id=user_id,
            title=title,
            body=body,
            tag=f"test-{device_id}-{notification_type}-{int(time.time())}",
            data_payload=data_payload,
            device_label=device_label,
            device_color=device_color,
            notification_type=notification_specific_type,
        )
        return (
            jsonify(
                {
                    "message": f"Test notification '{notification_type}' sent for {device_name}."
                }
            ),
            200,
        )
    except Exception as e:
        log.exception(
            f"Error sending test notification for {device_id}, type {notification_type}, user '{user_id}'"
        )
        abort(500, description="Failed to send test notification.")


# --- Notification History API ---
# Keep existing GET /notifications/history, PUT /read, PUT /unread, DELETE /<id>, DELETE /
@bp.route("/notifications/history", methods=["GET"])
@login_required
def get_notification_history():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    try:
        history = uds.load_notification_history(user_id)
        log.info(
            f"API GET /notifications/history for '{user_id}': Returning {len(history)} entries."
        )
        return jsonify(history)
    except Exception as e:
        log.exception(f"Error getting notification history for user '{user_id}'")
        abort(500, description="Failed to load notification history.")


@bp.route("/notifications/history/<string:notification_id>/read", methods=["PUT"])
@login_required
def mark_notification_read(notification_id):
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    log.info(f"API PUT /notifications/history/{notification_id}/read by '{user_id}'")
    try:
        success = uds.update_notification_read_status(user_id, notification_id, True)
        return jsonify({"message": "Notification marked as read."}), (
            200
            if success
            else (jsonify({"error": "Notification not found or update failed."}), 404)
        )
    except Exception as e:
        log.exception(
            f"Error marking notification read for user '{user_id}', id {notification_id}"
        )
        abort(500, description="Failed to update notification status.")


@bp.route("/notifications/history/<string:notification_id>/unread", methods=["PUT"])
@login_required
def mark_notification_unread(notification_id):
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    log.info(f"API PUT /notifications/history/{notification_id}/unread by '{user_id}'")
    try:
        success = uds.update_notification_read_status(user_id, notification_id, False)
        return jsonify({"message": "Notification marked as unread."}), (
            200
            if success
            else (jsonify({"error": "Notification not found or update failed."}), 404)
        )
    except Exception as e:
        log.exception(
            f"Error marking notification unread for user '{user_id}', id {notification_id}"
        )
        abort(500, description="Failed to update notification status.")


@bp.route("/notifications/history/<string:notification_id>", methods=["DELETE"])
@login_required
def delete_notification(notification_id):
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    log.info(f"API DELETE /notifications/history/{notification_id} by '{user_id}'")
    try:
        success = uds.delete_notification_history(user_id, notification_id)
        return jsonify({"message": "Notification deleted."}), (
            200
            if success
            else (jsonify({"error": "Notification not found or delete failed."}), 404)
        )
    except Exception as e:
        log.exception(
            f"Error deleting notification for user '{user_id}', id {notification_id}"
        )
        abort(500, description="Failed to delete notification.")


@bp.route("/notifications/history", methods=["DELETE"])
@login_required
def delete_all_notifications():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    log.warning(f"API DELETE /notifications/history (ALL) by '{user_id}'")
    try:
        success = uds.delete_notification_history(user_id, None)
        return jsonify({"message": "All notification history cleared."}), (
            200
            if success
            else (jsonify({"error": "Failed to clear notification history."}), 500)
        )
    except Exception as e:
        log.exception(f"Error clearing notification history for user '{user_id}'")
        abort(500, description="Failed to clear notification history.")


# --- User Preferences API ---
# Keep existing GET /user/preferences, PUT /user/preferences
@bp.route("/user/preferences", methods=["GET"])
@login_required
def get_user_preferences():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    try:
        prefs = uds.load_user_preferences(user_id)
        log.debug(f"API GET /user/preferences for '{user_id}': Returning {prefs}")
        return jsonify(prefs)
    except Exception as e:
        log.exception(f"Error getting preferences for user '{user_id}'")
        abort(500, description="Failed to load user preferences.")


@bp.route("/user/preferences", methods=["PUT"])
@login_required
def update_user_preferences():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    data = request.get_json()
    if not data or "theme_mode" not in data or "theme_color" not in data:
        log.warning(
            f"User '{user_id}' PUT /user/preferences: Invalid data payload: {data}"
        )
        abort(400, description="Missing 'theme_mode' or 'theme_color' in request.")
    theme_mode = data.get("theme_mode")
    theme_color = data.get("theme_color")
    try:
        if theme_mode not in ["system", "light", "dark"]:
            raise ValueError("Invalid theme_mode.")
        if not re.match(r"^#[0-9a-fA-F]{6}$", theme_color):
            raise ValueError("Invalid theme_color format.")
        uds.save_user_preferences(user_id, theme_mode, theme_color)
        log.info(f"API PUT /user/preferences successful for '{user_id}'")
        return jsonify({"message": "Preferences updated successfully."}), 200
    except ValueError as ve:
        log.warning(f"User '{user_id}' PUT /user/preferences: Validation error: {ve}")
        abort(400, description=str(ve))
    except RuntimeError as re_err:
        log.error(f"User '{user_id}' PUT /user/preferences: Runtime error: {re_err}")
        abort(500, description="Server error saving preferences.")
    except Exception as e:
        log.exception(f"Error updating preferences for user '{user_id}'")
        abort(500, description="Failed to save user preferences.")


# --- Account Deletion API ---
# Keep existing DELETE /user/delete
@bp.route("/user/delete", methods=["DELETE"])
@login_required
def delete_account():
    user_id = current_user.id
    log.warning(f"Received DELETE request for account '{user_id}'")
    uds = UserDataService(current_app.config)
    try:
        delete_successful = uds.delete_user_data(user_id)
        if delete_successful:
            log.info(f"Account deletion successful for '{user_id}'. Logging out.")
            logout_user()
            session.clear()
            return (
                jsonify({"message": f"Account '{user_id}' deleted successfully."}),
                200,
            )
        else:
            log.error(
                f"Account deletion failed for '{user_id}' during data removal process."
            )
            abort(
                500,
                description="Failed to delete account data. Please contact support if the issue persists.",
            )
    except Exception as e:
        log.exception(f"Unexpected error during account deletion for '{user_id}'")
        abort(500, description="An unexpected error occurred during account deletion.")


# --- NEW Share Management API Endpoints ---


@bp.route("/devices/<string:device_id>/share", methods=["POST"])
@login_required
def create_device_share(device_id):
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    devices_config = uds.load_devices_config(user_id)
    if device_id not in devices_config:
        abort(404, description="Device not found.")
    data = request.get_json() or {}
    duration_str = data.get("duration", "24h")
    note = data.get("note", "")[:100]
    duration_hours = None
    if duration_str == "indefinite":
        duration_hours = 0
    elif duration_str.endswith("h"):
        try:
            duration_hours = int(duration_str[:-1])
        except ValueError:
            abort(400)
    elif duration_str.endswith("d"):
        try:
            duration_hours = int(duration_str[:-1]) * 24
        except ValueError:
            abort(400)
    else:
        abort(400, description="Invalid duration unit ('h', 'd', 'indefinite').")
    if (
        duration_hours is not None
        and (duration_hours < 0 or duration_hours > 30 * 24)
        and duration_hours != 0
    ):
        abort(400, description="Duration out of range (1h-30d or indefinite).")
    log.info(
        f"User '{user_id}' request share for '{device_id}' (Duration: {duration_str})"
    )
    try:
        new_share = uds.add_share(user_id, device_id, duration_hours, note)
        if new_share:
            # --- CHANGE Blueprint Name Here ---
            share_url = url_for('public.view_shared_device', share_id=new_share["share_id"], _external=True)
            # --- ------------------------- ---
            return jsonify({**new_share, "share_url": share_url}), 201
        else: abort(500, description="Failed to create share.")
    except Exception as e: log.exception(f"Error creating share for {device_id}"); abort(500, description=f"Server error: {e}")


@bp.route("/shares", methods=["GET"])
@login_required
def get_my_shares():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    try:
        active_shares = uds.get_user_shares(
            user_id
        )  # This now includes 'is_expired' flag
        devices_config = uds.load_devices_config(user_id)
        for share in active_shares:
            device_conf = devices_config.get(share.get("device_id"))
            share["device_name"] = (
                device_conf.get("name", share.get("device_id"))
                if device_conf
                else "Unknown Device"
            )
            share["share_url"] = url_for(
                "main.view_shared_device", share_id=share["share_id"], _external=True
            )
        return jsonify(active_shares), 200
    except Exception as e:
        log.exception(f"Error fetching shares for user '{user_id}'")
        abort(500, description="Failed to retrieve shares.")


@bp.route("/shares/<string:share_id>/status", methods=["PUT"])
@login_required
def set_share_status(share_id):
    """Endpoint to suspend (active=false) or resume (active=true) a share."""
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    data = request.get_json()
    if data is None or "active" not in data or not isinstance(data["active"], bool):
        abort(
            400, description="Invalid request body. Expecting {'active': true/false}."
        )

    new_status = data["active"]
    log.info(
        f"User '{user_id}' attempting to set share '{share_id}' status to {new_status}"
    )

    try:
        success = uds.toggle_share_status(share_id, user_id, new_status)
        if success:
            # Optionally return the updated share info
            updated_share = uds.get_share(share_id)
            if updated_share:
                # Add URL and device name like in GET /shares
                devices_config = uds.load_devices_config(user_id)
                device_conf = devices_config.get(updated_share.get("device_id"))
                updated_share["device_name"] = (
                    device_conf.get("name", updated_share.get("device_id"))
                    if device_conf
                    else "Unknown Device"
                )
                updated_share["share_url"] = url_for(
                    "main.view_shared_device", share_id=share_id, _external=True
                )
                updated_share["share_id"] = share_id  # Ensure ID is present
                return jsonify(updated_share), 200
            else:  # Should not happen if toggle succeeded but get failed
                return (
                    jsonify(
                        {
                            "message": f"Share status set to {new_status}, but couldn't retrieve updated details."
                        }
                    ),
                    200,
                )
        else:
            # toggle_share_status handles logging owner check failure or not found
            abort(
                404,
                description="Share not found or you do not have permission to modify it.",
            )
    except Exception as e:
        log.exception(
            f"Error setting status for share '{share_id}' by user '{user_id}'"
        )
        abort(500, description="Failed to update share status.")


@bp.route("/shares/<string:share_id>/duration", methods=["PUT"])
@login_required
def update_share_duration(share_id):
    """Endpoint to update the expiry duration of a share."""
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    data = request.get_json()
    if data is None or "duration" not in data:
        abort(
            400,
            description="Invalid request body. Expecting {'duration': '1h'/'24h'/'7d'/'indefinite'/etc}.",
        )

    duration_str = data["duration"]
    note = data.get("note", None)  # Allow optional note update too
    if note is not None:
        note = note.strip()[:100]

    # --- Parse duration (same logic as create) ---
    duration_hours = None
    if duration_str == "indefinite":
        duration_hours = 0
    elif duration_str.endswith("h"):
        try:
            duration_hours = int(duration_str[:-1])
        except ValueError:
            abort(400, description="Invalid duration format.")
    elif duration_str.endswith("d"):
        try:
            duration_hours = int(duration_str[:-1]) * 24
        except ValueError:
            abort(400, description="Invalid duration format.")
    else:
        abort(400, description="Invalid duration unit.")

    if (
        duration_hours is not None
        and (duration_hours < 0 or duration_hours > 30 * 24)
        and duration_hours != 0
    ):
        abort(400, description="Duration out of range.")
    # --- End duration parsing ---

    log.info(
        f"User '{user_id}' attempting to update duration for share '{share_id}' to {duration_str}"
    )

    try:
        # Update expiry first
        updated_share = uds.update_share_expiry(share_id, user_id, duration_hours)

        if updated_share:
            # If note was also provided, update it separately
            if note is not None:
                all_shares = uds.load_shares()
                if (
                    share_id in all_shares
                    and all_shares[share_id].get("user_id") == user_id
                ):
                    all_shares[share_id]["note"] = note
                    uds.save_shares(all_shares)
                    updated_share["note"] = note  # Reflect note change in response
                    log.info(
                        f"User '{user_id}' also updated note for share '{share_id}'."
                    )

            # Add URL and device name to response
            devices_config = uds.load_devices_config(user_id)
            device_conf = devices_config.get(updated_share.get("device_id"))
            updated_share["device_name"] = (
                device_conf.get("name", updated_share.get("device_id"))
                if device_conf
                else "Unknown Device"
            )
            updated_share["share_url"] = url_for(
                "main.view_shared_device", share_id=share_id, _external=True
            )
            updated_share["share_id"] = share_id  # Ensure ID is present

            return jsonify(updated_share), 200
        else:
            abort(
                404,
                description="Share not found or you do not have permission to modify it.",
            )
    except Exception as e:
        log.exception(
            f"Error updating duration/note for share '{share_id}' by user '{user_id}'"
        )
        abort(500, description="Failed to update share duration/note.")


# --- START: Corrected DELETE Endpoint ---
# Ensure this decorator is directly above the function doing the permanent delete
@bp.route("/shares/<string:share_id>", methods=["DELETE"])
@login_required
def delete_my_share_permanently(share_id): # Function name is correct now
    """Permanently deletes a share link and record."""
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    log.warning(f"Permanent DELETE request for share '{share_id}' by user '{user_id}'") # Log clearly
    try:
        # Call the permanent delete service method
        success = uds.delete_share_permanently(share_id, user_id) # This method physically removes the entry
        if success:
            # Use the correct success message
            return jsonify({"message": "Share link permanently deleted."}), 200
        else:
            # Handle cases where it wasn't found or user didn't own it
            abort(404, description="Share not found or you do not have permission to delete it.")
    except Exception as e:
        log.exception(f"Error permanently deleting share '{share_id}' for user '{user_id}'")
        abort(500, description="Failed to permanently delete share.")
# --- END: Corrected DELETE Endpoint ---

# --- NEW Public API Endpoint for Shared Device Data ---


@bp.route("/public/share/<string:share_id>", methods=["GET"])
def get_public_share_data(share_id):
    # *** NO @login_required ***
    log.debug(f"Public API request for share_id: {share_id}")
    uds = UserDataService(current_app.config)

    try:
        share_info = uds.get_share(share_id)

        # Validate share (keep existing validation)
        if not share_info:
            log.warning(f"Public API: Share ID '{share_id}' not found.")
            abort(404, description="Share not found.")
        if not share_info.get("active", False):
            log.info(f"Public API: Share ID '{share_id}' is inactive.")
            abort(410, description="Share has been revoked.")  # Gone
        now_utc = datetime.now(timezone.utc)
        expires_at_str = share_info.get("expires_at")
        if expires_at_str:
            try:
                expires_at_dt = datetime.fromisoformat(
                    expires_at_str.replace("Z", "+00:00")
                )
                if expires_at_dt.tzinfo is None:
                    expires_at_dt = expires_at_dt.replace(tzinfo=timezone.utc)
                if expires_at_dt < now_utc:
                    log.info(f"Public API: Share ID '{share_id}' has expired.")
                    abort(410, description="Share has expired.")  # Gone
            except ValueError:
                log.error(f"Public API: Invalid expires_at format for share {share_id}")
                abort(500, description="Invalid share data.")

        owner_id = share_info.get("user_id")
        device_id = share_info.get("device_id")
        if not owner_id or not device_id:
            log.error(f"Public API: Share {share_id} is missing owner or device ID.")
            abort(500, description="Invalid share data.")

        # Fetch latest cached data for the *owner*
        owner_cache = uds.load_cache_from_file(owner_id)
        if (
            not owner_cache
            or "data" not in owner_cache
            or not isinstance(owner_cache["data"], dict)
        ):
            log.warning(
                f"Public API: Cache for owner '{owner_id}' (share '{share_id}') not available."
            )
            abort(503, description="Device location data is temporarily unavailable.")

        device_data_from_cache = owner_cache["data"].get(device_id)
        # --- START: Handle missing device data or reports ---
        if not device_data_from_cache:
            log.warning(
                f"Public API: No data structure found for device '{device_id}' in owner '{owner_id}' cache (share '{share_id}'). Might be syncing."
            )
            abort(
                503,
                description="Device data not yet available. Please try again shortly.",
            )

        reports_list = device_data_from_cache.get(
            "reports", []
        )  # Get reports list safely
        latest_report = (
            reports_list[0] if reports_list else None
        )  # Get latest only if list is not empty
        # --- END: Handle missing device data or reports ---

        device_config = device_data_from_cache.get(
            "config", {}
        )  # Config from owner's cache

        # Extract display info
        device_name = device_config.get("name", device_id) or device_id
        device_label = device_config.get("label", "❓") or "❓"
        device_color_hex = device_config.get("color")
        final_device_color = (
            device_color_hex if device_color_hex else getDefaultColorForId(device_id)
        )

        # --- START: Safely extract data from latest_report (if it exists) ---
        lat = latest_report.get("lat") if latest_report else None
        lng = latest_report.get("lon") if latest_report else None
        timestamp_iso = latest_report.get("timestamp") if latest_report else None
        battery_level_raw = latest_report.get("battery") if latest_report else None
        raw_status_code = latest_report.get("status") if latest_report else None
        # --- END: Safely extract data ---

        battery_level, battery_status = _parse_battery_info(
            battery_level_raw,
            raw_status_code,
            current_app.config.get("LOW_BATTERY_THRESHOLD", 15),
        )

        response = {
            "device_name": device_name,
            "device_label": device_label,
            "device_color": final_device_color,
            "lat": lat,  # Will be null if no report
            "lng": lng,  # Will be null if no report
            "timestamp": timestamp_iso,  # Will be null if no report
            "battery_level": battery_level,  # Will be null if no report
            "battery_status": battery_status,  # Will be 'Unknown' if no report
            "last_updated": owner_cache.get(
                "timestamp"
            ),  # Cache timestamp is still relevant
            "share_note": share_info.get("note", ""),
        }
        log.info(
            f"Public API: Successfully served data for share '{share_id}' (Report found: {latest_report is not None})"
        )
        return jsonify(response)

    except Exception as e:
        # Log the full exception for internal debugging
        log.exception(f"Error fetching public share data for '{share_id}'")
        # Return a generic 500 error to the public user
        abort(
            500, description="An error occurred while retrieving shared location data."
        )

// --------------------
// app\main\routes.py
# app/main/routes.py


import logging
from flask import (
    render_template,
    request,
    flash,
    redirect,
    url_for,
    session,
    current_app,
    send_from_directory,
    abort,
    Response,
    make_response,
)

from flask_login import login_required, current_user
import threading
import traceback
import os

from . import bp
from app.services.user_data_service import UserDataService
from app.scheduler.tasks import run_fetch_for_user_task
from app.auth.forms import AppleCredentialsForm

log = logging.getLogger(__name__)

# --- Core Page Routes ---


@bp.route("/")
@login_required
def index_route():
    user_id = current_user.id
    log.debug(f"Rendering index page for user '{user_id}'.")
    return render_template("index.html")


@bp.route("/manage_apple_creds", methods=["GET", "POST"])
@login_required
def manage_apple_creds_route():
    user_id = current_user.id
    uds = UserDataService(current_app.config)
    form = AppleCredentialsForm()  # Instantiate the form

    if form.validate_on_submit():  # Handles POST, validation, CSRF
        apple_id = form.apple_id.data.strip()
        apple_password = form.apple_password.data  # No strip

        try:
            uds.save_apple_credentials(user_id, apple_id, apple_password)
            log.info(
                f"User '{user_id}' updated Apple credentials in storage (ID: {apple_id})."
            )
            flash("Apple credentials updated and stored securely.", "success")

            log.info(
                f"Triggering immediate fetch for user '{user_id}' after credential update."
            )
            try:
                # Note: run_fetch_for_user_task should ideally handle decryption itself
                # or we pass the unencrypted password carefully.
                # For now, assume run_fetch_for_user_task expects the unencrypted password.
                immediate_fetch_thread = threading.Thread(
                    target=run_fetch_for_user_task,
                    args=(user_id, apple_id, apple_password, current_app.config),
                    name=f"ImmediateFetch-{user_id}",
                    daemon=True,
                )
                immediate_fetch_thread.start()
                flash("Credentials saved. Initial background fetch initiated.", "info")
            except Exception as e:
                log.error(
                    f"Failed to start immediate fetch thread for user '{user_id}': {e}",
                    exc_info=True,
                )
                flash(
                    "Credentials saved, but initial fetch could not be started.",
                    "warning",
                )

            return redirect(
                url_for(".index_route")
            )  # Redirect to main app after success

        except ValueError as ve:  # Catch specific validation errors from UDS
            log.error(f"Validation error saving credentials for user {user_id}: {ve}")
            flash(f"Failed to save credentials: {ve}", "error")
            # No redirect, fall through to render template again
        except Exception as e:
            log.exception(f"Error saving Apple credentials for user {user_id}")
            flash("Failed to save credentials: An unexpected error occurred.", "error")
            # No redirect, fall through to render template again

    # --- Render the GET request or if validation failed ---
    # Pre-populate the Apple ID field if it exists
    current_apple_id_stored = None
    if not form.is_submitted():  # Only load on GET request
        try:
            current_apple_id_stored, _ = uds.load_apple_credentials(user_id)
            form.apple_id.data = current_apple_id_stored or ""  # Pre-fill form field
            log.debug(
                f"Pre-populating manage_apple_creds form for '{user_id}'. Stored ID: {bool(current_apple_id_stored)}"
            )
        except Exception as e:
            log.error(f"Error loading Apple credentials for form pre-population: {e}")
            flash("Could not load current Apple ID status.", "warning")

    # Pass the form object to the template
    return render_template(
        "manage_apple_creds.html",
        title="Manage Apple Credentials",
        form=form,
        current_apple_id=current_apple_id_stored,
    )


@bp.route("/sw.js")
def service_worker():
    log.debug("Serving sw.js request...")
    # Construct path relative to the *application root*, not static folder directly
    # Assuming run.py is at the root, and app is a subdir.
    # If static folder is correctly set in Flask, this should work:
    static_dir = current_app.static_folder  # Should be absolute path inside container
    sw_path = os.path.join(static_dir, "sw.js")
    log.info(f"Attempting to send service worker from calculated path: {sw_path}")

    # Defensive check if static_folder is unexpectedly relative
    if not os.path.isabs(static_dir):
        # Assuming static folder is relative to app root (where __init__.py is)
        static_dir_abs = os.path.join(current_app.root_path, static_dir)
        sw_path = os.path.join(static_dir_abs, "sw.js")
        log.warning(
            f"Static folder was relative, recalculated absolute sw.js path: {sw_path}"
        )

    if not os.path.exists(sw_path):
        log.error(f"Service worker file not found at: {sw_path}")
        abort(404)

    try:
        response = make_response(
            send_from_directory(
                os.path.dirname(sw_path),  # Send from the directory containing sw.js
                os.path.basename(sw_path),  # Send the filename
                mimetype="application/javascript",
            )
        )
        response.headers["Service-Worker-Allowed"] = "/"
        # Aggressive caching prevention for SW itself during dev/updates
        response.headers["Cache-Control"] = (
            "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0"
        )
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response
    except FileNotFoundError:  # Should be caught by os.path.exists, but defensive
        log.error("sw.js not found using send_from_directory (should not happen).")
        abort(404)
    except Exception as e:
        log.exception("Error serving sw.js")
        abort(500)


# Keep existing Favicon route (using absolute path generation)
@bp.route("/favicon.ico")
def favicon():
    try:
        # Use static_folder which should resolve correctly
        return send_from_directory(
            current_app.static_folder,
            "favicon.ico",
            mimetype="image/vnd.microsoft.icon",
        )
    except Exception as e:
        # Try absolute path relative to app root as fallback
        try:
            log.warning(
                f"Failed to send favicon from static_folder, trying absolute path construction."
            )
            abs_path = os.path.join(current_app.root_path, "static")
            return send_from_directory(
                abs_path, "favicon.ico", mimetype="image/vnd.microsoft.icon"
            )
        except Exception as e2:
            log.error(
                f"favicon.ico not found in static folder ({current_app.static_folder}) or absolute path. Error: {e2}"
            )
            abort(404)


# --- NEW Public Share Route ---
@bp.route("/shared/<string:share_id>")
def view_shared_device(share_id):
    """Renders the public map page for a shared device."""
    # No validation needed here, the template/JS will call the public API
    # which performs validation.
    log.info(f"Serving public share page for ID: {share_id}")
    return render_template("share_map.html", share_id=share_id)

// --------------------
// app\main\__init__.py
# app/main/__init__.py
from flask import Blueprint

bp = Blueprint('main', __name__, template_folder='../templates', static_folder='../static', static_url_path='/static')

# Import routes and API endpoints after blueprint creation
from . import routes # noqa
from . import api    # noqa
// --------------------
// app\public\routes.py
# app/public/routes.py

import logging
import os
from flask import (
    render_template,
    current_app,
    send_from_directory,
    abort,
    make_response,
    jsonify
)

# ADD Service and Helper imports needed by the API function
from app.services.user_data_service import UserDataService
from app.utils.helpers import getDefaultColorForId
from app.utils.data_formatting import _parse_battery_info
from datetime import datetime, timezone # <<< ADD datetime imports

# Use the blueprint defined in app/public/__init__.py
from . import bp

log = logging.getLogger(__name__)

# --- Publicly Accessible Routes ---

@bp.route("/shared/<string:share_id>")
def view_shared_device(share_id):
    """Renders the public map page for a shared device."""
    log.info(f"Serving public share page for ID: {share_id}")
    return render_template("share_map.html", share_id=share_id)

@bp.route("/sw.js")
def service_worker():
    log.debug("Serving sw.js request from /public/sw.js...")
    static_dir = current_app.static_folder
    sw_path = os.path.join(static_dir, "sw.js")
    log.info(f"Attempting to send service worker from: {sw_path}")

    if not os.path.exists(sw_path):
        log.error(f"Service worker file not found at: {sw_path}")
        abort(404)

    try:
        response = make_response(
            send_from_directory(
                os.path.dirname(sw_path),
                os.path.basename(sw_path),
                mimetype="application/javascript",
            )
        )
        response.headers["Service-Worker-Allowed"] = "/" # Keep scope as root
        response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response
    except Exception as e:
        log.exception("Error serving sw.js")
        abort(500)

@bp.route("/manifest.json")
def manifest():
    log.debug("Serving manifest.json request from /public/manifest.json...")
    static_dir = current_app.static_folder
    manifest_path = os.path.join(static_dir, "manifest.json")
    log.info(f"Attempting to send manifest from calculated path: {manifest_path}") # ADD THIS LOG
    if not os.path.exists(manifest_path):
         log.error(f"Manifest file not found at: {manifest_path}")
         abort(404)
    try:
         log.info(">>> Sending manifest file now...") # ADD THIS LOG
         return send_from_directory(
             os.path.dirname(manifest_path),
             os.path.basename(manifest_path),
             mimetype="application/manifest+json"
         )
    except Exception as e:
         log.exception("Error serving manifest.json")
         abort(500)

@bp.route("/favicon.ico")
def favicon():
    log.debug("Serving favicon.ico request from /public/favicon.ico...")
    try:
        # Use static_folder which should resolve correctly
        return send_from_directory(
            current_app.static_folder,
            "favicon.ico",
            mimetype="image/vnd.microsoft.icon",
        )
    except Exception as e:
        log.error(f"favicon.ico not found. Error: {e}")
        abort(404)

@bp.route("/api/shared/<string:share_id>") # <<< Note: Path matches JS call
def get_public_share_data_new(share_id):
    # --- This is the logic copied & adapted from app/main/api.py ---
    log.debug(f"Public API request for share_id (via /public/api/shared): {share_id}")
    # Need a UDS instance - use current_app.config
    uds = UserDataService(current_app.config)

    try:
        share_info = uds.get_share(share_id)

        # Validate share (keep existing validation)
        if not share_info:
            log.warning(f"Public API: Share ID '{share_id}' not found.")
            abort(404, description="Share not found.")
        if not share_info.get("active", False):
            log.info(f"Public API: Share ID '{share_id}' is inactive.")
            abort(410, description="Share has been revoked.")  # Gone
        now_utc = datetime.now(timezone.utc)
        expires_at_str = share_info.get("expires_at")
        if expires_at_str:
            try:
                expires_at_dt = datetime.fromisoformat(
                    expires_at_str.replace("Z", "+00:00")
                )
                if expires_at_dt.tzinfo is None:
                    expires_at_dt = expires_at_dt.replace(tzinfo=timezone.utc)
                if expires_at_dt < now_utc:
                    log.info(f"Public API: Share ID '{share_id}' has expired.")
                    abort(410, description="Share has expired.")  # Gone
            except ValueError:
                log.error(f"Public API: Invalid expires_at format for share {share_id}")
                abort(500, description="Invalid share data.")

        owner_id = share_info.get("user_id")
        device_id = share_info.get("device_id")
        if not owner_id or not device_id:
            log.error(f"Public API: Share {share_id} is missing owner or device ID.")
            abort(500, description="Invalid share data.")

        # Fetch latest cached data for the *owner*
        owner_cache = uds.load_cache_from_file(owner_id)
        if (
            not owner_cache
            or "data" not in owner_cache
            or not isinstance(owner_cache["data"], dict)
        ):
            log.warning(
                f"Public API: Cache for owner '{owner_id}' (share '{share_id}') not available."
            )
            abort(503, description="Device location data is temporarily unavailable.")

        device_data_from_cache = owner_cache["data"].get(device_id)
        if not device_data_from_cache:
            log.warning(
                f"Public API: No data structure found for device '{device_id}' in owner '{owner_id}' cache (share '{share_id}'). Might be syncing."
            )
            abort(
                503,
                description="Device data not yet available. Please try again shortly.",
            )

        reports_list = device_data_from_cache.get("reports", [])
        latest_report = (reports_list[0] if reports_list else None)

        # *** Need device config from owner's cache/config ***
        # Option 1: Assume config is embedded in cache (done during fetch)
        # device_config = device_data_from_cache.get("config", {})
        # Option 2: Load owner's device config (might be slightly slower)
        owner_devices_config = uds.load_devices_config(owner_id)
        device_config = owner_devices_config.get(device_id, {})
        # ---------------------------------------------------


        # Extract display info
        device_name = device_config.get("name", device_id) or device_id
        device_label = device_config.get("label", "❓") or "❓"
        device_color_hex = device_config.get("color")
        final_device_color = (
            device_color_hex if device_color_hex else getDefaultColorForId(device_id)
        )

        lat = latest_report.get("lat") if latest_report else None
        lng = latest_report.get("lon") if latest_report else None
        timestamp_iso = latest_report.get("timestamp") if latest_report else None
        battery_level_raw = latest_report.get("battery") if latest_report else None
        raw_status_code = latest_report.get("status") if latest_report else None

        battery_level, battery_status = _parse_battery_info(
            battery_level_raw,
            raw_status_code,
            current_app.config.get("LOW_BATTERY_THRESHOLD", 15),
        )

        response = {
            "device_name": device_name,
            "device_label": device_label,
            "device_color": final_device_color,
            "lat": lat,
            "lng": lng,
            "timestamp": timestamp_iso,
            "battery_level": battery_level,
            "battery_status": battery_status,
            "last_updated": owner_cache.get("timestamp"),
            "share_note": share_info.get("note", ""),
        }
        log.info(
            f"Public API: Successfully served data for share '{share_id}' (Report found: {latest_report is not None})"
        )
        return jsonify(response)

    except Exception as e:
        log.exception(f"Error fetching public share data for '{share_id}'")
        abort(500, description="An error occurred while retrieving shared location data.")
// --------------------
// app\public\__init__.py
# app/public/__init__.py
from flask import Blueprint

# Note: url_prefix='/public' will be added during registration in app/__init__.py
bp = Blueprint('public', __name__, template_folder='../templates')

# Import routes after blueprint creation
from . import routes # noqa
// --------------------
// app\scheduler\tasks.py
# app/scheduler/tasks.py
import logging
import time
import threading
import traceback
from datetime import datetime, timedelta, timezone
from typing import Dict, Any, Optional, Set, List

# Import services and utilities
from app.services.user_data_service import UserDataService
from app.services.apple_data_service import AppleDataService
from app.services.notification_service import NotificationService

# Import scheduler components
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.jobstores.base import ConflictingIdError

log = logging.getLogger(__name__)


# --- Individual User Fetch Task ---
def run_fetch_for_user_task(
    user_id: str, apple_id: str, apple_password: str, config_obj: Dict[str, Any]
):
    """
    Performs the background data fetch and processing for a single user.
    This function is intended to be run in a separate thread.

    Args:
        user_id: The ID of the user to fetch data for.
        apple_id: The user's Apple ID (decrypted).
        apple_password: The user's Apple password or ASP (decrypted).
        config_obj: The application configuration dictionary.
    """
    log.info(f"Starting background fetch task for user '{user_id}'...")
    task_start_time = time.monotonic()
    uds = UserDataService(config_obj)
    apple_service = AppleDataService(config_obj, uds)
    notifier = NotificationService(config_obj, uds)

    # 1. Perform Login
    account, login_error_msg = apple_service.perform_account_login(
        apple_id, apple_password
    )

    # Handle login failure
    if login_error_msg or not account:
        log.error(
            f"User '{user_id}': Background fetch failed during login: {login_error_msg}"
        )
        try:
            user_cache = uds.load_cache_from_file(user_id) or {"data": None}
            # *** IMPROVED ERROR MESSAGE FOR CACHE ***
            cache_error_msg = login_error_msg or "Login failed: Unknown reason."
            if "Two-Factor Authentication required" in cache_error_msg:
                cache_error_msg = (
                    "Login Failed: 2FA Required. Use App-Specific Password."
                )
            # *** END IMPROVEMENT ***
            user_cache["error"] = cache_error_msg  # Store user-friendlier message
            user_cache["timestamp"] = datetime.now(timezone.utc).isoformat()
            uds.save_cache_to_file(user_id, user_cache)
            log.debug(
                f"User '{user_id}': Updated cache with login error: {cache_error_msg}"
            )
        except Exception as e:
            log.error(f"User '{user_id}': Failed to update cache with login error: {e}")
        log.info(f"Exiting fetch task early for user '{user_id}' due to login failure.")
        return

    # 2. Fetch Accessory Data
    fetched_data_dict, fetch_errors, found_device_ids = None, None, set()
    try:
        fetched_data_dict, fetch_errors, found_device_ids = (
            apple_service.fetch_accessory_data(user_id, account)
        )
    except Exception as fetch_exc:
        log.exception(
            f"User '{user_id}': Unhandled exception during fetch_accessory_data"
        )
        fetch_errors = f"Fetch failed unexpectedly: {fetch_exc}"

    # Log any non-fatal errors during fetch
    if fetch_errors:
        log.warning(f"User '{user_id}': Fetch encountered errors: {fetch_errors}")

    # 3. Process Fetched Data (if successful)
    if fetched_data_dict is not None:
        timestamp_now_iso = datetime.now(timezone.utc).isoformat()
        user_cache_data = {
            "data": fetched_data_dict,
            "timestamp": timestamp_now_iso,
            "error": fetch_errors,  # Store non-fatal errors in cache
        }

        # Save data to cache file
        try:
            uds.save_cache_to_file(user_id, user_cache_data)
            log.info(
                f"User '{user_id}': Cache updated with {len(fetched_data_dict)} devices."
            )
        except Exception as e:
            log.error(f"User '{user_id}': Failed to save cache file: {e}")
            # Continue processing even if cache save fails

        # Check for notifications based on the new data
        log.info(f"User '{user_id}': Starting notification checks...")
        check_start_time = time.monotonic()
        try:
            # Load fresh device config for notification checks
            user_devices_config_for_notify = uds.load_devices_config(user_id)

            for device_id, device_data in fetched_data_dict.items():
                # Use the config embedded within the fetched data (already validated)
                device_config = device_data.get("config")
                if not device_config:
                    log.debug(
                        f"User '{user_id}': No config found for device '{device_id}' in fetched data during notification check, skipping."
                    )
                    continue

                # Get the latest report from the list (should be sorted newest first)
                latest_report = (
                    device_data["reports"][0] if device_data.get("reports") else None
                )

                if latest_report:
                    try:
                        # Perform geofence and battery checks
                        notifier.check_device_notifications(
                            user_id, device_id, latest_report, device_config
                        )
                    except Exception as notify_err:
                        log.exception(
                            f"User '{user_id}': Error checking notifications for {device_id}: {notify_err}"
                        )
            log.info(
                f"User '{user_id}': Notification checks finished in {time.monotonic() - check_start_time:.2f}s."
            )
        except Exception as e:
            log.error(
                f"User '{user_id}': Error during notification check phase: {e}",
                exc_info=True,
            )

        # Cleanup stale state files (geofence, battery, notifications times)
        cleanup_start_time = time.monotonic()
        try:
            uds.cleanup_user_data_files(user_id, found_device_ids)
            log.debug(
                f"User '{user_id}': Stale state cleanup finished in {time.monotonic() - cleanup_start_time:.2f}s."
            )
        except Exception as e:
            log.error(f"User '{user_id}': Error during state cleanup: {e}")

    # 4. Handle Case Where Fetch Returned No Data
    else:
        log.error(
            f"User '{user_id}': Background fetch did not return any data dictionary (fetch_accessory_data returned None)."
        )
        # Update cache with the fetch error
        try:
            user_cache = uds.load_cache_from_file(user_id) or {"data": None}
            user_cache["error"] = (
                fetch_errors or "Failed to retrieve data dictionary from fetch service."
            )
            user_cache["timestamp"] = datetime.now(timezone.utc).isoformat()
            uds.save_cache_to_file(user_id, user_cache)
            log.debug(f"User '{user_id}': Updated cache with fetch failure error.")
        except Exception as e:
            log.error(f"User '{user_id}': Failed to update cache with fetch error: {e}")

    # 5. Log Task Completion
    log.info(
        f"Finished background fetch task for user '{user_id}' in {time.monotonic() - task_start_time:.2f}s."
    )


# --- Master Scheduler Job ---
def master_fetch_scheduler_job(config_obj: Dict[str, Any]):
    """
    Scheduler job that iterates through registered users and triggers
    individual fetch tasks (`run_fetch_for_user_task`) in separate threads.

    Args:
        config_obj: The application configuration dictionary.
    """
    log.critical(
        "########## PERIODIC 'master_fetch_scheduler_job' EXECUTION STARTING ##########"
    )
    job_start_time = time.monotonic()

    uds = UserDataService(config_obj)  # Initialize service for this job run

    try:
        users = uds.load_users()  # Load list of registered users
    except Exception as e:
        log.error(f"Master fetch: Failed to load users file ({uds.users_file}): {e}")
        log.critical(
            "########## PERIODIC 'master_fetch_scheduler_job' FAILED (Cannot Load Users) ##########"
        )
        return  # Cannot proceed

    if not users:
        log.info("Master fetch: No users found in database. Periodic job exiting.")
        log.critical(
            "########## PERIODIC 'master_fetch_scheduler_job' FINISHED (No Users) ##########"
        )
        return

    users_to_fetch = list(users.keys())
    log.info(
        f"Master fetch: Found {len(users_to_fetch)} users. Checking credentials and spawning tasks..."
    )
    active_threads_before = threading.active_count()

    spawned_count = 0
    skipped_count = 0
    thread_list = []  # Keep track of spawned threads

    for user_id in users_to_fetch:
        try:
            # Load DECRYPTED credentials for the user
            apple_id, apple_password = uds.load_apple_credentials(user_id)

            # Check if credentials exist
            if not apple_id or not apple_password:
                log.warning(
                    f"Master fetch: Skipping user '{user_id}', Apple credentials not found or incomplete."
                )
                # Optionally update cache to reflect missing credentials if needed
                try:
                    user_cache = uds.load_cache_from_file(user_id) or {"data": None}
                    # Only update error if it's different or cache is missing error
                    if (
                        user_cache.get("error")
                        != "Apple credentials not set. Cannot fetch data."
                    ):
                        user_cache["error"] = (
                            "Apple credentials not set. Cannot fetch data."
                        )
                        user_cache["timestamp"] = datetime.now(timezone.utc).isoformat()
                        uds.save_cache_to_file(user_id, user_cache)
                except Exception as e:
                    log.error(
                        f"Master fetch: Failed to update cache for skipped user '{user_id}': {e}"
                    )
                skipped_count += 1
                continue  # Skip to the next user

            # Spawn a new thread for the user fetch task
            log.debug(f"Master fetch: Spawning fetch task thread for user '{user_id}'")
            fetch_thread = threading.Thread(
                target=run_fetch_for_user_task,
                args=(
                    user_id,
                    apple_id,
                    apple_password,
                    config_obj,
                ),  # Pass necessary args
                name=f"FetchUser-{user_id}",  # Helpful thread name
                daemon=True,  # Allow main process to exit even if threads are running
            )
            fetch_thread.start()
            thread_list.append(fetch_thread)
            spawned_count += 1

        except Exception as e:
            # Catch errors during credential loading or thread spawning for a specific user
            log.error(
                f"Master fetch: Failed to prepare or start fetch thread for user '{user_id}': {e}",
                exc_info=True,  # Log traceback
            )
            # Continue to the next user

    # --- Job Completion Logging ---
    active_threads_after = threading.active_count()
    log.info(
        f"Master fetch scheduler job finished spawning tasks in {time.monotonic() - job_start_time:.2f}s. "
        f"Tasks Spawned: {spawned_count}, Skipped (No Creds): {skipped_count}. "
        f"Threads before: {active_threads_before}, after start: {active_threads_after}."
        # Note: 'active_threads_after' includes the threads just spawned.
    )
    log.critical(
        "########## PERIODIC 'master_fetch_scheduler_job' EXECUTION FINISHED ##########"
    )


# --- Notification History Pruning Job ---
def prune_all_notification_histories_job(config_obj: Dict[str, Any]):
    """
    Scheduler job that iterates through users and prunes old notification history entries.

    Args:
        config_obj: The application configuration dictionary.
    """
    log.info(
        "########## PERIODIC 'prune_notification_history' EXECUTION STARTING ##########"
    )
    job_start_time = time.monotonic()
    uds = UserDataService(config_obj)

    try:
        users = uds.load_users()
    except Exception as e:
        log.error(f"Pruning job: Failed to load users file ({uds.users_file}): {e}")
        log.warning(
            "########## PERIODIC 'prune_notification_history' FAILED (Cannot Load Users) ##########"
        )
        return

    if not users:
        log.info("Pruning job: No users found.")
        log.info(
            "########## PERIODIC 'prune_notification_history' FINISHED (No Users) ##########"
        )
        return

    users_to_prune = list(users.keys())
    log.info(f"Pruning job: Found {len(users_to_prune)} users. Starting pruning...")
    pruned_user_count = 0
    error_count = 0

    for user_id in users_to_prune:
        try:
            # UserDataService.prune_notification_history handles file locking
            uds.prune_notification_history(user_id)
            pruned_user_count += 1
        except Exception as e:
            log.error(
                f"Error pruning notification history for user '{user_id}': {e}",
                exc_info=True,
            )
            error_count += 1

    log.info(
        f"Finished notification history pruning job in {time.monotonic() - job_start_time:.2f}s. "
        f"Users checked: {len(users_to_prune)}, Errors: {error_count}."
    )
    log.info(
        "########## PERIODIC 'prune_notification_history' EXECUTION FINISHED ##########"
    )


# --- NEW: Share Pruning Job ---
def prune_shares_job(config_obj: Dict[str, Any]):
    """Scheduler job that triggers pruning of expired/inactive shares."""
    log.info("########## PERIODIC 'prune_shares_job' EXECUTION STARTING ##########")
    job_start_time = time.monotonic()
    uds = UserDataService(config_obj)

    try:
        uds.prune_expired_shares()
    except Exception as e:
        log.exception("Error occurred during prune_expired_shares execution.")

    log.info(
        f"Finished share pruning job in {time.monotonic() - job_start_time:.2f}s."
    )
    log.info(
        "########## PERIODIC 'prune_shares_job' EXECUTION FINISHED ##########"
    )



# --- Job Scheduling Function ---
def schedule_jobs(app, scheduler_instance: BackgroundScheduler):
    """
    Adds the required background jobs to the APScheduler instance.

    Args:
        app: The Flask application instance (used to get config).
        scheduler_instance: The APScheduler BackgroundScheduler instance.
    """
    config_obj = app.config  # Get config from the app instance

    # --- Schedule Master Fetch Job ---
    fetch_job_id = "master_fetch"
    fetch_interval_minutes = config_obj.get("FETCH_INTERVAL_MINUTES", 15)
    log.info(f"Configured FETCH_INTERVAL_MINUTES = {fetch_interval_minutes}")

    if fetch_interval_minutes <= 0:
        log.error(
            f"Invalid FETCH_INTERVAL_MINUTES ({fetch_interval_minutes}). Fetch job not scheduled."
        )
    elif scheduler_instance.get_job(fetch_job_id):
        log.info(f"Scheduler job '{fetch_job_id}' already exists. Skipping add.")
    else:
        log.info(
            f"Attempting to schedule job '{fetch_job_id}' every {fetch_interval_minutes} minutes."
        )
        try:
            scheduler_instance.add_job(
                master_fetch_scheduler_job,
                trigger=IntervalTrigger(
                    minutes=fetch_interval_minutes,
                    jitter=30,  # Add 30s jitter to spread load
                ),
                args=[config_obj],  # Pass config to the job function
                id=fetch_job_id,
                name="Master User Data Fetch Trigger",
                replace_existing=True,  # Replace if somehow exists with different settings
                misfire_grace_time=max(
                    60, fetch_interval_minutes * 15
                ),  # Allow grace time based on interval
                # Start the first run shortly after app start
                next_run_time=datetime.now(timezone.utc) + timedelta(seconds=30),
            )
            log.info(f"Job '{fetch_job_id}' added successfully.")
        except ConflictingIdError:
            # This shouldn't happen with the get_job check, but handle defensively
            log.warning(f"Scheduler job '{fetch_job_id}' conflict error on add.")
        except Exception as e:
            log.error(
                f"Failed to add scheduler job '{fetch_job_id}': {e}", exc_info=True
            )

    # --- Schedule Notification History Pruning Job ---
    pruning_job_id = "prune_notification_history"
    pruning_interval_hours = 24  # Default: Run once daily

    if scheduler_instance.get_job(pruning_job_id):
        log.info(f"Scheduler job '{pruning_job_id}' already exists. Skipping add.")
    else:
        log.info(
            f"Attempting to schedule job '{pruning_job_id}' every {pruning_interval_hours} hours."
        )
        try:
            scheduler_instance.add_job(
                prune_all_notification_histories_job,
                trigger=IntervalTrigger(
                    hours=pruning_interval_hours, jitter=300  # Add 5 min jitter
                ),
                args=[config_obj],
                id=pruning_job_id,
                name="Prune Notification History",
                replace_existing=True,
                misfire_grace_time=3600,  # Allow 1 hour grace time
                # Start slightly offset from the main fetch job's potential first run
                next_run_time=datetime.now(timezone.utc) + timedelta(minutes=5),
            )
            log.info(f"Job '{pruning_job_id}' added successfully.")
        except ConflictingIdError:
            log.warning(f"Scheduler job '{pruning_job_id}' conflict error on add.")
        except Exception as e:
            log.error(
                f"Failed to add scheduler job '{pruning_job_id}': {e}", exc_info=True
            )

    # --- Schedule Share Pruning Job ---
    share_pruning_job_id = "prune_shares"
    share_pruning_interval_hours = 1 # e.g., Run hourly

    if scheduler_instance.get_job(share_pruning_job_id):
        log.info(f"Scheduler job '{share_pruning_job_id}' already exists. Skipping add.")
    else:
        log.info(f"Attempting to schedule job '{share_pruning_job_id}' every {share_pruning_interval_hours} hours.")
        try:
            scheduler_instance.add_job(
                prune_shares_job,
                trigger=IntervalTrigger(
                    hours=share_pruning_interval_hours,
                    jitter=120 # Add 2 min jitter
                ),
                args=[config_obj],
                id=share_pruning_job_id,
                name="Prune Expired Shares",
                replace_existing=True,
                misfire_grace_time=600, # Allow 10 min grace time
                next_run_time=datetime.now(timezone.utc) + timedelta(minutes=10), # Start slightly offset
            )
            log.info(f"Job '{share_pruning_job_id}' added successfully.")
        except ConflictingIdError:
            log.warning(f"Scheduler job '{share_pruning_job_id}' conflict error on add.")
        except Exception as e:
            log.error(f"Failed to add scheduler job '{share_pruning_job_id}': {e}", exc_info=True)

// --------------------
// app\scheduler\__init__.py
# app/scheduler/__init__.py
# This file can be empty
// --------------------
// app\services\apple_data_service.py
# app/services/apple_data_service.py

import logging
from datetime import datetime, timedelta, timezone
from pathlib import Path
import base64
from typing import Optional, Dict, Any, Tuple, List, Set

# FindMy library components
from findmy.reports import (
    AppleAccount,
    LoginState,
    RemoteAnisetteProvider,
)
from findmy import FindMyAccessory, KeyPair

# Import necessary services and utilities
from .user_data_service import UserDataService
from app.utils.helpers import get_available_anisette_server

log = logging.getLogger(__name__)


class AppleDataService:
    """Handles interactions with Apple's Find My service."""

    def __init__(self, config: Dict[str, Any], user_data_service: UserDataService):
        """
        Initializes the service.

        Args:
            config: The Flask app config dictionary.
            user_data_service: An instance of UserDataService.
        """
        self.config = config
        self.uds = user_data_service
        self.history_duration_days = config.get("HISTORY_DURATION_DAYS", 30)

    def perform_account_login(
        self, apple_id: str, apple_password: str
    ) -> Tuple[Optional[AppleAccount], Optional[str]]:
        """
        Logs into an Apple account using provided credentials.

        Args:
            apple_id: The user's Apple ID.
            apple_password: The user's Apple password.

        Returns:
            A tuple containing the logged-in AppleAccount object (or None)
            and an error message string (or None).
        """
        if not apple_id or not apple_password:
            return None, "Apple ID or Password not provided."

        anisette_server_url = get_available_anisette_server(
            self.config.get("ANISETTE_SERVERS", [])
        )
        if not anisette_server_url:
            log.error("Login failed: No Anisette server available.")
            return None, "No Anisette server available."

        try:
            provider = RemoteAnisetteProvider(anisette_server_url)
            account = AppleAccount(provider)
            log.debug(
                f"Attempting login for {apple_id} using Anisette: {anisette_server_url}"
            )
            login_result = account.login(apple_id, apple_password)
            log.info(f"Login attempt result for {apple_id}: {login_result}")

            if login_result == LoginState.LOGGED_IN:
                log.info(
                    f"Successfully logged in Apple account for {apple_id} ({getattr(account, 'first_name', 'N/A')})"
                )
                return account, None
            elif login_result == LoginState.REQUIRE_2FA:
                log.warning(
                    f"Login requires 2FA for {apple_id}. Interactive 2FA not supported."
                )
                try:
                    methods = account.get_2fa_methods()
                except Exception:
                    methods = []
                method_details = [
                    {
                        "type": type(m).__name__,
                        "detail": getattr(
                            m, "phone_number", getattr(m, "device_name", "N/A")
                        ),
                    }
                    for m in methods
                ]
                error_msg = f"Two-Factor Authentication required. Available methods: {method_details}. Interactive 2FA not supported by this app."
                return None, error_msg
            elif login_result == LoginState.LOGGED_OUT:
                error_detail = getattr(
                    account, "login_error_detail", "Invalid Apple ID or Password"
                )
                log.error(f"Authentication failed for {apple_id}: {error_detail}")
                return None, f"Authentication failed: {error_detail}"
            else:
                log.error(
                    f"Login failed for {apple_id} with unexpected state: {login_result}"
                )
                return None, f"Login failed with unexpected state: {login_result}"

        except Exception as e:
            log.exception(
                f"An error occurred during Apple account login attempt for {apple_id}:"
            )
            return None, f"Failed to connect or log in: {e}"

    def _load_private_keys_from_file(self, keys_file_path: Path) -> List[str]:
        """Loads valid base64 private keys from a .keys file."""
        private_keys = []
        KNOWN_IGNORED_PREFIXES = {"advertisement key", "hashed adv key"}
        if not keys_file_path.exists():
            log.error(f"Keys file not found: {keys_file_path}")
            return []
        try:
            with keys_file_path.open("r", encoding="utf-8") as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    parts = line.split(":", 1)
                    if len(parts) == 2:
                        prefix, key_data = parts[0].strip().lower(), parts[1].strip()
                        if prefix == "private key":
                            try:
                                # Basic validation for Base64 format
                                if len(key_data) > 20 and len(key_data) % 4 == 0:
                                    base64.b64decode(key_data, validate=True)
                                    private_keys.append(key_data)
                                else:
                                    log.warning(
                                        f"Skipping potentially invalid private key data in {keys_file_path.name} (Line {line_num})"
                                    )
                            except Exception:
                                log.warning(
                                    f"Skipping invalid base64 data for 'private key' in {keys_file_path.name} (Line {line_num})"
                                )
                        elif prefix not in KNOWN_IGNORED_PREFIXES:
                            log.warning(
                                f"Skipping unrecognized line format (prefix '{prefix}') in {keys_file_path.name} (Line {line_num})"
                            )
        except Exception as e:
            log.error(f"Error reading keys file {keys_file_path}: {e}")

        if not private_keys:
            log.warning(f"No valid 'private key:' lines found in {keys_file_path.name}")
        return private_keys

    def _create_report_dict(self, report: Any) -> Dict[str, Any]:
        """Converts a FindMy report object/dict to a standardized dictionary with UTC timestamps."""

        def make_utc_aware(dt_input):
            if not dt_input:
                return None
            try:
                if isinstance(dt_input, datetime):
                    # If already timezone-aware, convert to UTC. If naive, assume UTC.
                    return (
                        dt_input.astimezone(timezone.utc)
                        if dt_input.tzinfo
                        else dt_input.replace(tzinfo=timezone.utc)
                    )
                elif isinstance(dt_input, str):
                    dt_str = dt_input.replace("Z", "+00:00")  # Handle Z for UTC
                    # Handle potential microseconds (up to 6 digits) before +/- timezone offset
                    if "." in dt_str:
                        parts = dt_str.split(".")
                        # Find timezone offset start (+ or -)
                        offset_char_index = -1
                        if "+" in parts[1]:
                            offset_char_index = parts[1].find("+")
                        elif "-" in parts[1]:
                            offset_char_index = parts[1].find("-")

                        if offset_char_index != -1:
                            micros = parts[1][:offset_char_index][
                                :6
                            ]  # Take up to 6 digits before offset
                            timezone_part = parts[1][offset_char_index:]
                            dt_str = parts[0] + "." + micros + timezone_part
                        else:  # No offset found after microseconds
                            micros = parts[1][:6]
                            dt_str = parts[0] + "." + micros

                    dt = datetime.fromisoformat(dt_str)
                    # If still naive after parsing, assume UTC
                    return (
                        dt.astimezone(timezone.utc)
                        if dt.tzinfo
                        else dt.replace(tzinfo=timezone.utc)
                    )
            except (ValueError, TypeError) as ve:
                log.warning(f"Could not parse/convert timestamp '{dt_input}': {ve}")
            return None

        ts_aware = make_utc_aware(
            getattr(
                report,
                "timestamp",
                report.get("timestamp") if isinstance(report, dict) else None,
            )
        )
        pub_aware = make_utc_aware(
            getattr(
                report,
                "published_at",
                report.get("published_at") if isinstance(report, dict) else None,
            )
        )

        def get_attr_safe(obj, attr, default=None):
            if isinstance(obj, dict):
                return obj.get(attr, default)
            return getattr(obj, attr, default)

        lat = get_attr_safe(report, "latitude", get_attr_safe(report, "lat"))
        lon = get_attr_safe(report, "longitude", get_attr_safe(report, "lon"))
        h_acc = get_attr_safe(
            report, "horizontal_accuracy", get_attr_safe(report, "horizontalAccuracy")
        )
        alt = get_attr_safe(report, "altitude")
        v_acc = get_attr_safe(
            report, "vertical_accuracy", get_attr_safe(report, "verticalAccuracy")
        )
        batt = get_attr_safe(report, "battery")
        status = get_attr_safe(report, "status")
        desc = get_attr_safe(report, "description")
        conf = get_attr_safe(report, "confidence")
        floor = get_attr_safe(report, "floor")

        return {
            "timestamp": ts_aware.isoformat() if ts_aware else None,
            "published_at": pub_aware.isoformat() if pub_aware else None,
            "lat": float(lat) if lat is not None else None,
            "lon": float(lon) if lon is not None else None,
            "horizontalAccuracy": float(h_acc) if h_acc is not None else None,
            "altitude": float(alt) if alt is not None else None,
            "verticalAccuracy": float(v_acc) if v_acc is not None else None,
            "battery": batt,
            "status": status,
            "description": desc,
            "confidence": conf,
            "floor": floor,
        }

    def fetch_accessory_data(
        self, user_id: str, account: AppleAccount
    ) -> Tuple[Optional[Dict[str, Any]], Optional[str], Set[str]]:
        """
        Fetches historical data for all accessories configured for the user.

        Args:
            user_id: The ID of the user.
            account: The logged-in AppleAccount object.

        Returns:
            A tuple containing:
                - A dictionary of processed device data {device_id: {"config": {...}, "reports": [...]}}.
                  The "reports" list contains the FULL history within the duration.
                - An error message string (or None).
                - A set of device IDs for which data was processed (or attempted).
        """
        log.info(f"Starting data fetch for user '{user_id}'...")
        processed_data: Dict[str, Dict[str, Any]] = {}
        error_messages: List[str] = []
        processed_ids: Set[str] = set()

        user_data_dir = self.uds._get_user_data_dir(user_id)
        if not user_data_dir:
            return None, f"Could not access data directory for user '{user_id}'", set()

        # Load fresh device config for this fetch operation
        devices_config = self.uds.load_devices_config(user_id)

        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=self.history_duration_days)
        log.info(
            f"User '{user_id}': Fetching report history from {start_date} to {end_date}"
        )

        default_config_structure = {
            "linked_geofences": [],
            "name": None,
            "label": "❓",
            "color": None,
            "model": "Accessory/Tag",
            "icon": "tag",
        }

        # --- Process .plist files ---
        for plist_file in user_data_dir.glob("*.plist"):
            device_id = plist_file.stem
            if (
                not device_id
                or device_id == Path(self.config["USER_APPLE_CREDS_FILENAME"]).stem
            ):
                continue

            processed_ids.add(device_id)
            config = devices_config.get(
                device_id, {**default_config_structure, "name": device_id}
            )
            # *** Store the FULL list of reports ***
            processed_data[device_id] = {"config": config, "reports": []}

            try:
                log.debug(
                    f"User '{user_id}': Fetching history for plist: {plist_file.name}"
                )
                with plist_file.open("rb") as f:
                    accessory = FindMyAccessory.from_plist(f)
                reports_raw: list[Any] = account.fetch_reports(
                    date_from=start_date, date_to=end_date, keys=accessory
                )
                log.debug(
                    f"User '{user_id}': Found {len(reports_raw)} raw reports for {device_id} (plist)"
                )

                if reports_raw:
                    # Convert, sort, and deduplicate reports
                    processed_reports = [
                        self._create_report_dict(r) for r in reports_raw
                    ]
                    # Deduplicate based on timestamp, keeping the latest occurrence if duplicates exist
                    # This assumes timestamps are precise enough, might need adjustment if not
                    unique_reports_map = {
                        r["timestamp"]: r
                        for r in processed_reports
                        if r.get("timestamp")
                    }
                    # Sort by timestamp (newest first)
                    sorted_reports = sorted(
                        list(unique_reports_map.values()),
                        key=lambda r: r["timestamp"],
                        reverse=True,
                    )
                    # *** Store the FULL sorted list ***
                    processed_data[device_id]["reports"] = sorted_reports
                    log.debug(
                        f"User '{user_id}': Stored {len(sorted_reports)} unique reports for {device_id} (plist)"
                    )

            except Exception as e:
                msg = f"Error fetching history for plist {plist_file.name}: {e}"
                log.exception(f"User '{user_id}': {msg}")
                error_messages.append(msg)
                # Keep the device entry but with empty reports
                processed_data[device_id]["reports"] = []

        # --- Process .keys files ---
        for keys_file in user_data_dir.glob("*.keys"):
            device_id = keys_file.stem
            if (
                not device_id
                or device_id == Path(self.config["USER_APPLE_CREDS_FILENAME"]).stem
                or device_id in processed_ids
            ):
                continue

            processed_ids.add(device_id)
            config = devices_config.get(
                device_id, {**default_config_structure, "name": device_id}
            )
            # *** Store the FULL list of reports ***
            processed_data[device_id] = {"config": config, "reports": []}
            all_key_reports_raw = []

            try:
                log.debug(f"User '{user_id}': Processing keys file: {keys_file.name}")
                private_keys_b64 = self._load_private_keys_from_file(keys_file)
                if not private_keys_b64:
                    log.warning(
                        f"User '{user_id}': No valid private keys found in {keys_file.name}, skipping fetch."
                    )
                    continue

                for key_b64 in private_keys_b64:
                    try:
                        key_pair = KeyPair.from_b64(key_b64)
                        reports_for_key: list[Any] = account.fetch_reports(
                            date_from=start_date, date_to=end_date, keys=key_pair
                        )
                        if reports_for_key:
                            all_key_reports_raw.extend(reports_for_key)
                    except Exception as key_err:
                        log.error(
                            f"User '{user_id}': Error fetching history for key {key_b64[:10]}... from {keys_file.name}: {key_err}"
                        )

                log.debug(
                    f"User '{user_id}': Found total {len(all_key_reports_raw)} raw reports for {device_id} (keys)"
                )

                if all_key_reports_raw:
                    # Convert, sort, and deduplicate reports
                    processed_reports = [
                        self._create_report_dict(r) for r in all_key_reports_raw
                    ]
                    unique_reports_map = {
                        r["timestamp"]: r
                        for r in processed_reports
                        if r.get("timestamp")
                    }
                    sorted_reports = sorted(
                        list(unique_reports_map.values()),
                        key=lambda r: r["timestamp"],
                        reverse=True,
                    )
                    # *** Store the FULL sorted list ***
                    processed_data[device_id]["reports"] = sorted_reports
                    log.debug(
                        f"User '{user_id}': Stored {len(sorted_reports)} unique reports for {device_id} (keys)"
                    )

            except Exception as e:
                msg = f"Error processing keys file {keys_file.name}: {e}"
                log.exception(f"User '{user_id}': {msg}")
                error_messages.append(msg)
                # Keep the device entry but with empty reports
                processed_data[device_id]["reports"] = []

        # --- Add devices from config that had no data files ---
        all_config_ids = set(devices_config.keys())
        missing_data_ids = all_config_ids - processed_ids
        for device_id in missing_data_ids:
            if device_id not in processed_data:
                log.warning(
                    f"User '{user_id}': Device '{device_id}' found in config but no data file found. Adding with empty reports."
                )
                processed_data[device_id] = {
                    "config": devices_config[device_id],
                    "reports": [],  # Ensure reports key exists
                }
                processed_ids.add(device_id)

        combined_error_msg = "; ".join(error_messages) if error_messages else None
        log.info(
            f"Finished data fetch for user '{user_id}'. Processed {len(processed_ids)} devices. Errors: {combined_error_msg or 'None'}"
        )

        return processed_data, combined_error_msg, processed_ids

// --------------------
// app\services\notification_service.py
# app/services/notification_service.py
import logging
import time
import json
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, Tuple, List, Set
from urllib.parse import quote  # Import quote
import uuid  # Add import
from pywebpush import webpush, WebPushException
from flask import url_for, current_app  # Keep Flask context helpers

from .user_data_service import UserDataService
from app.utils.helpers import (
    haversine,
    getDefaultColorForId,
)
from app.utils.data_formatting import _parse_battery_info

log = logging.getLogger(__name__)


class NotificationService:
    """Handles notification logic (geofence, battery) and sending web push notifications."""

    def __init__(self, config: Dict[str, Any], user_data_service: UserDataService):
        """
        Initializes the service.

        Args:
            config: The Flask app config dictionary.
            user_data_service: An instance of UserDataService.
        """
        self.config = config
        self.uds = user_data_service
        self.vapid_enabled = config.get("VAPID_ENABLED", False)
        self.vapid_public_key_str = config.get("VAPID_PUBLIC_KEY")
        self.vapid_private_key_str = config.get("VAPID_PRIVATE_KEY")
        self.vapid_claims_email_config = config.get("VAPID_CLAIMS_EMAIL")

        self.low_battery_threshold = config.get("LOW_BATTERY_THRESHOLD", 15)
        self.notification_cooldown = config.get("NOTIFICATION_COOLDOWN_SECONDS", 300)

        # Store relative paths for generating URLs later
        self.default_icon_path = config.get(
            "DEFAULT_NOTIFICATION_ICON_PATH", "icons/favicon.svg"
        )
        self.welcome_icon_path = config.get(
            "WELCOME_NOTIFICATION_ICON_PATH", self.default_icon_path
        )  # Used for Icon & Badge
        self.geofence_badge_path = config.get(
            "GEOFENCE_NOTIFICATION_ICON_PATH", self.default_icon_path
        )  # Path used for geofence BADGE
        self.battery_badge_path = config.get(
            "BATTERY_NOTIFICATION_ICON_PATH", self.default_icon_path
        )  # Path used for battery BADGE
        self.test_icon_badge_path = config.get(
            "TEST_NOTIFICATION_ICON_PATH", self.default_icon_path
        )  # Path used for test ICON and BADGE
        # Default badge if type unknown or for device icons
        self.default_badge_path = config.get(
            "DEFAULT_NOTIFICATION_BADGE_PATH", "icons/badge-icon.png"
        )

        # VAPID Initialization Check
        if not (self.vapid_private_key_str and self.vapid_claims_email_config):
            if self.vapid_enabled:
                log.warning(
                    "VAPID Private Key or Claims Email missing in config. Disabling push notifications."
                )
            self.vapid_enabled = False
        elif not self.vapid_enabled:
            log.info("VAPID push notifications explicitly disabled in config.")
        else:
            log.info("VAPID push notifications configured and enabled.")

    # --- Notification Cooldown ---
    def _can_send_notification(
        self, user_id: str, device_id: str, event_key: str
    ) -> bool:
        if not user_id:
            return False
        try:
            last_notification_times = self.uds.load_notification_times(user_id)
            last_time = last_notification_times.get((device_id, event_key))
            now = time.time()
            if last_time and (now - last_time < self.notification_cooldown):
                remaining = self.notification_cooldown - (now - last_time)
                log.info(
                    f"User '{user_id}': Cooldown active for {device_id}/{event_key}. {remaining:.0f}s remaining."
                )
                return False
            log.debug(
                f"User '{user_id}': Cooldown check passed for {device_id}/{event_key}."
            )
            return True
        except Exception as e:
            log.error(
                f"User '{user_id}': Error checking notification cooldown for {device_id}/{event_key}: {e}"
            )
            return False  # Fail safe - don't spam

    def _record_notification_sent(self, user_id: str, device_id: str, event_key: str):
        if not user_id:
            return
        try:
            last_notification_times = self.uds.load_notification_times(user_id)
            now = time.time()
            last_notification_times[(device_id, event_key)] = now
            self.uds.save_notification_times(user_id, last_notification_times)
            log.info(
                f"User '{user_id}': Recorded notification time for {device_id}/{event_key} at {now:.0f}"
            )
        except Exception as e:
            log.error(
                f"User '{user_id}': Error recording notification time for {device_id}/{event_key}: {e}"
            )

    # --- Notification Checks (Geofence & Battery) ---
    def check_device_notifications(
        self,
        user_id: str,
        device_id: str,
        latest_report: Optional[Dict],
        device_config: Dict,
    ):
        if not latest_report:
            log.debug(
                f"User '{user_id}', Device '{device_id}': Skipping notification checks, no latest report."
            )
            return
        try:
            all_user_geofences = self.uds.load_geofences_config(user_id)
            current_geofence_state = self.uds.load_geofence_state(user_id)
            current_battery_state = self.uds.load_battery_state(user_id)
        except Exception as e:
            log.error(
                f"User '{user_id}', Device '{device_id}': Failed to load state/config for notification checks: {e}"
            )
            return

        geofence_state_changed = False
        try:
            updated_geofence_state, gf_changed = self._check_geofences_for_device(
                user_id,
                device_id,
                latest_report,
                device_config,
                all_user_geofences,
                current_geofence_state,
            )
            if gf_changed:
                geofence_state_changed = True
                current_geofence_state = updated_geofence_state
        except Exception as e:
            log.exception(
                f"User '{user_id}', Device '{device_id}': Error during geofence check: {e}"
            )

        battery_state_changed = False
        try:
            updated_battery_state, bat_changed = self._check_low_battery_for_device(
                user_id, device_id, latest_report, device_config, current_battery_state
            )
            if bat_changed:
                battery_state_changed = True
                current_battery_state = updated_battery_state
        except Exception as e:
            log.exception(
                f"User '{user_id}', Device '{device_id}': Error during battery check: {e}"
            )

        try:
            if geofence_state_changed:
                self.uds.save_geofence_state(user_id, current_geofence_state)
            if battery_state_changed:
                self.uds.save_battery_state(user_id, current_battery_state)
        except Exception as e:
            log.error(
                f"User '{user_id}', Device '{device_id}': Failed to save updated state after checks: {e}"
            )

    def _check_geofences_for_device(
        self,
        user_id: str,
        device_id: str,
        latest_report: Dict,
        device_config: Dict,
        all_user_geofences: Dict,
        current_geofence_state: Dict,
    ) -> Tuple[Dict, bool]:
        state_changed = False
        lat = latest_report.get("lat")
        lon = latest_report.get("lon")
        if lat is None or lon is None:
            return current_geofence_state, False

        device_name = device_config.get("name", device_id)
        device_label = device_config.get("label", "❓")
        device_color = device_config.get("color", getDefaultColorForId(device_id))
        linked_geofences_info = device_config.get("linked_geofences", [])

        if not linked_geofences_info:
            return current_geofence_state, False

        for link_info in linked_geofences_info:
            gf_id = link_info.get("id")
            if not gf_id or gf_id not in all_user_geofences:
                continue

            gf_def = all_user_geofences[gf_id]
            gf_name = gf_def["name"]
            notify_entry = link_info.get("notify_entry", False)
            notify_exit = link_info.get("notify_exit", False)

            if not notify_entry and not notify_exit:
                continue

            try:
                distance = haversine(lat, lon, gf_def["lat"], gf_def["lng"])
                is_inside = distance <= gf_def["radius"]
                current_status_str = "inside" if is_inside else "outside"
                state_key = (device_id, gf_id)
                previous_status_str = current_geofence_state.get(state_key, "unknown")

                if previous_status_str != current_status_str:
                    log.info(
                        f"User '{user_id}': Geofence State Change: {device_id} @ '{gf_name}' ({gf_id}): {previous_status_str} -> {current_status_str}"
                    )
                    current_geofence_state[state_key] = current_status_str
                    state_changed = True

                    notification_title = None
                    notification_body = None
                    notification_tag = None
                    event_type_key = None
                    notification_data_payload = None
                    should_notify = False

                    base_payload = {
                        "type": "geofence",
                        "deviceId": device_id,
                        "geofenceId": gf_id,
                        "geofenceName": gf_name,
                        "lat": lat,
                        "lng": lon,
                    }

                    if is_inside and notify_entry:
                        event_type_key = f"geofence_{gf_id}_entry"
                        if self._can_send_notification(
                            user_id, device_id, event_type_key
                        ):
                            notification_title = f"{device_name} Entered {gf_name}"
                            notification_body = f"{device_name} entered '{gf_name}' area. ({distance:.0f}m from center)"
                            notification_tag = f"geofence-{device_id}-{gf_id}-entry-{int(time.time() / 60)}"
                            notification_data_payload = {
                                **base_payload,
                                "eventType": "entry",
                            }
                            should_notify = True
                        else:
                            log.info(
                                f"User '{user_id}': Geofence Entry notification for {device_id} @ {gf_name} skipped due to cooldown."
                            )

                    elif not is_inside and notify_exit:
                        event_type_key = f"geofence_{gf_id}_exit"
                        if self._can_send_notification(
                            user_id, device_id, event_type_key
                        ):
                            notification_title = f"{device_name} Exited {gf_name}"
                            notification_body = f"{device_name} left '{gf_name}' area. ({distance:.0f}m from center)"
                            notification_tag = f"geofence-{device_id}-{gf_id}-exit-{int(time.time() / 60)}"
                            notification_data_payload = {
                                **base_payload,
                                "eventType": "exit",
                            }
                            should_notify = True
                        else:
                            log.info(
                                f"User '{user_id}': Geofence Exit notification for {device_id} @ {gf_name} skipped due to cooldown."
                            )

                    if should_notify and event_type_key and notification_title:
                        log.info(
                            f"User '{user_id}': Triggering geofence notification for {event_type_key}"
                        )
                        self.send_user_notifications(
                            user_id=user_id,
                            title=notification_title,
                            body=notification_body,
                            tag=notification_tag,
                            data_payload=notification_data_payload,
                            device_label=device_label,  # Pass label for icon generation
                            device_color=device_color,  # Pass color for icon generation
                            notification_type="geofence",  # Pass type to select correct badge
                        )
                        self._record_notification_sent(
                            user_id, device_id, event_type_key
                        )

                elif previous_status_str == "unknown":
                    # Record initial state without notification
                    current_geofence_state[state_key] = current_status_str
                    state_changed = True

            except Exception as e:
                log.exception(
                    f"User '{user_id}': Error checking geofence '{gf_name}' ({gf_id}) for {device_id}: {e}"
                )

        return current_geofence_state, state_changed

    def _check_low_battery_for_device(
        self,
        user_id: str,
        device_id: str,
        latest_report: Dict,
        device_config: Dict,
        current_battery_state: Dict,
    ) -> Tuple[Dict, bool]:
        state_changed = False
        mapped_battery_level, battery_status_str = _parse_battery_info(
            latest_report.get("battery"),
            latest_report.get("status"),
            self.low_battery_threshold,
        )

        if mapped_battery_level is None:
            log.debug(
                f"User '{user_id}', Device '{device_id}': No usable battery level found for notification check."
            )
            return current_battery_state, False

        device_name = device_config.get("name", device_id)
        device_label = device_config.get("label", "❓")
        device_color = device_config.get("color", getDefaultColorForId(device_id))
        event_type_key = "battery_low"
        current_logical_status = (
            "low" if mapped_battery_level < self.low_battery_threshold else "normal"
        )
        previous_logical_status = current_battery_state.get(device_id, "unknown")

        if previous_logical_status != current_logical_status:
            log.info(
                f"User '{user_id}': Battery State Change: {device_id} ('{device_name}'): {previous_logical_status} -> {current_logical_status} (Level: {mapped_battery_level:.0f}%)"
            )
            current_battery_state[device_id] = current_logical_status
            state_changed = True

            if current_logical_status == "low":
                if self._can_send_notification(user_id, device_id, event_type_key):
                    title = f"{device_name} Battery Low"
                    lat = latest_report.get("lat")
                    lon = latest_report.get("lon")
                    loc_info = (
                        f"Last @ {lat:.4f}, {lon:.4f}"
                        if lat and lon
                        else "Last location unknown."
                    )
                    body = f"{device_name}'s battery is low ({mapped_battery_level:.0f}%). {loc_info}"
                    tag = f"battery-{device_id}-low-{int(time.time() / 3600)}"
                    data_payload = {
                        "type": "battery",
                        "deviceId": device_id,
                        "level": mapped_battery_level,
                        "lat": lat,
                        "lng": lon,
                    }
                    log.info(
                        f"User '{user_id}': Triggering low battery notification for {device_id}"
                    )
                    self.send_user_notifications(
                        user_id=user_id,
                        title=title,
                        body=body,
                        tag=tag,
                        data_payload=data_payload,
                        device_label=device_label,  # Pass label for icon generation
                        device_color=device_color,  # Pass color for icon generation
                        notification_type="battery",  # Pass type to select correct badge
                    )
                    self._record_notification_sent(user_id, device_id, event_type_key)
                else:
                    log.info(
                        f"User '{user_id}': Low Battery notification for {device_id} skipped due to cooldown."
                    )
            else:
                log.info(
                    f"User '{user_id}': Battery level for {device_id} is now normal ({mapped_battery_level}%)."
                )

        elif previous_logical_status == "unknown":
            # Record initial state without notification
            current_battery_state[device_id] = current_logical_status
            state_changed = True
            log.debug(
                f"User '{user_id}': Initial battery state recorded for {device_id} as '{current_logical_status}'."
            )

        return current_battery_state, state_changed

    # --- VAPID Claims Helper ---
    def _get_vapid_claims(self, user_id: str) -> Optional[Dict[str, str]]:
        user_email = None
        try:
            user_data = self.uds.load_single_user(user_id)
            if user_data and user_data.get("email") and user_data.get("email").strip():
                user_email = user_data.get("email").strip()
                log.debug(f"Using email from user data for VAPID claims: {user_email}")
            else:
                log.debug(
                    f"No valid email found in user data for {user_id}. Falling back to config email."
                )
        except Exception as e:
            log.error(
                f"Error fetching user data for VAPID email for user '{user_id}': {e}"
            )

        if not user_email:
            user_email = self.vapid_claims_email_config
            log.debug(f"Using VAPID_CLAIMS_EMAIL from config: {user_email}")

        if not user_email or not isinstance(user_email, str) or not user_email.strip():
            log.error(
                f"Cannot generate VAPID claims for user '{user_id}', no valid 'sub' email found. Ensure VAPID_CLAIMS_EMAIL is set."
            )
            return None

        final_email_claim = (
            user_email if user_email.startswith("mailto:") else f"mailto:{user_email}"
        )
        if final_email_claim == "mailto:":
            log.error(
                f"Cannot generate VAPID claims for user '{user_id}', final email claim is empty."
            )
            return None

        claims = {"sub": final_email_claim}
        log.debug(f"Generated VAPID claims for {user_id}: {claims}")
        return claims

    def _get_static_url(self, static_path: str) -> str:
        """Generates a URL for a static file. Uses url_for if context is available, otherwise relative path."""
        try:
            current_app.config  # Check if context exists
            return url_for("static", filename=static_path, _external=False)
        except RuntimeError:
            log.debug(
                f"No app context for url_for, generating relative path: /static/{static_path}"
            )
            return f"/static/{static_path}"  # Ensure leading slash

    def _save_notification_to_history(
        self, user_id: str, title: str, body: str, data_payload: Optional[Dict] = None
    ):
        """Saves a sent notification to the user's history file."""
        if not user_id:
            return
        try:
            notification_id = str(uuid.uuid4())
            timestamp_iso = datetime.now(timezone.utc).isoformat()
            entry = {
                "id": notification_id,
                "timestamp": timestamp_iso,
                "title": title,
                "body": body,
                "data": data_payload or {},
                "is_read": False,
            }
            self.uds.save_notification_history(user_id, entry)
            log.info(
                f"Saved notification {notification_id} to history for user '{user_id}'."
            )
        except Exception as e:
            log.error(
                f"Failed to save notification to history for user '{user_id}': {e}"
            )

    # --- Web Push Sending ---
    def send_user_notifications(
        self,
        user_id: str,
        title: str,
        body: str,
        tag: Optional[str] = None,
        data_payload: Optional[Dict] = None,
        device_label: Optional[str] = None,
        device_color: Optional[str] = None,
        notification_type: Optional[str] = None,
    ):
        # --- Save to history BEFORE sending ---
        self._save_notification_to_history(user_id, title, body, data_payload)

        if not self.vapid_enabled or not self.vapid_private_key_str:
            log.warning(
                f"User '{user_id}': VAPID disabled or key missing. Skipping push: {title}"
            )
            return
        if not user_id:
            log.error("send_user_notifications called without user_id.")
            return

        vapid_claims = self._get_vapid_claims(user_id)
        if not vapid_claims:
            log.error(f"User '{user_id}': Failed to get VAPID claims.")
            return

        try:
            user_subscriptions = self.uds.load_subscriptions(user_id)
        except Exception as e:
            log.error(f"User '{user_id}': Failed to load subscriptions: {e}")
            return
        if not user_subscriptions:
            log.info(f"User '{user_id}': No push subscriptions found.")
            return

        # --- Determine Icon and Badge URLs based on type ---
        icon_url = ""
        badge_url = ""

        if notification_type == "geofence":
            badge_url = self._get_static_url(self.geofence_badge_path)
            if device_label and device_color:
                # Dynamic device icon
                encoded_label = quote(device_label)
                encoded_color = quote(device_color.lstrip("#"))
                icon_url = f"/api/utils/generate_icon?label={encoded_label}&color=%23{encoded_color}"
            else:
                icon_url = self._get_static_url(self.default_icon_path)
                log.warning(
                    f"Geofence notification for {user_id} missing device label/color, using default icon."
                )

        elif notification_type == "battery":
            badge_url = self._get_static_url(self.battery_badge_path)
            if device_label and device_color:
                # Dynamic device icon
                encoded_label = quote(device_label)
                encoded_color = quote(device_color.lstrip("#"))
                icon_url = f"/api/utils/generate_icon?label={encoded_label}&color=%23{encoded_color}"
            else:
                icon_url = self._get_static_url(self.default_icon_path)
                log.warning(
                    f"Battery notification for {user_id} missing device label/color, using default icon."
                )

        elif notification_type == "welcome":
            # Use same PNG for icon and badge
            icon_url = self._get_static_url(self.welcome_icon_path)
            badge_url = icon_url  # Use the same path

        elif notification_type == "test":
            # Use same PNG for icon and badge
            icon_url = self._get_static_url(self.test_icon_badge_path)
            badge_url = icon_url  # Use the same path

        else:  # Fallback / Unknown type
            icon_url = self._get_static_url(self.default_icon_path)
            badge_url = self._get_static_url(self.default_badge_path)

        log.debug(
            f"Selected Notification URLs - Type: {notification_type}, Icon: {icon_url}, Badge: {badge_url}"
        )
        # --- ----------------------------- ---

        data_payload = data_payload or {}
        unique_tag = tag or f"notification-{int(time.time())}"
        payload = {
            "notification": {
                "title": title,
                "body": body,
                "icon": icon_url,
                "badge": badge_url,
                "tag": unique_tag,
                "renotify": False,
                "requireInteraction": False,
                "data": data_payload,
            }
        }
        payload["notification"].update(data_payload.get("notification_options", {}))

        try:
            payload_json = json.dumps(payload)
        except Exception as json_err:
            log.error(f"User '{user_id}': Failed to serialize payload: {json_err}.")
            return

        log.info(
            f"User '{user_id}': Sending push (Tag: {unique_tag}, Type: {notification_type or 'general'}) to {len(user_subscriptions)} subscribers."
        )

        # --- Sending Loop & Error Handling ---
        failed_endpoints = []
        success_count = 0
        current_subs_items = list(user_subscriptions.items())  # Iterate over a copy

        for endpoint, sub_info in current_subs_items:
            try:
                webpush(
                    subscription_info=sub_info,
                    data=payload_json,
                    vapid_private_key=self.vapid_private_key_str,
                    vapid_claims=vapid_claims,
                )
                log.debug(f"User '{user_id}': Sent notification to {endpoint[:50]}...")
                success_count += 1
            except WebPushException as ex:
                status_code = ex.response.status_code if ex.response else "N/A"
                log.error(
                    f"User '{user_id}': WebPush Delivery Error for {endpoint[:50]}... Status: {status_code}, Type: {type(ex).__name__}, Message: {ex}"
                )
                # Check status codes or error messages indicating expired/invalid subscription
                if ex.response and status_code in [400, 404, 410, 403]:
                    log.warning(
                        f"User '{user_id}': Sub {endpoint[:50]}... invalid/expired (status {status_code}). Removing."
                    )
                    failed_endpoints.append(endpoint)
                elif (
                    "unsubscribe" in str(ex).lower()
                    or "expired" in str(ex).lower()
                    or "InvalidToken" in str(ex)
                    or "push service error" in str(ex).lower()
                    or "invalid registration" in str(ex).lower()
                ):
                    log.warning(
                        f"User '{user_id}': Sub {endpoint[:50]}... likely invalid/expired (text). Removing."
                    )
                    failed_endpoints.append(endpoint)
            except Exception as e:
                log.exception(
                    f"User '{user_id}': Unexpected error sending to {endpoint[:50]}...: {e}"
                )

        log.info(
            f"User '{user_id}': Push complete. Success: {success_count}/{len(current_subs_items)}. Failures removed: {len(failed_endpoints)}."
        )
        if failed_endpoints:
            self._remove_failed_subscriptions(user_id, failed_endpoints)

    def send_single_notification(
        self,
        user_id: str,
        subscription_info: Dict,
        title: str,
        body: str,
        tag: Optional[str] = None,
        data_payload: Optional[Dict] = None,
        notification_type: Optional[str] = None,
    ):
        # --- Save to history BEFORE sending ---
        self._save_notification_to_history(user_id, title, body, data_payload)

        if not self.vapid_enabled or not self.vapid_private_key_str:
            log.warning(
                f"User '{user_id}': VAPID disabled/key missing. Skip single: {title}"
            )
            return
        if not user_id or not subscription_info:
            log.error("send_single_notification missing user_id or subscription_info.")
            return
        vapid_claims = self._get_vapid_claims(user_id)
        if not vapid_claims:
            log.error(f"User '{user_id}': Failed to get VAPID claims.")
            return

        # --- Determine Icon and Badge URL ---
        icon_url = ""
        badge_url = ""

        if notification_type == "welcome":
            icon_url = self._get_static_url(self.welcome_icon_path)
            badge_url = icon_url  # Use same for badge
        elif notification_type == "test":
            icon_url = self._get_static_url(self.test_icon_badge_path)
            badge_url = icon_url  # Use same for badge
        else:  # Default/fallback
            icon_url = self._get_static_url(self.default_icon_path)
            badge_url = self._get_static_url(self.default_badge_path)

        log.debug(
            f"Selected Single Notification URLs - Type: {notification_type}, Icon: {icon_url}, Badge: {badge_url}"
        )
        # --- ---------------------------- ---

        unique_tag = tag or f"single-notification-{int(time.time())}"
        payload = {
            "notification": {
                "title": title,
                "body": body,
                "icon": icon_url,
                "badge": badge_url,
                "tag": unique_tag,
                "data": data_payload or {},
            }
        }
        payload["notification"].update(data_payload.get("notification_options", {}))

        endpoint = subscription_info.get("endpoint", "N/A")
        try:
            payload_json = json.dumps(payload)
            webpush(
                subscription_info=subscription_info,
                data=payload_json,
                vapid_private_key=self.vapid_private_key_str,
                vapid_claims=vapid_claims,
            )
            log.info(
                f"User '{user_id}': Sent single notification '{title}' (Type: {notification_type}) to {endpoint[:50]}..."
            )
        except WebPushException as ex:
            status_code = ex.response.status_code if ex.response else "N/A"
            log.error(
                f"User '{user_id}': WebPush Error sending single to {endpoint[:50]}... Status: {status_code}, Type: {type(ex).__name__}, Msg: {ex}"
            )
            # Keep existing removal logic
            if ex.response and status_code in [400, 404, 410, 403]:
                self._remove_failed_subscription(user_id, endpoint)
            elif (
                "unsubscribe" in str(ex).lower()
                or "expired" in str(ex).lower()
                or "InvalidToken" in str(ex)
                or "push service error" in str(ex).lower()
                or "invalid registration" in str(ex).lower()
            ):
                log.warning(
                    f"User '{user_id}': Sub {endpoint[:50]}... likely invalid (text) during single send. Removing."
                )
                self._remove_failed_subscription(user_id, endpoint)
        except Exception as e:
            log.exception(
                f"User '{user_id}': Unexpected error sending single notification: {e}"
            )

    # --- Other Methods ---
    def _remove_failed_subscriptions(self, user_id: str, endpoints: List[str]):
        if not endpoints:
            return
        log.warning(
            f"User '{user_id}': Removing {len(endpoints)} failed subscriptions."
        )
        try:
            current_subs = self.uds.load_subscriptions(user_id)
            updated_subs = {
                ep: si for ep, si in current_subs.items() if ep not in endpoints
            }
            if len(updated_subs) < len(current_subs):
                self.uds.save_subscriptions(user_id, updated_subs)
                log.info(
                    f"User '{user_id}': Saved after removing {len(current_subs) - len(updated_subs)} subscriptions."
                )
            else:
                log.debug(f"User '{user_id}': No subscriptions needed removal.")
        except Exception as e:
            log.error(f"User '{user_id}': Failed to remove failed subscriptions: {e}")

    def _remove_failed_subscription(self, user_id: str, endpoint: Optional[str]):
        if endpoint:
            self._remove_failed_subscriptions(user_id, [endpoint])

    def send_welcome_notification(self, user_id: str, subscription_info: Dict):
        log.info(f"User '{user_id}': Sending welcome notification...")
        self.send_single_notification(
            user_id=user_id,
            subscription_info=subscription_info,
            title="Notifications Enabled",
            body=f"Find My alerts enabled for user '{user_id}'.",
            tag="welcome-notification",
            data_payload={"type": "welcome"},
            notification_type="welcome",  # Specify type
        )

    def is_valid_subscription(self, subscription_data: Any) -> bool:
        return (
            isinstance(subscription_data, dict)
            and isinstance(subscription_data.get("endpoint"), str)
            and subscription_data["endpoint"].startswith("https://")
            and isinstance(subscription_data.get("keys"), dict)
            and isinstance(subscription_data["keys"].get("p256dh"), str)
            and isinstance(subscription_data["keys"].get("auth"), str)
        )

    # --- Cleanup methods remain the same ---
    def cleanup_stale_geofence_states_for_geofence(
        self, user_id: str, geofence_id: str
    ):
        log.info(
            f"User '{user_id}': Cleaning up geofence state for deleted geofence ID '{geofence_id}'."
        )
        try:
            current_gf_state = self.uds.load_geofence_state(user_id)
            keys_to_remove = [
                k
                for k in current_gf_state
                if isinstance(k, tuple) and len(k) == 2 and k[1] == geofence_id
            ]
            if keys_to_remove:
                log.info(
                    f"User '{user_id}': Removing {len(keys_to_remove)} state entries for deleted geofence '{geofence_id}'."
                )
                updated_state = {
                    k: v for k, v in current_gf_state.items() if k not in keys_to_remove
                }
                self.uds.save_geofence_state(user_id, updated_state)
            else:
                log.debug(
                    f"User '{user_id}': No geofence state entries found for deleted geofence '{geofence_id}'."
                )
        except Exception as e:
            log.error(
                f"User '{user_id}': Error cleaning up geofence state for geofence '{geofence_id}': {e}"
            )

    def cleanup_stale_notification_times_for_geofence(
        self, user_id: str, geofence_id: str
    ):
        log.info(
            f"User '{user_id}': Cleaning up notification times for deleted geofence ID '{geofence_id}'."
        )
        try:
            current_notify_times = self.uds.load_notification_times(user_id)
            prefix = f"geofence_{geofence_id}_"
            keys_to_remove = [
                k
                for k in current_notify_times
                if isinstance(k, tuple) and len(k) == 2 and k[1].startswith(prefix)
            ]
            if keys_to_remove:
                log.info(
                    f"User '{user_id}': Removing {len(keys_to_remove)} notification time entries for deleted geofence '{geofence_id}'."
                )
                updated_state = {
                    k: v
                    for k, v in current_notify_times.items()
                    if k not in keys_to_remove
                }
                self.uds.save_notification_times(user_id, updated_state)
            else:
                log.debug(
                    f"User '{user_id}': No notification time entries found for deleted geofence '{geofence_id}'."
                )
        except Exception as e:
            log.error(
                f"User '{user_id}': Error cleaning up notification times for geofence '{geofence_id}': {e}"
            )

// --------------------
// app\services\user_data_service.py
# app/services/user_data_service.py
import os
import json
import logging
import threading
import shutil
from pathlib import Path
from typing import Optional, Dict, Any, Tuple, Set, List
from datetime import datetime, timezone, timedelta
from werkzeug.security import generate_password_hash
import uuid


from app.utils.json_utils import load_json_file, save_json_atomic
from app.utils.helpers import (
    encrypt_password,
    decrypt_password,
    getDefaultColorForId,
    generate_device_icon_svg,
    DEFAULT_SOURCE_COLOR,  # Import the default color constant
)

log = logging.getLogger(__name__)


class UserDataService:
    """
    Handles loading and saving of user-specific data files (JSON).
    Encapsulates file paths, locking, and basic validation.
    """

    def __init__(self, config: Dict[str, Any]):
        """
        Initializes the service with application configuration.

        Args:
            config: The Flask app config dictionary.
        """
        self.config = config
        self.data_dir = Path(config["DATA_DIRECTORY"])
        self.users_file = Path(config["USERS_FILE"])
        self.file_locks = config["FILE_LOCKS"]  # Use locks from config

        # Ensure base data directory exists
        self.data_dir.mkdir(parents=True, exist_ok=True)
        log.debug(f"UserDataService initialized. Data directory: {self.data_dir}")

    # --- Path Helpers ---

    def _get_user_data_dir(self, user_id: str) -> Optional[Path]:
        """Gets the Path object for a user's data directory, creating it if needed."""
        if (
            not user_id
            or not isinstance(user_id, str)
            or "/" in user_id
            or ".." in user_id  # Prevent path traversal
            or user_id.startswith(".")
        ):
            log.error(f"Attempted to get data dir for invalid user ID: '{user_id}'")
            return None  # Indicate failure

        user_dir = self.data_dir / user_id
        try:
            user_dir.mkdir(parents=True, exist_ok=True)
            return user_dir
        except OSError as e:
            log.error(f"Failed to create user data directory {user_dir}: {e}")
            return None

    def _get_user_file_path(self, user_id: str, filename: str) -> Optional[Path]:
        """Constructs the full path to a user-specific file."""
        user_dir = self._get_user_data_dir(user_id)
        if not user_dir:
            return None  # Failed to get/create user directory

        # Basic check on filename
        if "/" in filename or filename.startswith("."):
            log.error(
                f"Attempted to get file path for invalid filename: '{filename}' for user '{user_id}'"
            )
            return None

        return user_dir / filename

    # --- Global User Management (users.json) ---

    def load_users(self) -> Dict[str, Dict[str, Any]]:
        """Loads the main user database (users.json)."""
        users_lock = self.file_locks.get("users")
        if not users_lock:
            log.error("Lock for 'users.json' not found in configuration.")
            return {}

        users_data = load_json_file(self.users_file, users_lock)

        if users_data is None:
            return {}
        elif not isinstance(users_data, dict):
            log.error(
                f"{self.users_file.name} has invalid format (not a dictionary). Returning empty."
            )
            return {}

        log.info(f"Loaded {len(users_data)} users from {self.users_file.name}")
        return users_data

    def save_users(self, users_data: Dict[str, Dict[str, Any]]):
        """Saves the main user database (users.json)."""
        users_lock = self.file_locks.get("users")
        if not users_lock:
            log.error("Lock for 'users.json' not found in configuration. Cannot save.")
            raise RuntimeError("User lock configuration missing.")
        if not isinstance(users_data, dict):
            log.error(
                f"Attempted to save non-dictionary data to {self.users_file.name}. Aborting save."
            )
            raise TypeError("users_data must be a dictionary.")
        try:
            save_json_atomic(self.users_file, users_data, users_lock, indent=4)
            log.info(f"Saved {len(users_data)} users to {self.users_file.name}")
        except Exception as e:
            log.error(f"Failed to save users data: {e}")
            raise

    def load_single_user(self, user_id: str) -> Optional[Dict[str, Any]]:
        """Loads data for a single user from users.json."""
        all_users = self.load_users()
        return all_users.get(user_id)

    # --- NEW: User Preferences ---
    def load_user_preferences(self, user_id: str) -> Dict[str, str]:
        """Loads theme preferences for a user, returning defaults if not found."""
        user_data = self.load_single_user(user_id)
        default_prefs = {
            "theme_mode": "system",
            "theme_color": DEFAULT_SOURCE_COLOR,  # Use default from helpers
        }
        if not user_data:
            return default_prefs

        # Return saved prefs or defaults if specific keys are missing
        return {
            "theme_mode": user_data.get("theme_mode", default_prefs["theme_mode"]),
            "theme_color": user_data.get("theme_color", default_prefs["theme_color"]),
        }

    def save_user_preferences(self, user_id: str, theme_mode: str, theme_color: str):
        """Saves theme preferences for a user into users.json."""
        if not user_id:
            log.error("Cannot save preferences for empty user ID.")
            raise ValueError("User ID cannot be empty.")

        # --- START: Validation (outside lock) ---
        valid_modes = ["system", "light", "dark"]
        if theme_mode not in valid_modes:
            log.warning(
                f"Invalid theme mode '{theme_mode}' for user '{user_id}'. Using 'system'."
            )
            theme_mode = "system"
        if not theme_color or not theme_color.startswith("#") or len(theme_color) != 7:
            log.warning(
                f"Invalid theme color '{theme_color}' for user '{user_id}'. Using default."
            )
            theme_color = DEFAULT_SOURCE_COLOR
        # --- END: Validation ---

        users_lock = self.file_locks.get("users")
        if not users_lock:
            log.error("Lock for 'users.json' not found. Cannot save preferences.")
            raise RuntimeError("User lock configuration missing.")

        # --- START: Modified Lock Handling ---
        MAX_RETRIES = 3
        RETRY_DELAY = 0.1  # seconds
        for attempt in range(MAX_RETRIES):
            # 1. Load data *without* holding the lock for modification
            #    (load_users handles its own locking for the read)
            all_users = self.load_users()  # Read the latest data

            if user_id not in all_users:
                log.error(
                    f"User '{user_id}' not found in users.json during save attempt {attempt + 1}. Cannot save preferences."
                )
                raise ValueError(f"User '{user_id}' not found.")

            # 2. Modify the data in memory
            original_mode = all_users[user_id].get("theme_mode")
            original_color = all_users[user_id].get("theme_color")
            all_users[user_id]["theme_mode"] = theme_mode
            all_users[user_id]["theme_color"] = theme_color

            # 3. Acquire lock ONLY for the save operation
            with users_lock:
                # 4. *Re-read* the file inside the lock to check for conflicts
                try:
                    # Use the locked load_json_file directly for efficiency
                    current_data_in_file = load_json_file(
                        self.users_file, threading.Lock()
                    )  # Dummy lock as outer lock is held
                    if (
                        current_data_in_file is None
                    ):  # File deleted or corrupted between load and lock?
                        log.error(
                            f"Users file {self.users_file} became inaccessible during save_user_preferences. Aborting."
                        )
                        raise IOError("Users file became inaccessible during save.")

                    # Check if the specific user's data changed concurrently
                    current_user_data_in_file = current_data_in_file.get(user_id, {})
                    if (
                        current_user_data_in_file.get("theme_mode") != original_mode
                        or current_user_data_in_file.get("theme_color")
                        != original_color
                    ):
                        log.warning(
                            f"Conflict detected saving preferences for user '{user_id}'. Retrying (attempt {attempt + 1}/{MAX_RETRIES})..."
                        )
                        # Release lock implicitly by exiting 'with', loop will retry
                        if attempt < MAX_RETRIES - 1:
                            import time

                            time.sleep(
                                RETRY_DELAY * (attempt + 1)
                            )  # Exponential backoff basic
                            continue  # Go to next retry iteration
                        else:
                            log.error(
                                f"Failed to save preferences for user '{user_id}' after {MAX_RETRIES} attempts due to conflicts."
                            )
                            raise RuntimeError(
                                "Failed to save preferences due to concurrent modification."
                            )

                    # 5. If no conflict, save the modified data (atomic save)
                    save_json_atomic(
                        self.users_file, all_users, threading.Lock(), indent=4
                    )  # Dummy lock as outer lock is held
                    log.info(
                        f"Saved preferences for user '{user_id}': Mode={theme_mode}, Color={theme_color}"
                    )
                    return  # Success, exit function

                except Exception as e:
                    log.exception(
                        f"Error during locked save/check in save_user_preferences (attempt {attempt + 1})"
                    )
                    # Depending on error, might want to retry or raise immediately
                    if attempt < MAX_RETRIES - 1:
                        import time

                        time.sleep(RETRY_DELAY * (attempt + 1))
                        continue
                    else:
                        raise  # Re-raise after final attempt

        # Should not be reached if successful, only if retries failed
        log.error(f"Exhausted retries saving preferences for {user_id}")
        raise RuntimeError("Failed to save preferences after multiple retries.")

    # --- Apple Credentials ---

    def load_apple_credentials(
        self, user_id: str
    ) -> Tuple[Optional[str], Optional[str]]:
        """Loads Apple ID and (decrypted) password for a user."""
        creds_filename = self.config["USER_APPLE_CREDS_FILENAME"]
        creds_file = self._get_user_file_path(user_id, creds_filename)
        if not creds_file:
            return None, None
        lock = self.file_locks.get(creds_filename)
        if not lock:
            log.error(f"Lock for '{creds_filename}' not found.")
            return None, None

        creds_data = load_json_file(creds_file, lock)
        if creds_data is None:
            log.debug(f"No Apple credentials file found for user '{user_id}'.")
            return None, None

        apple_id = creds_data.get("apple_id")
        encrypted_password = creds_data.get("apple_password_encrypted")
        if not apple_id or not encrypted_password:
            log.warning(
                f"Incomplete Apple credentials found for user '{user_id}' in {creds_file.name}."
            )
            return apple_id or None, None

        password = decrypt_password(encrypted_password, self.config)
        if not password:
            log.error(
                f"Password decryption failed for user '{user_id}'. Check FERNET_KEY or stored format."
            )
            return apple_id, None
        log.debug(f"Loaded Apple credentials for user '{user_id}'.")
        return apple_id, password

    def save_apple_credentials(self, user_id: str, apple_id: str, apple_password: str):
        """Saves (encrypted) Apple credentials for a user."""
        if not user_id or not apple_id or not apple_password:
            raise ValueError("Missing required arguments for saving Apple credentials.")
        creds_filename = self.config["USER_APPLE_CREDS_FILENAME"]
        creds_file = self._get_user_file_path(user_id, creds_filename)
        if not creds_file:
            raise IOError(f"Could not determine file path for user '{user_id}'.")
        lock = self.file_locks.get(creds_filename)
        if not lock:
            raise RuntimeError("Apple credentials lock configuration missing.")

        encrypted_password = encrypt_password(apple_password, self.config)
        if not encrypted_password and apple_password:
            raise ValueError("Password encryption failed.")

        creds_data = {
            "apple_id": apple_id,
            "apple_password_encrypted": encrypted_password,
            "last_updated": datetime.now(timezone.utc).isoformat(),
        }
        try:
            save_json_atomic(creds_file, creds_data, lock, indent=4)
            log.info(f"Saved Apple credentials to {creds_file} for user '{user_id}'.")
        except Exception as e:
            log.error(f"Failed to save Apple credentials for user '{user_id}': {e}")
            raise

    def clear_apple_credentials(self, user_id: str):
        """Removes the Apple credentials file for a user."""
        if not user_id:
            log.error("clear_apple_credentials called without user_id")
            return
        creds_filename = self.config["USER_APPLE_CREDS_FILENAME"]
        creds_file = self._get_user_file_path(user_id, creds_filename)
        if not creds_file:
            return
        lock = self.file_locks.get(creds_filename)
        if not lock:
            log.error(f"Lock for '{creds_filename}' not found.")
            return
        with lock:
            try:
                if creds_file.exists():
                    os.remove(creds_file)
                    log.info(f"Removed Apple credentials file for user '{user_id}'.")
                else:
                    log.debug(
                        f"No Apple credentials file to remove for user '{user_id}'."
                    )
            except OSError as e:
                log.error(f"Failed to remove {creds_file}: {e}")

    def user_has_apple_credentials(self, user_id: str) -> bool:
        """Checks if the credentials file exists and contains an ID."""
        creds_filename = self.config["USER_APPLE_CREDS_FILENAME"]
        creds_file = self._get_user_file_path(user_id, creds_filename)
        if not creds_file or not creds_file.exists():
            return False
        apple_id, _ = self.load_apple_credentials(user_id)
        return bool(apple_id)

    # --- Devices Config ---

    def load_devices_config(self, user_id: str) -> Dict[str, Dict[str, Any]]:
        """
        Loads and validates the devices configuration for a user.
        Merges devices found from .plist/.keys files if they are missing from devices.json.
        """
        devices_filename = self.config["USER_DEVICES_FILENAME"]
        devices_file = self._get_user_file_path(user_id, devices_filename)
        if not devices_file:
            return {}

        lock = self.file_locks.get(devices_filename)
        if not lock:
            log.error(f"Lock for '{devices_filename}' not found.")
            return {}

        config_data = load_json_file(devices_file, lock)
        if config_data is None:
            config_data = {}  # Start with empty dict if file missing/invalid

        # --- START: Merge file-based devices if missing from loaded config ---
        user_data_dir = self._get_user_data_dir(user_id)
        config_changed_by_merge = False
        if user_data_dir:
            found_file_ids = set()
            for data_file in list(user_data_dir.glob("*.plist")) + list(
                user_data_dir.glob("*.keys")
            ):
                device_id = data_file.stem
                # Skip known non-device files
                if device_id == Path(self.config["USER_APPLE_CREDS_FILENAME"]).stem:
                    continue
                if device_id:
                    found_file_ids.add(device_id)

            devices_to_add = found_file_ids - set(config_data.keys())
            if devices_to_add:
                log.warning(
                    f"User '{user_id}': Found device files not in {devices_filename}: {devices_to_add}. Adding default entries."
                )
                for device_id in devices_to_add:
                    config_data[device_id] = {  # Add default config
                        "name": device_id,
                        "label": "❓",
                        "color": None,
                        "model": "Accessory/Tag",
                        "icon": "tag",
                        "linked_geofences": [],
                    }
                config_changed_by_merge = True  # Mark that we modified the loaded data
        # --- END: Merge file-based devices ---

        # --- Validation ---
        all_user_geofences = self.load_geofences_config(
            user_id
        )  # Load for link validation
        validated_config = {}
        default_config_structure = {
            "linked_geofences": [],
            "name": None,
            "label": "❓",
            "color": None,
            "model": "Accessory/Tag",
            "icon": "tag",
        }
        for device_id, config in config_data.items():
            if not isinstance(config, dict):
                continue
            validated_device = default_config_structure.copy()
            validated_device.update(config)  # Apply loaded config over defaults
            raw_links = validated_device.get("linked_geofences", [])
            validated_links, linked_ids_seen = [], set()
            if isinstance(raw_links, list):
                for link in raw_links:
                    if isinstance(link, dict) and "id" in link:
                        gf_id = link.get("id")
                        if (
                            isinstance(gf_id, str)
                            and gf_id
                            and gf_id in all_user_geofences
                            and gf_id not in linked_ids_seen
                        ):
                            validated_links.append(
                                {
                                    "id": gf_id,
                                    "notify_entry": bool(
                                        link.get("notify_entry", False)
                                    ),
                                    "notify_exit": bool(link.get("notify_exit", False)),
                                }
                            )
                            linked_ids_seen.add(gf_id)
                        elif gf_id and gf_id not in all_user_geofences:
                            log.warning(
                                f"User '{user_id}', Device '{device_id}': Linked geofence ID '{gf_id}' not found. Removing link."
                            )
                        elif gf_id in linked_ids_seen:
                            log.warning(
                                f"User '{user_id}', Device '{device_id}': Duplicate geofence link ID '{gf_id}'. Ignoring duplicate."
                            )
            validated_device["linked_geofences"] = validated_links
            validated_device["name"] = str(
                validated_device.get("name", device_id) or device_id
            ).strip()
            validated_device["label"] = str(
                validated_device.get("label", "❓") or "❓"
            ).strip()[:2]
            validated_device["color"] = validated_device.get("color")  # Allow None
            validated_device["model"] = str(
                validated_device.get("model", "Accessory/Tag") or "Accessory/Tag"
            ).strip()
            validated_device["icon"] = str(
                validated_device.get("icon", "tag") or "tag"
            ).strip()

            # --- Generate and add SVG icon during load ---
            try:
                final_color_for_svg = validated_device["color"] or getDefaultColorForId(
                    device_id
                )
                validated_device["svg_icon"] = generate_device_icon_svg(
                    validated_device["label"], final_color_for_svg
                )
            except Exception as svg_err:
                log.error(
                    f"Error generating SVG during device config load for {device_id}: {svg_err}"
                )
                validated_device["svg_icon"] = None  # Ensure field exists even on error
            # --- -------------------------------------- ---

            validated_config[device_id] = validated_device

        # If we added devices by merging, save the updated config file back
        if config_changed_by_merge:
            log.info(
                f"User '{user_id}': Saving merged device config back to {devices_filename}."
            )
            try:
                # Use save_json_atomic directly for initial save, indent=4 for readability
                save_json_atomic(
                    devices_file,
                    {
                        dev_id: {k: v for k, v in conf.items() if k != "svg_icon"}
                        for dev_id, conf in validated_config.items()
                    },
                    lock,
                    indent=4,
                )  # Exclude SVG from file
            except Exception as e:
                log.error(
                    f"User '{user_id}': Failed to save merged {devices_filename}: {e}"
                )
                # Proceed with in-memory data, but log error

        log.debug(
            f"Device config loaded for user '{user_id}' ({len(validated_config)} items)"
        )
        return validated_config

    def save_devices_config(self, user_id: str, config_data: Dict[str, Dict[str, Any]]):
        """Validates and saves the devices configuration for a user (excluding generated SVG)."""
        devices_filename = self.config["USER_DEVICES_FILENAME"]
        devices_file = self._get_user_file_path(user_id, devices_filename)
        if not devices_file:
            raise IOError(
                f"Could not determine device config file path for user '{user_id}'."
            )
        lock = self.file_locks.get(devices_filename)
        if not lock:
            raise RuntimeError("Device config lock configuration missing.")
        if not isinstance(config_data, dict):
            raise TypeError("Device config data must be a dictionary.")

        all_user_geofences_ids = set(self.load_geofences_config(user_id).keys())
        validated_config_to_save = {}
        for device_id, config in config_data.items():
            if not isinstance(config, dict):
                log.warning(
                    f"User '{user_id}', Device '{device_id}': Invalid config format (not dict) during save, skipping."
                )
                continue
            config_to_save = {
                k: v for k, v in config.items() if k != "svg_icon"
            }  # Exclude SVG from saving

            raw_links = config_to_save.get("linked_geofences", [])
            validated_links, linked_ids_seen = [], set()
            if isinstance(raw_links, list):
                for link in raw_links:
                    if isinstance(link, dict) and "id" in link:
                        gf_id = link.get("id")
                        if (
                            isinstance(gf_id, str)
                            and gf_id
                            and gf_id in all_user_geofences_ids
                            and gf_id not in linked_ids_seen
                        ):
                            validated_links.append(
                                {
                                    "id": gf_id,
                                    "notify_entry": bool(
                                        link.get("notify_entry", False)
                                    ),
                                    "notify_exit": bool(link.get("notify_exit", False)),
                                }
                            )
                            linked_ids_seen.add(gf_id)
                        elif gf_id and gf_id not in all_user_geofences_ids:
                            log.warning(
                                f"User '{user_id}', Device '{device_id}': Skipping link to non-existent geofence ID '{gf_id}' during save."
                            )
                        elif gf_id in linked_ids_seen:
                            log.warning(
                                f"User '{user_id}', Device '{device_id}': Duplicate geofence link ID '{gf_id}' during save. Skipping duplicate."
                            )
            config_to_save["linked_geofences"] = validated_links
            config_to_save["name"] = str(
                config_to_save.get("name", device_id) or device_id
            ).strip()
            config_to_save["label"] = str(
                config_to_save.get("label", "❓") or "❓"
            ).strip()[:2]
            config_to_save["color"] = config_to_save.get("color")
            config_to_save["model"] = str(
                config_to_save.get("model", "Accessory/Tag") or "Accessory/Tag"
            ).strip()
            config_to_save["icon"] = str(
                config_to_save.get("icon", "tag") or "tag"
            ).strip()
            validated_config_to_save[device_id] = config_to_save

        try:
            save_json_atomic(devices_file, validated_config_to_save, lock, indent=4)
            log.info(f"Device config saved to {devices_file} for user '{user_id}'")
        except Exception as e:
            log.error(f"Failed to save device config for user '{user_id}': {e}")
            raise

    # --- Geofences Config ---

    def load_geofences_config(self, user_id: str) -> Dict[str, Dict[str, Any]]:
        """Loads and validates the geofences configuration for a user."""
        geofences_filename = self.config["USER_GEOFENCES_FILENAME"]
        geofences_file = self._get_user_file_path(user_id, geofences_filename)
        if not geofences_file:
            return {}
        lock = self.file_locks.get(geofences_filename)
        if not lock:
            log.error(f"Lock for '{geofences_filename}' not found.")
            return {}

        config_data = load_json_file(geofences_file, lock)
        if config_data is None:
            return {}

        validated_config, seen_names_lower = {}, set()
        for gf_id, config in config_data.items():
            if not isinstance(config, dict):
                log.warning(
                    f"User '{user_id}', Geofence '{gf_id}': Invalid config format (not dict), skipping."
                )
                continue
            try:
                validated_gf = {
                    "id": gf_id,
                    "name": str(config["name"]).strip(),
                    "lat": float(config["lat"]),
                    "lng": float(config["lng"]),
                    "radius": float(config["radius"]),
                }
                if (
                    not validated_gf["name"]
                    or validated_gf["radius"] <= 0
                    or not (-90 <= validated_gf["lat"] <= 90)
                    or not (-180 <= validated_gf["lng"] <= 180)
                ):
                    raise ValueError("Invalid geofence data (name, radius, lat, lng).")
                name_lower = validated_gf["name"].lower()
                if name_lower in seen_names_lower:
                    log.warning(
                        f"User '{user_id}' has duplicate geofence name (case-insensitive): '{validated_gf['name']}'. Loading anyway, but check config."
                    )
                validated_config[gf_id] = validated_gf
                seen_names_lower.add(name_lower)
            except (KeyError, ValueError, TypeError) as ve:
                log.warning(
                    f"User '{user_id}': Skipping invalid geofence config for ID {gf_id}: {config} - Error: {ve}"
                )

        log.debug(
            f"Geofence config loaded for user '{user_id}' ({len(validated_config)} items)"
        )
        return validated_config

    def save_geofences_config(
        self, user_id: str, config_data: Dict[str, Dict[str, Any]]
    ):
        """Validates and saves the geofences configuration for a user."""
        geofences_filename = self.config["USER_GEOFENCES_FILENAME"]
        geofences_file = self._get_user_file_path(user_id, geofences_filename)
        if not geofences_file:
            raise IOError(
                f"Could not determine geofence config file path for user '{user_id}'."
            )
        lock = self.file_locks.get(geofences_filename)
        if not lock:
            raise RuntimeError("Geofence config lock configuration missing.")
        if not isinstance(config_data, dict):
            raise TypeError("Geofence config data must be a dictionary.")

        validated_config_to_save, seen_names_lower = {}, set()
        for gf_id, config in config_data.items():
            config_value = {
                k: v for k, v in config.items() if k != "id"
            }  # Exclude ID from value saved to file
            if not isinstance(config_value, dict):
                log.warning(
                    f"User '{user_id}', Geofence '{gf_id}': Invalid value format (not dict) during save, skipping."
                )
                continue
            try:
                validated_gf_data = {
                    "name": str(config_value["name"]).strip(),
                    "lat": float(config_value["lat"]),
                    "lng": float(config_value["lng"]),
                    "radius": float(config_value["radius"]),
                }
                if (
                    not validated_gf_data["name"]
                    or validated_gf_data["radius"] <= 0
                    or not (-90 <= validated_gf_data["lat"] <= 90)
                    or not (-180 <= validated_gf_data["lng"] <= 180)
                ):
                    raise ValueError("Invalid geofence data (name, radius, lat, lng).")
                name_lower = validated_gf_data["name"].lower()
                if name_lower in seen_names_lower:
                    raise ValueError(
                        f"Duplicate geofence name detected: '{validated_gf_data['name']}'"
                    )
                validated_config_to_save[gf_id] = validated_gf_data
                seen_names_lower.add(name_lower)
            except (KeyError, ValueError, TypeError) as ve:
                log.warning(
                    f"User '{user_id}': Skipping invalid geofence during save ID {gf_id}: {config_value} - Error: {ve}"
                )

        try:
            save_json_atomic(geofences_file, validated_config_to_save, lock, indent=4)
            log.info(f"Geofence config saved to {geofences_file} for user '{user_id}'")
        except Exception as e:
            log.error(f"Failed to save geofence config for user '{user_id}': {e}")
            raise

    # --- Push Subscriptions ---

    def load_subscriptions(self, user_id: str) -> Dict[str, Dict[str, Any]]:
        """Loads push notification subscriptions for a user."""
        subs_filename = self.config["USER_SUBSCRIPTIONS_FILENAME"]
        subs_file = self._get_user_file_path(user_id, subs_filename)
        if not subs_file:
            return {}
        lock = self.file_locks.get(subs_filename)
        if not lock:
            log.error(f"Lock for '{subs_filename}' not found.")
            return {}

        subs_data = load_json_file(subs_file, lock)
        if subs_data is None:
            return {}

        validated_subs = {}
        for endpoint, sub_info in subs_data.items():
            if (
                isinstance(sub_info, dict)
                and "endpoint" in sub_info
                and "keys" in sub_info
            ):
                validated_subs[endpoint] = sub_info
            else:
                log.warning(
                    f"User '{user_id}': Invalid subscription format found for endpoint '{endpoint[:50]}...'. Skipping."
                )
        log.info(f"Loaded {len(validated_subs)} subscriptions for user '{user_id}'")
        return validated_subs

    def save_subscriptions(self, user_id: str, subs_to_save: Dict[str, Dict[str, Any]]):
        """Saves push notification subscriptions for a user."""
        subs_filename = self.config["USER_SUBSCRIPTIONS_FILENAME"]
        subs_file = self._get_user_file_path(user_id, subs_filename)
        if not subs_file:
            raise IOError(
                f"Could not determine subscriptions file path for user '{user_id}'."
            )
        lock = self.file_locks.get(subs_filename)
        if not lock:
            raise RuntimeError("Subscriptions lock configuration missing.")
        if not isinstance(subs_to_save, dict):
            raise TypeError("Subscriptions data must be a dictionary.")

        validated_data_to_save = {}
        for endpoint, sub_info in subs_to_save.items():
            if (
                isinstance(sub_info, dict)
                and "endpoint" in sub_info
                and "keys" in sub_info
            ):
                validated_data_to_save[endpoint] = sub_info
            else:
                log.warning(
                    f"User '{user_id}': Attempting to save invalid subscription format for endpoint '{endpoint[:50]}...'. Skipping."
                )
        try:
            save_json_atomic(
                subs_file, validated_data_to_save, lock, indent=None
            )  # No indent
            log.info(
                f"Saved {len(validated_data_to_save)} subscriptions to {subs_file} for user '{user_id}'"
            )
        except Exception as e:
            log.error(f"Failed to save subscriptions for user '{user_id}': {e}")
            raise

    # --- Notification History ---

    def load_notification_history(self, user_id: str) -> List[Dict[str, Any]]:
        """Loads notification history for a user, sorted newest first."""
        history_filename = self.config["USER_NOTIFICATIONS_HISTORY_FILENAME"]
        history_file = self._get_user_file_path(user_id, history_filename)
        if not history_file:
            return []
        lock = self.file_locks.get(history_filename)
        if not lock:
            log.error(f"Lock for '{history_filename}' not found.")
            return []

        # --- MODIFIED: Use load_json_file but handle LIST type ---
        with lock:
            if not history_file.exists():
                log.debug(f"Notification history file not found: {history_file}")
                return []
            if history_file.stat().st_size == 0:
                log.warning(f"Notification history file is empty: {history_file}")
                return []

            try:
                with open(history_file, "r", encoding="utf-8") as f:
                    history_data = json.load(f)

                # *** CRITICAL FIX: Check if it's a LIST ***
                if not isinstance(history_data, list):
                    log.warning(
                        f"Notification history file {history_file} is not a list. Resetting."
                    )
                    # Optionally backup/rename corrupted file here before returning empty
                    # history_file.rename(history_file.with_suffix(".corrupted"))
                    return []

            except json.JSONDecodeError as e:
                log.error(f"Failed to parse JSON from {history_file}: {e}")
                return []
            except (IOError, OSError) as e:
                log.error(f"Failed to read file {history_file}: {e}")
                return []
            except Exception as e:
                log.exception(f"Unexpected error loading JSON from {history_file}")
                return []
        # --- END MODIFICATION ---

        # Ensure basic structure and sort (Keep this part)
        validated_history = []
        required_keys = {"id", "timestamp", "title", "body", "is_read"}
        for item in history_data:
            if isinstance(item, dict) and required_keys.issubset(item.keys()):
                try:
                    # Attempt to parse timestamp for sorting consistency check
                    item_ts_str = item.get("timestamp", "")
                    # Ensure timestamp has timezone info before parsing
                    if "+" not in item_ts_str and "Z" not in item_ts_str:
                        item_ts_str += "+00:00"  # Assume UTC if no offset
                    else:
                        item_ts_str = item_ts_str.replace("Z", "+00:00")

                    item["timestamp_dt"] = datetime.fromisoformat(item_ts_str)
                    validated_history.append(item)
                except (ValueError, TypeError, KeyError) as e:
                    log.warning(
                        f"Skipping history item with invalid timestamp '{item.get('timestamp')}': {e} (ID: {item.get('id')})"
                    )
            else:
                log.warning(
                    f"Skipping invalid history item structure: {str(item)[:100]}..."
                )

        validated_history.sort(key=lambda x: x["timestamp_dt"], reverse=True)
        # Remove temporary sort key
        for item in validated_history:
            del item["timestamp_dt"]

        log.info(
            f"Loaded {len(validated_history)} notification history entries for user '{user_id}'"
        )
        return validated_history

    def save_notification_history(
        self, user_id: str, notification_entry: Dict[str, Any]
    ):
        """Adds a new notification entry to the history file (which is a list)."""
        history_filename = self.config["USER_NOTIFICATIONS_HISTORY_FILENAME"]
        history_file = self._get_user_file_path(user_id, history_filename)
        if not history_file:
            raise IOError(
                f"Could not get notification history file path for user '{user_id}'."
            )
        lock = self.file_locks.get(history_filename)
        if not lock:
            raise RuntimeError(f"Lock for '{history_filename}' not found.")

        # --- MODIFIED: Load existing history (expecting list) and handle potential errors ---
        with lock:
            current_history = []  # Default to empty list
            if history_file.exists() and history_file.stat().st_size > 0:
                try:
                    with open(history_file, "r", encoding="utf-8") as f:
                        loaded_data = json.load(f)
                    if isinstance(loaded_data, list):
                        current_history = loaded_data
                    else:
                        log.warning(
                            f"Overwriting non-list history file {history_file} during save."
                        )
                except Exception as load_err:
                    log.error(
                        f"Error loading existing history file {history_file} during save, starting fresh: {load_err}"
                    )
            # --- END MODIFICATION ---

            # Prepend new entry
            current_history.insert(0, notification_entry)

            # Prune immediately after adding
            max_days = self.config.get("NOTIFICATION_HISTORY_DAYS", 30)
            cutoff_date = datetime.now(timezone.utc) - timedelta(days=max_days)
            pruned_history = []
            for item in current_history:
                try:
                    # Ensure timestamp has timezone info before parsing
                    item_ts_str = item.get("timestamp", "")
                    if "+" not in item_ts_str and "Z" not in item_ts_str:
                        item_ts_str += "+00:00"
                    else:
                        item_ts_str = item_ts_str.replace("Z", "+00:00")
                    item_ts = datetime.fromisoformat(item_ts_str)
                    if item_ts >= cutoff_date:
                        pruned_history.append(item)
                except (ValueError, TypeError, KeyError) as e:
                    log.warning(
                        f"Skipping item with invalid timestamp '{item.get('timestamp')}' during history save/prune: {e} (ID: {item.get('id')})"
                    )

            try:
                # Save the potentially pruned list back
                save_json_atomic(
                    history_file, pruned_history, threading.Lock(), indent=2
                )  # Use dummy lock inside outer lock
                log.info(
                    f"Saved notification history for user '{user_id}' ({len(pruned_history)} entries)."
                )
            except Exception as e:
                log.error(
                    f"Failed to save notification history for user '{user_id}': {e}"
                )
                raise  # Re-raise the exception after logging

    def update_notification_read_status(
        self, user_id: str, notification_id: str, is_read: bool
    ) -> bool:
        """Updates the read status of a specific notification entry in the history list."""
        history_filename = self.config["USER_NOTIFICATIONS_HISTORY_FILENAME"]
        history_file = self._get_user_file_path(user_id, history_filename)
        if not history_file:
            return False
        lock = self.file_locks.get(history_filename)
        if not lock:
            return False

        with lock:
            # --- MODIFIED: Load directly expecting a list ---
            current_history = []
            if history_file.exists() and history_file.stat().st_size > 0:
                try:
                    with open(history_file, "r", encoding="utf-8") as f:
                        loaded_data = json.load(f)
                    if isinstance(loaded_data, list):
                        current_history = loaded_data
                    else:
                        log.warning(
                            f"History file {history_file} is not a list. Cannot update read status."
                        )
                        return False
                except Exception as load_err:
                    log.error(
                        f"Error loading history file {history_file} for read status update: {load_err}"
                    )
                    return False
            # --- END MODIFICATION ---

            updated = False
            for item in current_history:
                if isinstance(item, dict) and item.get("id") == notification_id:
                    item["is_read"] = bool(is_read)
                    updated = True
                    break  # Found and updated

            if updated:
                try:
                    # Save the modified list
                    save_json_atomic(
                        history_file, current_history, threading.Lock(), indent=2
                    )  # Use dummy lock
                    log.info(
                        f"Updated read status for notification {notification_id} for user '{user_id}' to {is_read}."
                    )
                    return True
                except Exception as e:
                    log.error(
                        f"Failed to save updated history for read status change (user {user_id}): {e}"
                    )
                    return False  # Save failed
            else:
                log.warning(
                    f"Notification ID {notification_id} not found for user '{user_id}' during status update."
                )
                return False  # Indicate not found

    def delete_notification_history(
        self, user_id: str, notification_id: Optional[str] = None
    ) -> bool:
        """Deletes a specific notification or all history (list) for a user."""
        history_filename = self.config["USER_NOTIFICATIONS_HISTORY_FILENAME"]
        history_file = self._get_user_file_path(user_id, history_filename)
        if not history_file:
            return False
        lock = self.file_locks.get(history_filename)
        if not lock:
            return False

        with lock:
            # --- MODIFIED: Load directly expecting a list ---
            current_history = []
            if history_file.exists() and history_file.stat().st_size > 0:
                try:
                    with open(history_file, "r", encoding="utf-8") as f:
                        loaded_data = json.load(f)
                    if isinstance(loaded_data, list):
                        current_history = loaded_data
                    else:
                        log.warning(
                            f"History file {history_file} is not a list. Cannot delete entries."
                        )
                        # Treat as success if clearing all, as file will be overwritten anyway
                        return notification_id is None
                except Exception as load_err:
                    log.error(
                        f"Error loading history file {history_file} for deletion: {load_err}"
                    )
                    return False
            # --- END MODIFICATION ---

            deleted = False
            if notification_id:  # Delete single entry
                original_count = len(current_history)
                new_history = [
                    item
                    for item in current_history
                    if not (
                        isinstance(item, dict) and item.get("id") == notification_id
                    )
                ]
                deleted = len(new_history) < original_count
            else:  # Delete all entries
                new_history = []
                deleted = (
                    len(current_history) > 0
                )  # Mark as deleted if list wasn't already empty

            if (
                deleted or notification_id is None
            ):  # Save if deleted specific OR clearing all
                try:
                    # Save the potentially modified list
                    save_json_atomic(
                        history_file, new_history, threading.Lock(), indent=2
                    )  # Use dummy lock
                    if notification_id:
                        if deleted:
                            log.info(
                                f"Deleted notification {notification_id} for user '{user_id}'."
                            )
                        else:
                            log.warning(
                                f"Notification ID {notification_id} not found for deletion for user '{user_id}'."
                            )
                    else:
                        log.info(
                            f"Cleared all notification history for user '{user_id}'."
                        )
                    return True  # Return True if operation completed, even if specific ID wasn't found
                except Exception as e:
                    log.error(
                        f"Failed to save history after deletion (user {user_id}): {e}"
                    )
                    return False  # Save failed
            else:
                # This case means specific ID was requested but not found
                log.warning(
                    f"Notification ID {notification_id} not found for deletion for user '{user_id}'."
                )
                return True  # Return True as operation completed without error, though nothing changed

    # --- Pruning (Keep as is, it already loads/saves correctly based on the fixed methods above) ---
    def prune_notification_history(self, user_id: str):
        """Removes history entries older than the configured retention period."""
        history_filename = self.config["USER_NOTIFICATIONS_HISTORY_FILENAME"]
        history_file = self._get_user_file_path(user_id, history_filename)
        if not history_file or not history_file.exists():
            return  # No file to prune
        lock = self.file_locks.get(history_filename)
        if not lock:
            return

        with lock:
            # --- MODIFIED: Load directly expecting a list ---
            current_history = []
            if history_file.exists() and history_file.stat().st_size > 0:
                try:
                    with open(history_file, "r", encoding="utf-8") as f:
                        loaded_data = json.load(f)
                    if isinstance(loaded_data, list):
                        current_history = loaded_data
                    else:
                        log.warning(
                            f"History file {history_file} is not a list during prune. Cannot prune."
                        )
                        return  # Cannot prune invalid file
                except Exception as load_err:
                    log.error(
                        f"Error loading history file {history_file} for pruning: {load_err}"
                    )
                    return  # Cannot prune if load fails
            # --- END MODIFICATION ---

            if not current_history:
                return  # Nothing to prune

            max_days = self.config.get("NOTIFICATION_HISTORY_DAYS", 30)
            cutoff_date = datetime.now(timezone.utc) - timedelta(days=max_days)
            original_count = len(current_history)

            pruned_history = []
            for item in current_history:
                try:
                    item_ts_str = item.get("timestamp", "")
                    if "+" not in item_ts_str and "Z" not in item_ts_str:
                        item_ts_str += "+00:00"
                    else:
                        item_ts_str = item_ts_str.replace("Z", "+00:00")
                    item_ts = datetime.fromisoformat(item_ts_str)
                    if item_ts >= cutoff_date:
                        pruned_history.append(item)
                except (ValueError, TypeError, KeyError) as e:
                    log.warning(
                        f"Skipping item with invalid timestamp '{item.get('timestamp')}' during pruning: {e} (ID: {item.get('id')})"
                    )
                    continue  # Skip invalid items

            if len(pruned_history) < original_count:
                try:
                    # Save the pruned list
                    save_json_atomic(
                        history_file, pruned_history, threading.Lock(), indent=2
                    )  # Dummy lock
                    log.info(
                        f"Pruned {original_count - len(pruned_history)} old notification history entries for user '{user_id}'."
                    )
                except Exception as e:
                    log.error(
                        f"Failed to save pruned history for user '{user_id}': {e}"
                    )
            else:
                log.debug(f"No history entries needed pruning for user '{user_id}'.")

    # --- State Files (Geofence, Battery, Notification Times, Cache) ---

    def load_geofence_state(self, user_id: str) -> Dict[Tuple[str, str], str]:
        state_filename = self.config["USER_GEOFENCE_STATE_FILENAME"]
        state_file = self._get_user_file_path(user_id, state_filename)
        if not state_file:
            return {}
        lock = self.file_locks.get(state_filename)
        if not lock:
            log.error(f"Lock for '{state_filename}' not found.")
            return {}
        state_from_file = load_json_file(state_file, lock)
        if state_from_file is None:
            return {}
        parsed_state = {}
        for k, v in state_from_file.items():
            parts = k.split("::", 1)
            if (
                len(parts) == 2
                and isinstance(v, str)
                and v in ["inside", "outside", "unknown"]
            ):
                parsed_state[(parts[0], parts[1])] = v
            else:
                log.warning(
                    f"User '{user_id}': Invalid key/value format in {state_file.name}: {k}={v}"
                )
        log.info(f"Loaded {len(parsed_state)} geofence states for user '{user_id}'")
        return parsed_state

    def save_geofence_state(self, user_id: str, state_dict: Dict[Tuple[str, str], str]):
        state_filename = self.config["USER_GEOFENCE_STATE_FILENAME"]
        state_file = self._get_user_file_path(user_id, state_filename)
        if not state_file:
            raise IOError(
                f"Could not get geofence state file path for user '{user_id}'."
            )
        lock = self.file_locks.get(state_filename)
        if not lock:
            raise RuntimeError(f"Lock for '{state_filename}' not found.")
        if not isinstance(state_dict, dict):
            raise TypeError("Geofence state data must be a dict.")
        state_to_save = {
            f"{k[0]}::{k[1]}": v
            for k, v in state_dict.items()
            if isinstance(k, tuple) and len(k) == 2 and isinstance(v, str)
        }
        try:
            save_json_atomic(state_file, state_to_save, lock, indent=2)
            log.debug(f"Geofence state saved to {state_file} for user '{user_id}'")
        except Exception as e:
            log.error(f"Failed to save geofence state for user '{user_id}': {e}")
            raise

    def load_battery_state(self, user_id: str) -> Dict[str, str]:
        state_filename = self.config["USER_BATTERY_STATE_FILENAME"]
        state_file = self._get_user_file_path(user_id, state_filename)
        if not state_file:
            return {}
        lock = self.file_locks.get(state_filename)
        if not lock:
            log.error(f"Lock for '{state_filename}' not found.")
            return {}
        state_from_file = load_json_file(state_file, lock)
        if state_from_file is None:
            return {}
        state = {
            k: v
            for k, v in state_from_file.items()
            if isinstance(v, str) and v in ["low", "normal", "unknown"]
        }
        log.info(f"Loaded {len(state)} battery states for user '{user_id}'")
        return state

    def save_battery_state(self, user_id: str, state_dict: Dict[str, str]):
        state_filename = self.config["USER_BATTERY_STATE_FILENAME"]
        state_file = self._get_user_file_path(user_id, state_filename)
        if not state_file:
            raise IOError(
                f"Could not get battery state file path for user '{user_id}'."
            )
        lock = self.file_locks.get(state_filename)
        if not lock:
            raise RuntimeError(f"Lock for '{state_filename}' not found.")
        if not isinstance(state_dict, dict):
            raise TypeError("Battery state data must be a dict.")
        state_to_save = {k: v for k, v in state_dict.items() if isinstance(v, str)}
        try:
            save_json_atomic(state_file, state_to_save, lock, indent=2)
            log.debug(f"Battery state saved to {state_file} for user '{user_id}'")
        except Exception as e:
            log.error(f"Failed to save battery state for user '{user_id}': {e}")
            raise

    def load_notification_times(self, user_id: str) -> Dict[Tuple[str, str], float]:
        state_filename = self.config["USER_NOTIFICATION_TIMES_FILENAME"]
        state_file = self._get_user_file_path(user_id, state_filename)
        if not state_file:
            return {}
        lock = self.file_locks.get(state_filename)
        if not lock:
            log.error(f"Lock for '{state_filename}' not found.")
            return {}
        state_from_file = load_json_file(state_file, lock)
        if state_from_file is None:
            return {}
        parsed_state = {}
        for k, v in state_from_file.items():
            parts = k.split("::", 1)
            if len(parts) == 2 and isinstance(v, (int, float)):
                try:
                    parsed_state[(parts[0], parts[1])] = float(v)
                except ValueError:
                    log.warning(
                        f"User '{user_id}': Invalid timestamp value in {state_file.name}: {k}={v}"
                    )
            else:
                log.warning(
                    f"User '{user_id}': Invalid key/value format in {state_file.name}: {k}={v}"
                )
        log.info(f"Loaded {len(parsed_state)} notification times for user '{user_id}'")
        return parsed_state

    def save_notification_times(
        self, user_id: str, state_dict: Dict[Tuple[str, str], float]
    ):
        state_filename = self.config["USER_NOTIFICATION_TIMES_FILENAME"]
        state_file = self._get_user_file_path(user_id, state_filename)
        if not state_file:
            raise IOError(
                f"Could not get notification times file path for user '{user_id}'."
            )
        lock = self.file_locks.get(state_filename)
        if not lock:
            raise RuntimeError(f"Lock for '{state_filename}' not found.")
        if not isinstance(state_dict, dict):
            raise TypeError("Notification times data must be a dict.")
        state_to_save = {}
        for k, v in state_dict.items():
            if isinstance(k, tuple) and len(k) == 2 and isinstance(v, (int, float)):
                state_to_save[f"{k[0]}::{k[1]}"] = float(v)
            else:
                log.warning(
                    f"User '{user_id}': Skipping invalid notification time entry during save: Key={k}, Value={v}"
                )
        try:
            save_json_atomic(state_file, state_to_save, lock, indent=2)
            log.debug(f"Notification times saved to {state_file} for user '{user_id}'")
        except Exception as e:
            log.error(f"Failed to save notification times for user '{user_id}': {e}")
            raise

    def load_cache_from_file(self, user_id: str) -> Optional[Dict[str, Any]]:
        """Loads the cached device data for a user."""
        cache_filename = self.config["USER_CACHE_FILENAME"]
        cache_file = self._get_user_file_path(user_id, cache_filename)
        if not cache_file:
            return None
        lock = self.file_locks.get(cache_filename)
        if not lock:
            log.error(f"Lock for '{cache_filename}' not found.")
            return None

        cache_data = load_json_file(cache_file, lock)
        if cache_data is None:
            return None

        if isinstance(cache_data.get("data"), dict) and "timestamp" in cache_data:
            log.info(
                f"Location data cache loaded from {cache_file} for user '{user_id}'"
            )
            return cache_data
        elif cache_data.get("error") and "timestamp" in cache_data:
            log.warning(f"Cache file for user '{user_id}' contains only error state.")
            return cache_data
        else:
            log.warning(f"Cache file {cache_file} has invalid format. Discarding.")
            return None

    def save_cache_to_file(self, user_id: str, cache_data: Dict[str, Any]):
        """Saves the cached device data for a user."""
        cache_filename = self.config["USER_CACHE_FILENAME"]
        cache_file = self._get_user_file_path(user_id, cache_filename)
        if not cache_file:
            raise IOError(f"Could not get cache file path for user '{user_id}'.")
        lock = self.file_locks.get(cache_filename)
        if not lock:
            raise RuntimeError(f"Lock for '{cache_filename}' not found.")

        if not isinstance(cache_data, dict) or "timestamp" not in cache_data:
            raise ValueError("Invalid cache data structure for saving.")
        if "data" not in cache_data and "error" not in cache_data:
            log.warning(
                f"Saving cache for user '{user_id}' with missing 'data' and 'error' keys."
            )

        try:
            save_json_atomic(
                cache_file, cache_data, lock, indent=None
            )  # No indent for cache
            log.debug(f"Cache saved to {cache_file} for user '{user_id}'")
        except Exception as e:
            log.error(f"Failed to save cache for user '{user_id}': {e}")
            raise

    # --- Data Cleanup Operations ---

    def cleanup_user_data_files(self, user_id: str, valid_device_ids: Set[str]):
        """Removes stale entries from state files for devices that no longer exist."""
        log.info(
            f"Running state file cleanup for user '{user_id}' based on {len(valid_device_ids)} valid device(s)."
        )
        try:
            current_gf_state = self.load_geofence_state(user_id)
            keys_to_remove_gf = [
                k for k in current_gf_state if k[0] not in valid_device_ids
            ]
            if keys_to_remove_gf:
                log.info(
                    f"User '{user_id}': Removing {len(keys_to_remove_gf)} stale geofence state entries."
                )
                updated_state = {
                    k: v
                    for k, v in current_gf_state.items()
                    if k not in keys_to_remove_gf
                }
                self.save_geofence_state(user_id, updated_state)
        except Exception as e:
            log.error(f"User '{user_id}': Error cleaning up geofence state: {e}")
        try:
            current_batt_state = self.load_battery_state(user_id)
            keys_to_remove_batt = [
                k for k in current_batt_state if k not in valid_device_ids
            ]
            if keys_to_remove_batt:
                log.info(
                    f"User '{user_id}': Removing {len(keys_to_remove_batt)} stale battery state entries."
                )
                updated_state = {
                    k: v
                    for k, v in current_batt_state.items()
                    if k not in keys_to_remove_batt
                }
                self.save_battery_state(user_id, updated_state)
        except Exception as e:
            log.error(f"User '{user_id}': Error cleaning up battery state: {e}")
        try:
            current_notify_times = self.load_notification_times(user_id)
            keys_to_remove_times = [
                k
                for k in current_notify_times
                if isinstance(k, tuple) and len(k) > 0 and k[0] not in valid_device_ids
            ]
            if keys_to_remove_times:
                log.info(
                    f"User '{user_id}': Removing {len(keys_to_remove_times)} stale notification time entries."
                )
                updated_state = {
                    k: v
                    for k, v in current_notify_times.items()
                    if k not in keys_to_remove_times
                }
                self.save_notification_times(user_id, updated_state)
        except Exception as e:
            log.error(f"User '{user_id}': Error cleaning up notification times: {e}")
        log.info(f"Finished state file cleanup for user '{user_id}'.")

    # --- NEW: Account Deletion ---

    def load_shares(self) -> Dict[str, Dict[str, Any]]:
        """Loads the global shares database (shares.json)."""
        shares_lock = self.file_locks.get("shares")
        if not shares_lock:
            log.error("Lock for 'shares.json' not found.")
            return {}
        shares_data = load_json_file(self.config["SHARES_FILE"], shares_lock)
        if shares_data is None:
            return {}
        if not isinstance(shares_data, dict):
            log.error("shares.json format invalid.")
            return {}
        # log.debug(f"Loaded {len(shares_data)} shares.") # Less verbose
        return shares_data

    def save_shares(self, shares_data: Dict[str, Dict[str, Any]]):
        """Saves the global shares database (shares.json)."""
        shares_lock = self.file_locks.get("shares")
        if not shares_lock:
            raise RuntimeError("Share lock missing.")
        if not isinstance(shares_data, dict):
            raise TypeError("shares_data must be dict.")
        try:
            save_json_atomic(
                self.config["SHARES_FILE"], shares_data, shares_lock, indent=2
            )
            log.info(
                f"Saved {len(shares_data)} shares to {self.config['SHARES_FILE'].name}"
            )
        except Exception as e:
            log.error(f"Failed to save shares data: {e}")
            raise

    def add_share(
        self,
        user_id: str,
        device_id: str,
        duration_hours: Optional[int],
        note: Optional[str] = None,
    ) -> Optional[Dict[str, Any]]:
        """Creates a new share record."""
        if not user_id or not device_id:
            log.error("Missing user/device ID for share.")
            return None
        share_id = str(uuid.uuid4())
        now = datetime.now(timezone.utc)
        expires_at = None
        if duration_hours is not None and duration_hours > 0:
            expires_at = now + timedelta(hours=duration_hours)
        elif duration_hours == 0:
            expires_at = None  # Indefinite
        else:
            default_duration = self.config.get("DEFAULT_SHARE_DURATION_HOURS", 24)
            if default_duration > 0:
                expires_at = now + timedelta(hours=default_duration)
        new_share = {
            "share_id": share_id,
            "user_id": user_id,
            "device_id": device_id,
            "created_at": now.isoformat(),
            "expires_at": expires_at.isoformat() if expires_at else None,
            "active": True,
            "note": (note or "").strip()[:100],
        }
        try:
            all_shares = self.load_shares()
            all_shares[share_id] = new_share
            self.save_shares(all_shares)
            log.info(
                f"User '{user_id}' created share '{share_id}' for device '{device_id}'. Expires: {new_share['expires_at']}"
            )
            return new_share
        except Exception as e:
            log.exception(
                f"Failed to add share for user '{user_id}', device '{device_id}'"
            )
            return None

    def get_share(self, share_id: str) -> Optional[Dict[str, Any]]:
        """Retrieves a specific share record by its ID."""
        all_shares = self.load_shares()
        return all_shares.get(share_id)

    def get_user_shares(self, user_id: str) -> List[Dict[str, Any]]:
        """Retrieves all active shares created by a specific user."""
        all_shares = self.load_shares()
        user_shares = []
        now_utc = datetime.now(timezone.utc)
        for share_id, share_data in all_shares.items():
            if share_data.get("user_id") == user_id:
                is_expired = False
                expires_at_str = share_data.get("expires_at")
                if expires_at_str:
                    try:
                        expires_at_dt = datetime.fromisoformat(
                            expires_at_str.replace("Z", "+00:00")
                        )
                        if expires_at_dt.tzinfo is None:
                            expires_at_dt = expires_at_dt.replace(tzinfo=timezone.utc)
                        if expires_at_dt < now_utc:
                            is_expired = True
                    except ValueError:
                        log.warning(f"Invalid expiry format for share {share_id}")
                        is_expired = True
                # Only include if active flag is True (ignore expiry here, UI can show expired ones if needed)
                # if share_data.get("active", False): # <<< Keep this check
                share_data_with_id = share_data.copy()
                share_data_with_id["share_id"] = share_id
                share_data_with_id["is_expired"] = is_expired  # Add expiry status flag
                user_shares.append(share_data_with_id)
        user_shares.sort(key=lambda x: x.get("created_at", ""), reverse=True)
        return user_shares

    # --- START: New Share Management Methods ---
    def toggle_share_status(
        self, share_id: str, requesting_user_id: str, new_status: bool
    ) -> bool:
        """Sets the active status of a share if the requesting user is the owner."""
        try:
            all_shares = self.load_shares()
            share_data = all_shares.get(share_id)

            if not share_data:
                log.warning(f"Toggle status failed: Share ID '{share_id}' not found.")
                return False
            if share_data.get("user_id") != requesting_user_id:
                log.warning(
                    f"Toggle status failed: User '{requesting_user_id}' does not own share '{share_id}'."
                )
                return False

            current_status = share_data.get("active", False)
            if current_status == new_status:
                log.info(
                    f"Share '{share_id}' status is already {new_status}. No change needed."
                )
                return True  # Treat as success if already in desired state

            share_data["active"] = new_status
            self.save_shares(all_shares)
            log.info(
                f"User '{requesting_user_id}' set share '{share_id}' status to {new_status}."
            )
            return True
        except Exception as e:
            log.exception(f"Failed to toggle status for share '{share_id}'")
            return False

    def update_share_expiry(
        self, share_id: str, requesting_user_id: str, new_duration_hours: Optional[int]
    ) -> Optional[Dict]:
        """Updates the expiry time of a share if the requesting user is the owner."""
        try:
            all_shares = self.load_shares()
            share_data = all_shares.get(share_id)

            if not share_data:
                log.warning(f"Update expiry failed: Share ID '{share_id}' not found.")
                return None
            if share_data.get("user_id") != requesting_user_id:
                log.warning(
                    f"Update expiry failed: User '{requesting_user_id}' does not own share '{share_id}'."
                )
                return None

            now = datetime.now(timezone.utc)
            new_expires_at = None
            if new_duration_hours is not None and new_duration_hours > 0:
                new_expires_at = now + timedelta(hours=new_duration_hours)
            elif new_duration_hours == 0:  # Indefinite
                new_expires_at = None
            else:  # Use default if invalid duration provided (e.g., None or negative)
                default_duration = self.config.get("DEFAULT_SHARE_DURATION_HOURS", 24)
                if default_duration > 0:
                    new_expires_at = now + timedelta(hours=default_duration)

            share_data["expires_at"] = (
                new_expires_at.isoformat() if new_expires_at else None
            )
            share_data["note"] = share_data.get(
                "note", ""
            )  # Ensure note exists even if empty

            self.save_shares(all_shares)
            log.info(
                f"User '{requesting_user_id}' updated expiry for share '{share_id}' to {share_data['expires_at']}."
            )
            # Return the updated share data (including share_id)
            updated_share = share_data.copy()
            updated_share["share_id"] = share_id
            return updated_share
        except Exception as e:
            log.exception(f"Failed to update expiry for share '{share_id}'")
            return None

    # --- END: New Share Management Methods ---

    def delete_share_permanently(self, share_id: str, requesting_user_id: str) -> bool:
        """
        Permanently deletes a share record from shares.json if the user is the owner.
        """
        try:
            all_shares = self.load_shares() # load_shares handles locking for read
            share_data = all_shares.get(share_id)

            if not share_data:
                log.warning(f"Permanent delete failed: Share ID '{share_id}' not found.")
                return False # Not found is not an error, but deletion didn't happen

            if share_data.get("user_id") != requesting_user_id:
                log.warning(f"Permanent delete failed: User '{requesting_user_id}' does not own share '{share_id}'.")
                # Consider raising PermissionError here? For now, return False
                return False

            # If checks pass, remove the entry
            del all_shares[share_id]

            # Save the modified dictionary (save_shares handles locking for write)
            self.save_shares(all_shares)
            log.info(f"User '{requesting_user_id}' permanently deleted share '{share_id}'.")
            return True

        except KeyError: # Should be caught by the get() check, but safety first
            log.warning(f"Permanent delete failed: Share ID '{share_id}' key error during removal attempt.")
            return False
        except Exception as e:
            log.exception(f"Failed to permanently delete share '{share_id}'")
            return False # Indicate failure
    # --- END: New Permanent Delete Method ---


    def revoke_share(self, share_id: str, requesting_user_id: str) -> bool:
        """Revokes a share by setting its status to inactive."""
        # This method now only sets active=False
        log.info(f"Revoking share '{share_id}' by setting active=False (not deleting).")
        return self.toggle_share_status(share_id, requesting_user_id, new_status=False)

    def prune_expired_shares(self):
        # Keep existing logic, but now only needs to check expiry, not active flag
        log.info("Running periodic share pruning...")
        try:
            all_shares = self.load_shares()
            shares_to_keep = {}
            now_utc = datetime.now(timezone.utc)
            removed_count = 0
            for share_id, share_data in all_shares.items():
                is_expired = False
                expires_at_str = share_data.get("expires_at")
                if expires_at_str:
                    try:
                        expires_at_dt = datetime.fromisoformat(
                            expires_at_str.replace("Z", "+00:00")
                        )
                        if expires_at_dt.tzinfo is None:
                            expires_at_dt = expires_at_dt.replace(tzinfo=timezone.utc)
                        if expires_at_dt < now_utc:
                            is_expired = True
                    except ValueError:
                        log.warning(f"Invalid expiry format during pruning {share_id}")
                        is_expired = True
                # Keep shares that are NOT expired (regardless of active status, user manages that)
                if not is_expired:
                    shares_to_keep[share_id] = share_data
                else:
                    log.debug(f"Pruning expired share '{share_id}'")
                    removed_count += 1
            if removed_count > 0:
                self.save_shares(shares_to_keep)
                log.info(f"Successfully pruned {removed_count} expired shares.")
            else:
                log.info("No shares needed pruning based on expiry.")
        except Exception as e:
            log.exception("Error during share pruning")

    def is_device_shared(self, user_id: str, device_id: str) -> bool:
        # Keep existing logic (checks active and expiry)
        all_shares = self.load_shares()
        now_utc = datetime.now(timezone.utc)
        for share_id, share_data in all_shares.items():
            if (
                share_data.get("user_id") == user_id
                and share_data.get("device_id") == device_id
            ):
                if share_data.get("active", False):
                    expires_at_str = share_data.get("expires_at")
                    if expires_at_str:
                        try:
                            expires_at_dt = datetime.fromisoformat(
                                expires_at_str.replace("Z", "+00:00")
                            )
                            if expires_at_dt.tzinfo is None:
                                expires_at_dt = expires_at_dt.replace(
                                    tzinfo=timezone.utc
                                )
                            if expires_at_dt >= now_utc:
                                return True
                        except ValueError:
                            continue
                    else:
                        return True  # Active and never expires
        return False

    def delete_user_data(self, user_id: str) -> bool:
        """
        Deletes a user's entry from users.json and their entire data directory.
        Corrected to avoid lock re-acquisition.
        Returns True if user entry is successfully removed, False otherwise.
        """
        if not user_id:
            log.error("Attempted to delete user with empty ID.")
            return False

        log.warning(f"Initiating deletion for user '{user_id}'. This is irreversible.")
        user_removed_from_json = False
        users_lock = self.file_locks.get("users")

        if not users_lock:
            log.error(
                "CRITICAL: Lock for 'users.json' not found. Cannot remove user entry. Aborting delete."
            )
            return False

        # --- Step 1: Remove user from users.json (under lock) ---
        try:
            # Use a temporary dummy lock for internal calls as the main lock is held
            dummy_lock = threading.Lock()
            with users_lock:  # Acquire the actual lock
                # --- Read directly using load_json_file ---
                all_users = load_json_file(self.users_file, dummy_lock)
                if all_users is None:
                    # Handle case where file doesn't exist or is invalid within the lock
                    log.error(
                        f"Could not load users from {self.users_file} during delete operation."
                    )
                    # Decide if this should be treated as "user already removed" or an error
                    # Let's treat as error for safety, as we can't confirm state.
                    return False  # Or raise an exception

                if user_id in all_users:
                    log.debug(
                        f"Found user '{user_id}' in users file. Preparing removal."
                    )
                    del all_users[user_id]
                    # --- Save directly using save_json_atomic ---
                    save_json_atomic(self.users_file, all_users, dummy_lock, indent=4)
                    log.info(
                        f"Successfully removed user '{user_id}' entry from {self.users_file.name} and saved file."
                    )
                    user_removed_from_json = True
                else:
                    log.warning(
                        f"User '{user_id}' was not found in users.json during deletion attempt (already removed?)."
                    )
                    user_removed_from_json = True  # Treat as success if already gone

        except (IOError, OSError, TypeError, RuntimeError, Exception) as e:
            log.exception(
                f"Failed operation within lock while removing user '{user_id}'. Aborting delete."
            )
            return False  # Failed the critical step

        # --- Step 2: Delete user directory (AFTER releasing lock) ---
        if user_removed_from_json:
            try:
                all_shares = self.load_shares()
                shares_to_keep = {
                    sid: sdata
                    for sid, sdata in all_shares.items()
                    if sdata.get("user_id") != user_id
                }
                if len(shares_to_keep) < len(all_shares):
                    self.save_shares(shares_to_keep)
                    log.info(
                        f"Removed shares associated with deleted user '{user_id}'."
                    )
                else:
                    log.info(f"No shares found for deleted user '{user_id}'.")
            except Exception as e:
                log.error(f"Failed to remove shares for deleted user '{user_id}': {e}")
            # Still return True as user account is gone
            return True
        else:
            log.error(
                f"Deletion failed because user '{user_id}' not removed from users.json."
            )
            return False

    def delete_device_and_data(self, user_id: str, device_id: str) -> Tuple[bool, str]:
        """
        Deletes a device's source file (.plist/.keys) and removes its related data
        from configuration and state files.

        Args:
            user_id: The ID of the user.
            device_id: The ID of the device to delete.

        Returns:
            A tuple (success: bool, message: str).
        """
        log.warning(f"Attempting to delete device '{device_id}' for user '{user_id}'.")
        user_data_dir = self._get_user_data_dir(user_id)
        if not user_data_dir:
            msg = f"Could not access data directory for user '{user_id}'."
            log.error(msg)
            return False, msg

        source_file_deleted = False
        deleted_filename = "Unknown"

        # --- 1. Delete Source File (.plist or .keys) ---
        # No specific lock needed for single file deletion, OS handles atomicity generally.
        plist_path = user_data_dir / f"{device_id}.plist"
        keys_path = user_data_dir / f"{device_id}.keys"
        file_to_delete = None

        if plist_path.exists():
            file_to_delete = plist_path
        elif keys_path.exists():
            file_to_delete = keys_path

        if file_to_delete:
            try:
                deleted_filename = file_to_delete.name
                os.remove(file_to_delete)
                log.info(f"User '{user_id}': Deleted source file {deleted_filename}.")
                source_file_deleted = True
            except OSError as e:
                msg = f"Failed to delete source file {file_to_delete.name}: {e}"
                log.error(f"User '{user_id}': {msg}")
                # Continue cleanup even if source file deletion fails (might be permissions issue)
                # return False, msg # Option: Halt if source file can't be deleted
        else:
            log.warning(
                f"User '{user_id}': Source file (.plist or .keys) for device '{device_id}' not found. Proceeding with data cleanup."
            )
            # Allow cleanup even if source file is missing

        # --- 2. Clean up JSON files (locking individually) ---
        cleanup_errors = []

        # Helper function to load, modify, save a file atomically with locking
        def cleanup_json_file(filename_key: str, removal_logic):
            json_filename = self.config.get(filename_key)
            if not json_filename:
                log.error(f"Config key '{filename_key}' not found.")
                cleanup_errors.append(f"Config missing for {filename_key}")
                return

            json_file = self._get_user_file_path(user_id, json_filename)
            lock = self.file_locks.get(json_filename)

            if not json_file or not lock:
                log.error(f"Path or lock not found for {json_filename}.")
                cleanup_errors.append(f"Path/lock error for {json_filename}")
                return

            with lock:  # Lock for the read-modify-write operation
                try:
                    # Load using the locked helper (pass dummy lock as outer lock is held)
                    data = load_json_file(json_file, threading.Lock())
                    if data is None:  # File non-existent or invalid
                        log.debug(
                            f"{json_filename} not found or invalid for user '{user_id}', skipping cleanup."
                        )
                        return

                    original_size = len(data)
                    updated_data = removal_logic(
                        data
                    )  # Apply the specific removal logic

                    if len(updated_data) < original_size:
                        # Save using the locked helper (pass dummy lock)
                        save_json_atomic(
                            json_file,
                            updated_data,
                            threading.Lock(),
                            indent=2 if filename_key != "USER_CACHE_FILENAME" else None,
                        )
                        log.info(
                            f"User '{user_id}': Removed '{device_id}' related entries from {json_filename}."
                        )
                    else:
                        log.debug(
                            f"User '{user_id}': No entries for '{device_id}' found in {json_filename}."
                        )

                except Exception as e:
                    msg = f"Failed to process {json_filename} for device '{device_id}': {e}"
                    log.exception(f"User '{user_id}': {msg}")
                    cleanup_errors.append(msg)

        # --- Apply Cleanup Logic for each file ---

        # a) devices.json (Keep as is)
        cleanup_json_file(
            "USER_DEVICES_FILENAME",
            lambda data: {k: v for k, v in data.items() if k != device_id},
        )

        # --- *** CORRECTED Cache Cleanup Logic *** ---
        # b) cache.json
        def remove_from_cache(cache_dict):
            if (
                isinstance(cache_dict, dict)
                and "data" in cache_dict
                and isinstance(cache_dict["data"], dict)
            ):
                # Modify the inner 'data' dictionary
                if device_id in cache_dict["data"]:
                    del cache_dict["data"][device_id]
                    log.debug(
                        f"Removed device '{device_id}' from inner 'data' dict in cache."
                    )
            # Return the potentially modified outer dictionary
            return cache_dict

        cleanup_json_file("USER_CACHE_FILENAME", remove_from_cache)
        # --- *** END CORRECTION *** ---

        # c) geofence_state.json (Keep as is)
        cleanup_json_file(
            "USER_GEOFENCE_STATE_FILENAME",
            lambda data: {
                k: v for k, v in data.items() if not k.startswith(f"{device_id}::")
            },
        )
        # d) battery_state.json (Keep as is)
        cleanup_json_file(
            "USER_BATTERY_STATE_FILENAME",
            lambda data: {k: v for k, v in data.items() if k != device_id},
        )
        # e) notification_times.json (Keep as is)
        cleanup_json_file(
            "USER_NOTIFICATION_TIMES_FILENAME",
            lambda data: {
                k: v for k, v in data.items() if not k.startswith(f"{device_id}::")
            },
        )
        # f) (Optional) notifications_history.json (Keep commented or implement if needed)

        if cleanup_errors:
            final_message = f"Device '{device_id}' source file ({deleted_filename}) deleted (or was missing), but errors occurred during data cleanup: {'; '.join(cleanup_errors)}"
            log.error(f"User '{user_id}': {final_message}")
            return False, final_message
        else:
            final_message = f"Successfully deleted device '{device_id}' ({deleted_filename}) and associated data."
            log.info(f"User '{user_id}': {final_message}")
            return True, final_message

// --------------------
// app\services\__init__.py
# app/services/__init__.py
# This file can be empty or used to import services for easier access
# e.g., from .user_data_service import UserDataService
// --------------------
// app\static\favicon.ico
[Binary or unreadable file]

// --------------------
// app\static\sw.js
// app/static/sw.js

// Keep existing constants and install/activate listeners...
const CACHE_NAME = 'findmy-cache-v8'; // Increment if significant changes
const urlsToCache = [
  // Core App Shell
  '/', // Explicitly cache the root
  '/static/css/style.css',
  '/static/js/config.js',
  '/static/js/state.js',
  '/static/js/utils.js',
  '/static/js/api.js',
  '/static/js/ui.js',
  '/static/js/map.js',
  '/static/js/notifications.js',
  '/static/js/app.js',

  // Icons
  '/static/icons/web-app-manifest-192x192.png',
  '/static/icons/web-app-manifest-512x512.png',
  '/static/icons/favicon.svg',
  '/static/icons/apple-touch-icon.png',
  '/static/icons/icon.svg',
  '/static/img/wifi_tethering_16dp.png', // Examples - keep if used
  '/static/img/crisis_alert_16dp.png',   // Examples - keep if used
  '/static/img/labs_16dp.png',         // Examples - keep if used
  '/favicon.ico', // Use root route now handled by Flask

  // Leaflet assets
  '/static/libs/leaflet/leaflet.js',
  '/static/styles/leaflet/leaflet.css',
  '/static/styles/leaflet/images/marker-icon.png',
  '/static/styles/leaflet/images/marker-icon-2x.png',
  '/static/styles/leaflet/images/marker-shadow.png',

  // Material Icons & Symbols CSS (fonts are loaded BY the CSS)
  '/static/styles/material-icons/material-icons.css',
  '/static/styles/material-symbols/material-symbols-outlined.css',
  // Add specific WOFF2 font files if you want explicit caching (optional, CSS usually triggers load)
  // e.g., '/static/fonts/material-icons.woff2',
  // e.g., '/static/fonts/material-symbols-outlined.woff2',
  // You'll need to list the actual filenames you downloaded

  // Material Color Utilities (local fallback)
  '/static/libs/material-color/material-color-utilities.esm.js',
  // --- END ADDED ---

];

// --- Install Event ---
self.addEventListener('install', event => {
  console.log(`[SW-${CACHE_NAME}] Install event started.`);
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log(`[SW-${CACHE_NAME}] Caching core assets... (${urlsToCache.length} items)`);
        const criticalAssets = ['/', '/static/css/style.css', '/static/js/app.js'];
        const cachePromises = urlsToCache.map(urlToCache => {
          const isExternal = urlToCache.startsWith('https://');
          const requestOptions = isExternal ? {} : { cache: 'reload' }; // Only reload local assets
          return cache.add(new Request(urlToCache, requestOptions))
            .catch(err => {
              const urlPath = new URL(urlToCache, self.location.origin).pathname;
              if (!isExternal && criticalAssets.some(critical => urlPath.endsWith(critical))) {
                console.error(`[SW-${CACHE_NAME}] CRITICAL ASSET FAILED TO CACHE: ${urlPath}`, err);
                throw new Error(`Failed to cache critical asset: ${urlPath}`);
              } else {
                console.warn(`[SW-${CACHE_NAME}] Failed to cache non-critical/external asset on install (continuing): ${urlPath}`, err);
                return null; // Resolve as null/undefined on non-critical failure
              }
            });
        });
        // Ensure only resolved promises proceed
        return Promise.all(cachePromises.filter(p => p !== null));
      })
      .then(() => {
        console.log(`[SW-${CACHE_NAME}] Core assets caching finished. Activating immediately.`);
        return self.skipWaiting();
      })
      .catch(error => {
        console.error(`[SW-${CACHE_NAME}] Installation failed due to critical asset error:`, error);
      })
  );
});

// --- Activate Event ---
self.addEventListener('activate', event => {
  console.log(`[SW-${CACHE_NAME}] Activate event started.`);
  event.waitUntil(
    (async () => {
      try { if (self.clients && typeof self.clients.claim === 'function') { await self.clients.claim(); console.log(`[SW-${CACHE_NAME}] Clients claimed successfully.`); } }
      catch (err) { console.error(`[SW-${CACHE_NAME}] Error claiming clients:`, err); }
      try {
        const cacheNames = await caches.keys();
        await Promise.all(
          cacheNames.map(cacheName => {
            if (cacheName !== CACHE_NAME) { console.log(`[SW-${CACHE_NAME}] Deleting old cache:`, cacheName); return caches.delete(cacheName); }
          })
        ); console.log(`[SW-${CACHE_NAME}] Old caches deleted successfully.`);
      } catch (err) { console.error(`[SW-${CACHE_NAME}] Error deleting old caches:`, err); }
      console.log(`[SW-${CACHE_NAME}] Activation complete.`);
    })()
  );
});

// --- Fetch Event ---
self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);

  // Network Only for API
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(
      fetch(event.request).catch(error => {
        console.warn(`[SW-${CACHE_NAME}] Network request failed for API ${event.request.method} ${url.pathname}:`, error);
        // Consider returning a custom offline JSON response for GET API calls if needed
        // if (event.request.method === 'GET') {
        //   return new Response(JSON.stringify({ error: 'Offline', message: 'Cannot fetch data while offline.' }), {
        //     status: 503, headers: { 'Content-Type': 'application/json' }
        //   });
        // }
        throw error; // Let browser handle non-GET API errors when offline
      })
    );
    return;
  }

  // Cache First for Static Assets
  if (event.request.method === 'GET' &&
    (url.pathname.startsWith('/static/') ||
      url.pathname === '/favicon.ico' ||
      url.pathname === '/sw.js' ||
      url.pathname === '/manifest.json')) { // Use correct manifest name
    event.respondWith(
      caches.match(event.request)
        .then(cachedResponse => {
          if (cachedResponse) { return cachedResponse; }
          return fetch(event.request).then(response => {
            if (!response || response.status !== 200 || (response.type !== 'basic' && response.type !== 'cors')) {
              if (response) console.warn(`[SW-${CACHE_NAME}] Not Caching: ${url.pathname} (${response.status}, ${response.type})`);
              return response;
            }
            const responseToCache = response.clone();
            caches.open(CACHE_NAME).then(cache => { cache.put(event.request, responseToCache); });
            return response;
          }
          ).catch(error => {
            console.error(`[SW-${CACHE_NAME}] Network fetch failed for cacheable asset: ${url.pathname}`, error);
            // Optionally return a fallback asset if needed, e.g., an offline image placeholder
            throw error;
          });
        })
    );
    return;
  }

  // Network First (with Cache Fallback) for Root HTML (/)
  if (event.request.method === 'GET' && url.pathname === '/') {
    event.respondWith(
      fetch(event.request)
        .then(response => {
          if (!response || response.status !== 200 || response.type !== 'basic') {
            if (response) console.warn(`[SW-${CACHE_NAME}] Not Caching /: (${response.status}, ${response.type})`);
            return response;
          }
          const responseToCache = response.clone();
          caches.open(CACHE_NAME).then(cache => { cache.put(event.request, responseToCache); });
          return response;
        })
        .catch(async (error) => {
          console.warn(`[SW-${CACHE_NAME}] Network failed for /, serving from cache. Error:`, error);
          const cachedResponse = await caches.match(event.request);
          if (cachedResponse) { return cachedResponse; }
          else { console.error(`[SW-${CACHE_NAME}] Network failed and / not in cache.`); throw error; }
        })
    );
    return;
  }

  // Default: Let the browser handle other requests
});


// --- Push Event Listener --- (*** ADDED THIS ***)
self.addEventListener('push', event => {
  console.log('[SW] Push Received.');

  let payload = {};
  if (event.data) {
    try {
      payload = event.data.json();
      console.log('[SW] Push data payload:', payload);
    } catch (e) {
      console.error('[SW] Error parsing push data:', e);
      payload = { notification: { title: "Notification", body: "Error parsing content." } };
    }
  } else {
    console.log('[SW] Push event had no data.');
    payload = { notification: { title: "Notification", body: "No content received." } };
  }

  const notificationData = payload.notification || {};
  const title = notificationData.title || 'FindMy Alert';
  const options = {
    body: notificationData.body || 'You received a notification.',
    // Directly use the icon URL provided by the backend
    icon: notificationData.icon || '/static/icons/favicon.svg', // Use provided or fallback static
    badge: notificationData.badge || '/static/icons/badge-icon.png', // Use provided or fallback static badge
    tag: notificationData.tag || 'findmy-notification-' + Date.now(),
    renotify: notificationData.renotify || false,
    requireInteraction: notificationData.requireInteraction || false,
    data: notificationData.data || {},
  };

  // --- REMOVED data URL check ---
  // if (options.data && options.data.device_icon_data_url) {
  //   console.log('[SW] Using device-specific icon from data URL.'); // No longer applicable
  //   options.icon = options.data.device_icon_data_url;
  // }
  // --- ------------------------ ---

  console.log('[SW] Showing notification:', title, options);

  const notificationPromise = self.registration.showNotification(title, options);
  event.waitUntil(notificationPromise);
});
// --- END OF ADDED PUSH LISTENER ---


// --- Notification Click Listener ---
// (Keep existing notificationclick listener)
self.addEventListener('notificationclick', event => {
  const clickedNotification = event.notification;
  const notificationData = clickedNotification.data;

  console.log('[SW] Notification click Received.');
  console.log('[SW] Notification Tag:', clickedNotification.tag);
  console.log('[SW] Notification Data Payload:', notificationData);

  clickedNotification.close();

  const targetUrl = new URL('/', self.location.origin).href;
  let focusMessage = null;

  if (notificationData && notificationData.deviceId) {
    console.log(`[SW] Click relates to device: ${notificationData.deviceId}`);
    focusMessage = { type: 'focusDevice', deviceId: notificationData.deviceId };
  } else {
    console.log('[SW] Click is for a generic notification.');
  }

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then(clientList => {
      let focusedClient = null;
      for (const client of clientList) {
        if (new URL(client.url).pathname === '/' && 'focus' in client) {
          console.log('[SW] Found existing client to focus:', client.url);
          focusedClient = client;
          break;
        }
      }

      if (focusedClient) {
        return focusedClient.focus().then(() => {
          if (focusMessage) {
            console.log('[SW] Sending focus message to client:', focusMessage);
            focusedClient.postMessage(focusMessage);
          }
        }).catch(focusErr => {
          console.error('[SW] Error focusing client:', focusErr);
          if (clients.openWindow) {
            console.log('[SW] Focusing failed. Opening new window instead.');
            const urlToOpen = focusMessage?.deviceId ? `${targetUrl}?focusDevice=${focusMessage.deviceId}` : targetUrl;
            return clients.openWindow(urlToOpen);
          }
        });
      } else {
        if (clients.openWindow) {
          console.log('[SW] No matching client found. Opening new window.');
          const urlToOpen = focusMessage?.deviceId ? `${targetUrl}?focusDevice=${focusMessage.deviceId}` : targetUrl;
          return clients.openWindow(urlToOpen);
        } else {
          console.warn('[SW] clients.openWindow() is not supported.');
        }
      }
    }).catch(err => {
      console.error('[SW] Error handling notification click:', err);
    })
  );
});


console.log(`[SW-${CACHE_NAME}] Script loaded. Event listeners attached.`);
// --------------------
// app\static\css\style.css
/* app/static/css/style.css */

/* Define M3 variables with default LIGHT purple theme fallbacks */
:root {
    /* M3 Sys Color Roles (Light Theme Fallbacks - Purple Source #6750A4) */
    --m3-sys-color-primary: #6750A4;
    --m3-sys-color-on-primary: #FFFFFF;
    --m3-sys-color-primary-container: #EADDFF;
    --m3-sys-color-on-primary-container: #21005D;
    --m3-sys-color-secondary: #625B71;
    --m3-sys-color-on-secondary: #FFFFFF;
    --m3-sys-color-secondary-container: #E8DEF8;
    --m3-sys-color-on-secondary-container: #1D192B;
    --m3-sys-color-tertiary: #7D5260;
    --m3-sys-color-on-tertiary: #FFFFFF;
    --m3-sys-color-tertiary-container: #FFD8E4;
    --m3-sys-color-on-tertiary-container: #31111D;
    --m3-sys-color-error: #B3261E;
    --m3-sys-color-on-error: #FFFFFF;
    --m3-sys-color-error-container: #F9DEDC;
    --m3-sys-color-on-error-container: #410E0B;
    --m3-sys-color-background: #FFFBFE;
    --m3-sys-color-on-background: #1C1B1F;
    --m3-sys-color-surface: #FFFBFE;
    --m3-sys-color-surface-rgb: 255, 251, 254;
    /* RGB for #FFFBFE */
    --m3-sys-color-on-surface: #1C1B1F;
    --m3-sys-color-surface-variant: #E7E0EC;
    --m3-sys-color-on-surface-variant: #49454F;
    --m3-sys-color-outline: #79747E;
    --m3-sys-color-outline-variant: #CAC4D0;
    --m3-sys-color-shadow: #000000;
    --m3-sys-color-scrim: #000000;
    /* Scrim RGB for rgba() calculations if needed */
    --m3-sys-color-scrim-rgb: 0, 0, 0;
    --m3-sys-color-inverse-surface: #313033;
    --m3-sys-color-inverse-on-surface: #F4EFF4;
    --m3-sys-color-inverse-primary: #D0BCFF;
    /* M3 Surface Tones (Light Theme Fallbacks) */
    --m3-sys-color-surface-dim: #DED8E1;
    --m3-sys-color-surface-bright: #FFFBFE;
    --m3-sys-color-surface-container-lowest: #FFFFFF;
    --m3-sys-color-surface-container-low: #F7F2FA;
    --m3-sys-color-surface-container: #F3EDF7;
    --m3-sys-color-surface-container-high: #EDEAF3;
    --m3-sys-color-surface-container-highest: #E6E0E9;

    /* Typography (Keep unchanged) */
    --font-family: 'Roboto', 'Segoe UI', Arial, sans-serif;
    --headline-large-size: 32px;
    --headline-large-weight: 400;
    --headline-medium-size: 28px;
    --headline-medium-weight: 400;
    --headline-small-size: 24px;
    --headline-small-weight: 400;
    --title-large-size: 22px;
    --title-large-weight: 500;
    --title-medium-size: 16px;
    --title-medium-weight: 500;
    --title-small-size: 14px;
    --title-small-weight: 500;
    --body-large-size: 16px;
    --body-large-weight: 400;
    --body-medium-size: 14px;
    --body-medium-weight: 400;
    --body-small-size: 12px;
    --body-small-weight: 400;
    --label-large-size: 14px;
    --label-large-weight: 500;
    --label-medium-size: 12px;
    --label-medium-weight: 500;
    --label-small-size: 11px;
    --label-small-weight: 500;
}

/* --- DARK THEME FALLBACK OVERRIDES --- */
/* Define dark variables when the dark-theme class is present */
.dark-theme {
    /* M3 Sys Color Roles (Dark Theme Fallbacks - Purple Source #6750A4) */
    --m3-sys-color-primary: #D0BCFF;
    --m3-sys-color-on-primary: #381E72;
    --m3-sys-color-primary-container: #4F378B;
    --m3-sys-color-on-primary-container: #EADDFF;
    --m3-sys-color-secondary: #CCC2DC;
    --m3-sys-color-on-secondary: #332D41;
    --m3-sys-color-secondary-container: #4A4458;
    --m3-sys-color-on-secondary-container: #E8DEF8;
    --m3-sys-color-tertiary: #EFB8C8;
    --m3-sys-color-on-tertiary: #492532;
    --m3-sys-color-tertiary-container: #633B48;
    --m3-sys-color-on-tertiary-container: #FFD8E4;
    --m3-sys-color-error: #F2B8B5;
    --m3-sys-color-on-error: #601410;
    --m3-sys-color-error-container: #8C1D18;
    --m3-sys-color-on-error-container: #F9DEDC;
    --m3-sys-color-background: #1C1B1F;
    --m3-sys-color-on-background: #E6E1E5;
    --m3-sys-color-surface: #1C1B1F;
    --m3-sys-color-surface-rgb: 28, 27, 31;
    /* RGB for #1C1B1F */
    --m3-sys-color-on-surface: #E6E1E5;
    --m3-sys-color-surface-variant: #49454F;
    --m3-sys-color-on-surface-variant: #CAC4D0;
    --m3-sys-color-outline: #938F99;
    --m3-sys-color-outline-variant: #49454F;
    --m3-sys-color-shadow: #000000;
    --m3-sys-color-scrim: #000000;
    /* Scrim RGB for rgba() calculations if needed */
    --m3-sys-color-scrim-rgb: 0, 0, 0;
    --m3-sys-color-inverse-surface: #E6E1E5;
    --m3-sys-color-inverse-on-surface: #313033;
    --m3-sys-color-inverse-primary: #6750A4;
    /* M3 Surface Tones (Dark Theme Fallbacks) */
    --m3-sys-color-surface-dim: #141218;
    --m3-sys-color-surface-bright: #3B383E;
    --m3-sys-color-surface-container-lowest: #0F0D13;
    --m3-sys-color-surface-container-low: #1C1B1F;
    --m3-sys-color-surface-container: #201F23;
    --m3-sys-color-surface-container-high: #2B292F;
    --m3-sys-color-surface-container-highest: #36343A;
}


/* General Reset and Body Styles */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: var(--font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    outline: none;
}

*:active {
    outline: none;
}

*:focus {
    outline: none;
}

/* Scrollbar Styles */
::-webkit-scrollbar {
    width: 5px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background-color: var(--m3-sys-color-outline);
    border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
    background-color: var(--m3-sys-color-on-surface-variant);
}

::-webkit-scrollbar-corner {
    background: transparent;
}

body {
    background-color: var(--m3-sys-color-background);
    color: var(--m3-sys-color-on-background);
    height: 100vh;
    display: flex;
    flex-direction: column;
    transition: background-color 0.3s, color 0.3s;
}

/* Input color scheme hint for dark mode */
.dark-theme input,
.dark-theme select,
.dark-theme textarea,
.dark-theme button {
    color-scheme: dark;
}


/* App Bar styling */
.app-bar {
    background-color: var(--m3-sys-color-surface-container-low);
    color: var(--m3-sys-color-on-surface);
    padding: 16px;
    display: flex;
    align-items: center;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.1);
    position: sticky;
    top: 0;
    z-index: 10;
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
}

.app-bar h1 {
    font-size: var(--title-large-size);
    font-weight: var(--title-large-weight);
    margin-left: 16px;
    color: var(--m3-sys-color-on-surface);
    transition: color 0.3s;
}

.app-bar .menu-icon,
.app-bar .action-button {
    width: 24px;
    height: 24px;
    opacity: 0.7;
    cursor: pointer;
    font-size: 24px;
    color: var(--m3-sys-color-on-surface-variant);
    transition: opacity 0.3s, color 0.3s;
}

.app-bar .action-buttons {
    margin-left: auto;
    display: flex;
    gap: 8px;
}

/* Content styling */
.content {
    flex: 1;
    padding: 16px;
    overflow: auto;
    padding-bottom: 96px;
}

#index-page {
    display: block;
    height: 100%;
}

.history-slider-container {
    /* Default hidden state */
    opacity: 0;
    visibility: hidden;
    max-height: 0;
    /* Use max-height for smooth collapse/expand */
    overflow: hidden;
    /* Hide content when collapsed */
    transition: opacity 0.3s ease-out, visibility 0s linear 0.3s, max-height 0.3s ease-out;
    /* Delay visibility change */
    text-align: center;
    margin-bottom: 0;
    /* Collapse margin */
    pointer-events: none;
}

.history-slider-container.visible {
    /* Visible state */
    opacity: 1;
    visibility: visible;
    max-height: 100px;
    /* Adjust to fit content */
    margin-bottom: 16px;
    /* Restore margin */
    transition: opacity 0.3s ease-out, visibility 0s linear 0s, max-height 0.3s ease-out;
    pointer-events: auto;
}

#history-slider-label {
    color: var(--m3-sys-color-on-surface-variant);
    font-size: var(--label-medium-size);
}

#history-slider {
    cursor: pointer;
    accent-color: var(--m3-sys-color-primary);
    margin-top: 2px;
    width: 95%;
}

/* Map placeholder and container */
/* .map-container {
    height: 45vh;
    background-color: var(--m3-sys-color-surface-container);
    border-radius: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 16px;
    position: relative;
    overflow: hidden;
} */

.map-container {
    height: 45vh;
    /* Or your desired height */
    background-color: var(--m3-sys-color-surface-container);
    border-radius: 16px;
    margin-bottom: 16px;
    position: relative;
    /* Crucial for absolute positioning of child */
    overflow: hidden;
    /* Keep content within rounded corners */
}


#map {
    height: 100%;
    border-radius: 16px;
    width: 100%;
    display: block;
    z-index: 1;
    background: var(--m3-sys-color-background);
}


/* Map Placeholder - Make it an overlay */
#map-placeholder {
    position: absolute;
    /* Position it over the map div */
    top: 0;
    left: 0;
    width: 100%;
    /* Cover full width */
    height: 100%;
    /* Cover full height */
    display: flex;
    /* Keep flex for centering content */
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: color-mix(in srgb, var(--m3-sys-color-surface) 90%, transparent);
    /* Use surface with slight transparency */
    /* Optional: Add backdrop blur if supported */
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
    z-index: 5;
    /* Ensure it's above #map but below map controls/popups */
    border-radius: 16px;
    /* Match container radius */
    transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
    /* Fade transition */
    opacity: 0;
    /* Start hidden */
    visibility: hidden;
    /* Start hidden */
    pointer-events: none;
    /* Don't capture clicks when hidden */
    color: var(--m3-sys-color-on-surface-variant);
}

#map-placeholder.visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    /* Allow interaction if needed (e.g., cancel button) */
}

#map-placeholder .spinner {
    /* Spinner styles already defined */
    border: 4px solid var(--m3-sys-color-surface-variant);
    border-top: 4px solid var(--m3-sys-color-primary);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin-bottom: 16px;
}

#map-placeholder p {
    margin-top: 0;
    /* Remove previous margin */
    color: var(--m3-sys-color-on-surface-variant);
    font-size: var(--body-medium-size);
    opacity: 0.8;
    transition: color 0.3s;
}

#map-placeholder .material-icons.error {
    /* Error icon styling */
    font-size: 48px;
    color: var(--m3-sys-color-error);
    margin-bottom: 16px;
}



/* Custom Leaflet marker style */
.custom-marker {
    display: flex;
    justify-content: center;
    text-align: center;
    align-items: center;
    align-content: center;
    vertical-align: middle;
}

.custom-marker.fallback-icon div {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: var(--m3-sys-color-outline-variant);
    color: var(--m3-sys-color-on-surface-variant);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
}

.custom-marker .material-icons {
    font-size: 20px;
    color: var(--m3-sys-color-primary);
    display: block;
}

.saved-place-marker .material-icons {
    color: var(--m3-sys-color-tertiary);
    font-size: 22px;
}

.search-location-marker .material-icons {
    color: var(--m3-sys-color-error);
    font-size: 24px;
}

/* Dialog maps */
#add-place-dialog .dialog-content #place-picker-map,
#geofence-dialog .dialog-content #geofence-picker-map {
    height: 250px;
    margin-bottom: 16px;
    border-radius: 12px;
    background-color: var(--m3-sys-color-surface-container);
    position: relative;
    overflow: hidden;
    z-index: 1;
}

/* Map Placeholder */
.map-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: var(--m3-sys-color-surface-container);
    background-image: radial-gradient(circle, var(--m3-sys-color-outline-variant) 1px, transparent 1px);
    background-size: 20px 20px;
    transition: background-color 0.3s, background-image 0.3s;
}

.map-placeholder .material-icons {
    font-size: 48px;
    color: var(--m3-sys-color-outline);
    opacity: 0.5;
    transition: color 0.3s;
}

.map-placeholder p {
    margin-top: 12px;
    color: var(--m3-sys-color-outline);
    font-size: var(--body-medium-size);
    opacity: 0.6;
    transition: color 0.3s;
}

/* Hide default Leaflet attribution */
.leaflet-control-attribution {
    display: none;
}

/* User location marker style */
.current-location-marker {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 14px;
    height: 14px;
    background-color: var(--m3-sys-color-primary);
    border-radius: 50%;
    border: 2px solid var(--m3-sys-color-surface);
    box-shadow: 0 0 0 6px color-mix(in srgb, var(--m3-sys-color-primary) 20%, transparent);
    animation: pulse 2s infinite;
    z-index: 3;
}

@keyframes pulse {

    0% {
        box-shadow: 0 0 0 0 color-mix(in srgb, var(--m3-sys-color-primary) 40%, transparent);
    }

    70% {
        box-shadow: 0 0 0 10px color-mix(in srgb, var(--m3-sys-color-primary) 0%, transparent);
    }

    100% {
        box-shadow: 0 0 0 0 color-mix(in srgb, var(--m3-sys-color-primary) 0%, transparent);
    }
}

/* Map Controls */
.map-controls {
    position: absolute;
    right: 16px;
    bottom: 24px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 6;
    align-items: flex-end;
}

.map-control-button {
    width: 40px;
    height: 40px;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.1);
    cursor: pointer;
    transition: box-shadow 0.2s, background-color 0.2s;
}

.map-control-button:hover {
    box-shadow: 0 2px 4px rgba(var(--m3-sys-color-shadow), 0.15);
    background-color: var(--m3-sys-color-surface-container-highest);
}

.map-control-button .material-icons {
    font-size: 24px;
    color: var(--m3-sys-color-on-surface-variant);
    transition: color 0.3s;
}

.map-control-button.active {
    background-color: var(--m3-sys-color-primary-container);
}

.map-control-button.active .material-icons {
    color: var(--m3-sys-color-on-primary-container);
}

/* Card styling */
.card {
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 16px;
    border: 1px solid var(--m3-sys-color-outline-variant);
    padding: 24px;
    margin-bottom: 16px;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.08);
    transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s;
}

#my-location span {
    color: var(--m3-sys-color-primary);
}

.card-title {
    font-size: var(--title-medium-size);
    font-weight: var(--title-medium-weight);
    margin-bottom: 12px;
    color: var(--m3-sys-color-on-surface);
    transition: color 0.3s;
}

/* Location Info */
.location-info {
    display: flex;
    align-items: center;
    margin-bottom: 16px;
}

.location-info-icon {
    width: 24px;
    height: 24px;
    margin-right: 24px;
    opacity: 0.6;
    font-size: 24px;
    color: var(--m3-sys-color-on-surface-variant);
    transition: opacity 0.3s, color 0.3s;
}

.location-info-text {
    flex: 1;
}

.location-address {
    font-size: var(--body-large-size);
    color: var(--m3-sys-color-on-surface);
    line-height: 1.4;
    transition: color 0.3s;
}

.location-coordinates {
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-on-surface-variant);
    margin-top: 6px;
    transition: color 0.3s;
}

/* Button styling */
.button {
    background-color: var(--m3-sys-color-primary);
    color: var(--m3-sys-color-on-primary);
    border: none;
    padding: 12px 24px;
    border-radius: 100px;
    font-size: var(--label-large-size);
    font-weight: var(--label-large-weight);
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: background-color 0.2s, box-shadow 0.2s;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.1);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
}

.button:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-primary) 90%, black 10%);
    box-shadow: 0 2px 4px rgba(var(--m3-sys-color-shadow), 0.15);
}

.button:active {
    background-color: color-mix(in srgb, var(--m3-sys-color-primary) 85%, black 15%);
    box-shadow: 0 1px 1px rgba(var(--m3-sys-color-shadow), 0.1);
}

.button:disabled {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 8%, transparent);
    color: var(--m3-sys-color-on-surface);
    opacity: 0.38;
    cursor: not-allowed;
    box-shadow: none;
}

.button-row {
    display: flex;
    gap: 16px;
    margin-top: 24px;
    justify-content: flex-end;
}

.text-button {
    background: none;
    border: none;
    color: var(--m3-sys-color-primary);
    font-size: var(--label-large-size);
    font-weight: var(--label-large-weight);
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 12px 16px;
    border-radius: 100px;
    transition: background-color 0.2s, color 0.2s;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.text-button:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-primary) 8%, transparent);
    color: var(--m3-sys-color-primary);
}

.text-button:active {
    background-color: color-mix(in srgb, var(--m3-sys-color-primary) 12%, transparent);
    color: var(--m3-sys-color-primary);
}

.text-button:disabled {
    color: var(--m3-sys-color-on-surface);
    opacity: 0.38;
    cursor: not-allowed;
    background-color: transparent;
}

/* Bottom navigation */
.bottom-nav {
    display: flex;
    background-color: var(--m3-sys-color-surface-container);
    border-top: 1px solid var(--m3-sys-color-outline-variant);
    padding: 8px 0;
    box-shadow: 0 -1px 2px rgba(var(--m3-sys-color-shadow), 0.08);
    transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10;
}

.nav-item {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 0;
    cursor: pointer;
    color: var(--m3-sys-color-on-surface-variant);
    text-decoration: none;
    transition: color 0.3s;
}

.nav-item.active {
    color: var(--m3-sys-color-primary);
}

.nav-icon {
    width: 24px;
    height: 24px;
    margin-bottom: 4px;
    font-size: 24px;
}

.nav-label {
    font-size: var(--label-medium-size);
}

/* FAB */
.fab {
    position: fixed;
    bottom: 90px;
    left: 16px;
    width: 56px;
    height: 56px;
    border-radius: 16px;
    background-color: var(--m3-sys-color-primary-container);
    color: var(--m3-sys-color-on-primary-container);
    display: none;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 6px rgba(var(--m3-sys-color-shadow), 0.15);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
    z-index: 11;
}

.fab:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 8px rgba(var(--m3-sys-color-shadow), 0.2);
    background-color: color-mix(in srgb, var(--m3-sys-color-primary-container) 90%, black 10%);
}

.fab:active {
    transform: scale(0.95);
    box-shadow: 0 1px 4px rgba(var(--m3-sys-color-shadow), 0.15);
    background-color: color-mix(in srgb, var(--m3-sys-color-primary-container) 85%, black 15%);
}

.fab .material-icons {
    font-size: 28px;
}

/* Dialog */
.dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(var(--m3-sys-color-scrim-rgb, 0, 0, 0), 0.4);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 100;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
}

.dialog-overlay.show {
    display: flex;
    opacity: 1;
    visibility: visible;
}

.dialog {
    margin: 32px;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 28px;
    width: fit-content;
    min-width: 280px;
    max-width: calc(100% - 64px);
    max-height: calc(100% - 64px);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 3px 9px rgba(var(--m3-sys-color-shadow), 0.15);
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.2s ease-out, transform 0.2s ease-out, background-color 0.3s, box-shadow 0.3s;
}

.dialog-overlay.show .dialog {
    opacity: 1;
    transform: scale(1);
}

.dialog-header {
    padding: 24px;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
    transition: border-color 0.3s;
    flex-shrink: 0;
    display: flex;
    align-items: center;
}

.dialog-title {
    font-size: var(--headline-small-size);
    font-weight: var(--headline-small-weight);
    color: var(--m3-sys-color-on-surface);
    transition: color 0.3s;
}

.dialog-content {
    padding: 24px;
    color: var(--m3-sys-color-on-surface);
    font-size: var(--body-medium-size);
    line-height: 1.5;
    transition: color 0.3s;
    overflow-y: auto;
    flex-grow: 1;
}

.dialog-actions {
    display: flex;
    justify-content: flex-end;
    padding: 8px 16px 16px 16px;
    border-top: 1px solid var(--m3-sys-color-outline-variant);
    gap: 8px;
    flex-shrink: 0;
}

/* Tabs */
.tabs {
    display: flex;
    background-color: var(--m3-sys-color-surface);
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.05);
    overflow-x: auto;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
    transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s;
}

.tab {
    padding: 16px 24px;
    font-size: var(--label-large-size);
    font-weight: var(--label-large-weight);
    color: var(--m3-sys-color-on-surface-variant);
    cursor: pointer;
    white-space: nowrap;
    position: relative;
    border-bottom: 3px solid transparent;
    transition: color 0.2s, border-bottom-color 0.2s;
}

.tab:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 4%, transparent);
}

.tab.active {
    color: var(--m3-sys-color-primary);
    border-bottom-color: var(--m3-sys-color-primary);
}

/* Drawer menu */
.drawer-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(var(--m3-sys-color-scrim-rgb, 0, 0, 0), 0.4);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    z-index: 100;
}

.drawer-overlay.show {
    opacity: 1;
    visibility: visible;
}

.drawer {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 300px;
    background-color: var(--m3-sys-color-surface-container-low);
    transform: translateX(-100%);
    transition: transform 0.3s ease, background-color 0.3s;
    z-index: 101;
    display: flex;
    flex-direction: column;
    box-shadow: 2px 0 6px rgba(var(--m3-sys-color-shadow), 0.1);
}

.drawer.open {
    transform: translateX(0);
}

.drawer-header {
    padding: 16px 24px;
    height: 64px;
    display: flex;
    align-items: center;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
    transition: border-color 0.3s;
    flex-shrink: 0;
}

.drawer-title {
    font-size: var(--title-large-size);
    font-weight: var(--title-large-weight);
    color: var(--m3-sys-color-on-surface);
    margin-left: 16px;
    transition: color 0.3s;
}

.drawer-header .material-icons.menu-icon {
    margin-left: -8px;
}

.drawer-content {
    flex: 1;
    overflow: auto;
}

.drawer-item {
    display: flex;
    align-items: center;
    padding: 16px 24px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.drawer-item:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 4%, transparent);
}

.drawer-item-icon {
    width: 24px;
    height: 24px;
    margin-right: 32px;
    opacity: 0.6;
    font-size: 24px;
    color: var(--m3-sys-color-on-surface-variant);
    transition: opacity 0.3s, color 0.3s;
}

.drawer-item-text {
    font-size: var(--body-large-size);
    color: var(--m3-sys-color-on-surface);
    transition: color 0.3s;
}

.drawer-divider {
    height: 1px;
    background-color: var(--m3-sys-color-outline-variant);
    margin: 12px 0;
    transition: background-color 0.3s;
}

/* Settings page specific */
.settings-section {
    margin-bottom: 24px;
}

.settings-section-title {
    font-size: var(--label-medium-size);
    font-weight: var(--label-medium-weight);
    color: var(--m3-sys-color-primary);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 0.4px;
    transition: color 0.3s;
    padding: 0 8px;
}

.settings-item {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    padding: 16px 24px;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 16px;
    margin-bottom: 12px;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.08);
    transition: background-color 0.3s, box-shadow 0.3s;
}

.settings-item-text {
    flex: 1;
    margin-right: 16px;
}

.settings-item-title {
    font-size: var(--body-large-size);
    color: var(--m3-sys-color-on-surface);
    margin-bottom: 4px;
    transition: color 0.3s;
}

.settings-item-description {
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface-variant);
    transition: color 0.3s;
}

/* Toggle Switch */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 26px;
    margin-left: auto;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--m3-sys-color-outline);
    transition: .4s, background-color 0.3s;
    border-radius: 34px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 2px;
    bottom: 2px;
    background-color: var(--m3-sys-color-outline-variant);
    transition: .4s, transform 0.3s;
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.2);
}

input:checked+.toggle-slider {
    background-color: var(--m3-sys-color-primary);
}

input:checked+.toggle-slider:before {
    background-color: var(--m3-sys-color-on-primary);
    transform: translateX(18px);
}


/* Shared devices page specific */
#shared-devices-list .loading-indicator,
#shared-devices-list .no-devices-message,
.no-devices-message {
    padding: 24px;
    text-align: center;
    color: var(--m3-sys-color-on-surface-variant);
    font-style: italic;
}

.shared-device {
    display: flex;
    align-items: center;
    padding: 16px 24px;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 16px;
    margin-bottom: 12px;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.08);
    transition: background-color 0.3s, box-shadow 0.3s;
    cursor: pointer;
}

.device-icon {
    width: 48px;
    height: 48px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-right: 20px;
    flex-shrink: 0;
    overflow: hidden;
}

.device-icon svg {
    width: 100%;
    height: 100%;
    display: block;
}

.device-icon .device-icon-fallback {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: var(--m3-sys-color-outline-variant);
    color: var(--m3-sys-color-on-surface-variant);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: bold;
}

.device-info {
    flex: 1;
    overflow: hidden;
    margin-right: 16px;
}

.device-name {
    font-size: var(--body-large-size);
    color: var(--m3-sys-color-on-surface);
    margin-bottom: 4px;
    transition: color 0.3s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.device-status {
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface-variant);
    transition: color 0.3s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.device-status .material-icons {
    font-size: 16px;
    vertical-align: middle;
    margin-left: 4px;
}

.device-status .material-icons.error {
    color: var(--m3-sys-color-error);
}

.device-menu {
    width: 24px;
    height: 24px;
    opacity: 0.6;
    cursor: pointer;
    font-size: 24px;
    color: var(--m3-sys-color-on-surface-variant);
    transition: opacity 0.3s, color 0.3s;
    margin-left: auto;
    flex-shrink: 0;
}

/* History page specific */
.timeline {
    position: relative;
    margin-left: 24px;
    padding-left: 32px;
}

.timeline:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 2px;
    background-color: var(--m3-sys-color-outline-variant);
    transition: background-color 0.3s;
}

.timeline-item {
    position: relative;
    margin-bottom: 24px;
}

.timeline-item:last-child {
    margin-bottom: 0;
}

.timeline-dot {
    position: absolute;
    left: -37px;
    top: 4px;
    width: 12px;
    height: 12px;
    background-color: var(--m3-sys-color-primary);
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.1);
}

.timeline-time {
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-on-surface-variant);
    margin-bottom: 6px;
    transition: color 0.3s;
}

.timeline-content {
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.08);
    transition: background-color 0.3s, box-shadow 0.3s;
}

.timeline-location {
    font-size: var(--body-large-size);
    color: var(--m3-sys-color-on-surface);
    font-weight: var(--body-large-weight);
    margin-bottom: 4px;
    transition: color 0.3s;
}

.timeline-content p {
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface-variant);
    line-height: 1.4;
}

/* Ripple effect */
.button,
.text-button,
.map-control-button,
.nav-item,
.drawer-item,
.tab,
.settings-item,
.shared-device,
.fab {
    overflow: hidden;
    position: relative;
    transform: translateZ(0);
}

.button::after,
.text-button::after,
.map-control-button::after,
.nav-item::after,
.drawer-item::after,
.tab::after,
.settings-item::after,
.shared-device::after,
.fab::after {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, var(--m3-sys-color-primary) 10%, transparent 10.01%);
    background-repeat: no-repeat;
    background-position: 50%;
    opacity: 0;
    pointer-events: none;
    transform: scale(10, 10);
    transition: transform 0.5s, opacity 1s;
}

.button:active::after,
.text-button:active::after,
.map-control-button:active::after,
.nav-item:active::after,
.drawer-item:active::after,
.tab:active::after,
.settings-item:active::after,
.shared-device:active::after,
.fab:active::after {
    opacity: 0.12;
    transform: scale(0, 0);
    transition: transform 0s, opacity 0s;
}

/* Device Icon Selector */
.device-icon-selector {
    display: flex;
    gap: 16px;
    align-items: center;
    margin-top: 8px;
}

.device-icon-selector label {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
}

.device-icon-selector label input[type="radio"] {
    display: none;
}

.device-icon-selector label span.material-icons {
    font-size: 30px;
    color: var(--m3-sys-color-outline);
    opacity: 0.5;
    transition: opacity 0.2s, color 0.2s;
}

.device-icon-selector label input[type="radio"]:checked+span.material-icons {
    opacity: 1;
    color: var(--m3-sys-color-primary);
}


/* Search Bar Styling */
.search-bar {
    display: flex;
    align-items: center;
    background-color: var(--m3-sys-color-surface-container-highest);
    border-radius: 100px;
    padding: 8px 16px;
    margin-left: 8px;
    margin-right: 8px;
    flex-grow: 1;
    transition: background-color 0.3s;
}

.search-icon {
    color: var(--m3-sys-color-on-surface-variant);
    margin-right: 12px;
    opacity: 0.6;
    font-size: 20px;
    transition: color 0.3s, opacity 0.3s;
}

.search-input {
    border: none;
    background-color: transparent;
    flex-grow: 1;
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    outline: none;
    transition: color 0.3s;
}

.search-input::placeholder {
    color: var(--m3-sys-color-on-surface-variant);
    opacity: 0.8;
}

/* Input fields */
.dialog-content .settings-section .settings-item input[type="text"],
.dialog-content .settings-section .settings-item input[type="number"],
.dialog-content .settings-section .settings-item input[type="email"],
.dialog-content .settings-section .settings-item input[type="password"],
.dialog-content .settings-section .settings-item textarea,
.dialog-content .settings-section .settings-item select,
.login-card input[type="text"],
.settings-item input[type="number"],
.login-card input[type="password"],
.login-card input[type="email"] {
    margin-left: 0;
    border: 1px solid var(--m3-sys-color-outline);
    border-radius: 8px;
    padding: 12px;
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    background-color: var(--m3-sys-color-surface);
    outline: none;
    transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s;
    margin-top: 8px;
    font-family: var(--font-family);
    width: 100%;
    box-sizing: border-box;
}

.login-card input[type="text"],
.login-card input[type="password"],
.login-card input[type="email"] {
    margin-top: 0;
    margin-bottom: 16px;
}

/* Input focus */
.dialog-content .settings-section .settings-item input:focus-visible,
.dialog-content .settings-section .settings-item textarea:focus-visible,
.dialog-content .settings-section .settings-item select:focus-visible,
.login-card input:focus-visible {
    border-color: var(--m3-sys-color-primary);
    box-shadow: 0 0 0 1px var(--m3-sys-color-primary);
}

/* Theme Selector Radio Buttons */
.theme-selector {
    margin-left: auto;
    text-align: left;
}

.theme-selector label {
    display: block;
    margin-bottom: 8px;
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    cursor: pointer;
}

.theme-selector label:last-child {
    margin-bottom: 0;
}

.theme-selector input[type="radio"] {
    margin-right: 8px;
    accent-color: var(--m3-sys-color-primary);
}


/* Color Picker Container */
.color-picker-container {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-left: auto;
}

#theme-color-picker {
    width: 40px;
    height: 40px;
    padding: 0;
    border: 1px solid var(--m3-sys-color-outline-variant);
    border-radius: 50%;
    cursor: pointer;
    overflow: hidden;
    background-color: transparent;
}

#theme-color-picker::-webkit-color-swatch-wrapper {
    padding: 0;
    border-radius: 50%;
}

#theme-color-picker::-webkit-color-swatch {
    border: none;
    border-radius: 50%;
}

#theme-color-picker::-moz-color-swatch {
    border: none;
    border-radius: 50%;
}

#reset-theme-color-button {
    margin-left: 8px;
    padding: 6px 10px;
    min-width: auto;
}

#reset-theme-color-button .material-icons {
    font-size: 16px;
}

/* Map Dialog Controls */
.map-dialog-controls {
    position: absolute;
    right: 8px;
    bottom: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1001;
    pointer-events: auto;
}

#place-picker-my-location,
#geofence-picker-my-location {
    width: 40px;
    height: 40px;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.1);
    cursor: pointer;
    transition: box-shadow 0.2s, background-color 0.2s;
}

#place-picker-my-location:hover,
#geofence-picker-my-location:hover {
    box-shadow: 0 2px 4px rgba(var(--m3-sys-color-shadow), 0.15);
    background-color: var(--m3-sys-color-surface-container-highest);
}

#place-picker-my-location .material-icons,
#geofence-picker-my-location .material-icons {
    font-size: 24px;
    color: var(--m3-sys-color-primary);
}


/* More Menu Dialog */
#more-menu-dialog {
    width: 200px;
    min-width: auto;
    max-width: 200px;
    max-height: none;
    border-radius: 16px;
    padding: 8px 0;
    box-shadow: 0 4px 12px rgba(var(--m3-sys-color-shadow), 0.15);
    position: absolute;
    background-color: var(--m3-sys-color-surface-container);
}

#more-menu-dialog .dialog-content {
    padding: 0;
}

#more-menu-dialog .drawer-item {
    padding: 12px 16px;
}

#more-menu-dialog .drawer-item-icon {
    margin-right: 16px;
}

#more-menu-dialog .dialog-header,
#more-menu-dialog .dialog-actions {
    display: none;
}

/* Z-index stacking */
.dialog-overlay {
    z-index: 100;
}

.drawer-overlay {
    z-index: 100;
}

.drawer {
    z-index: 101;
}

.fab {
    z-index: 11;
}

.bottom-nav {
    z-index: 10;
}

.app-bar {
    z-index: 10;
}

#more-menu-dialog-overlay {
    z-index: 102;
}

#more-menu-dialog {
    z-index: 103;
}

.search-results-container {
    z-index: 105;
}

.dialog-search-results {
    z-index: 106;
}

/* Focus outline */
button:focus-visible,
a:focus-visible,
input:focus-visible,
textarea:focus-visible,
[tabindex]:not([tabindex="-1"]):focus-visible,
select:focus-visible {
    outline: 2px solid var(--m3-sys-color-primary);
    outline-offset: 2px;
    border-radius: 4px;
}

.map-control-button:focus-visible {
    box-shadow: 0 0 0 2px var(--m3-sys-color-primary);
    outline: none;
}

/* Spinner */
.spinner {
    border: 4px solid var(--m3-sys-color-surface-variant);
    border-top: 4px solid var(--m3-sys-color-primary);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }

    100% {
        transform: rotate(360deg);
    }
}

/* History Popups */
.leaflet-popup-content {
    font-family: var(--font-family);
    line-height: 1.6;
    color: var(--m3-sys-color-on-surface);
}

.leaflet-popup-content .material-symbols-outlined {
    font-size: 18px;
    vertical-align: bottom;
    margin-right: 8px;
    opacity: 0.6;
    color: var(--m3-sys-color-on-surface-variant);
}

.leaflet-popup-content strong {
    font-weight: var(--title-small-weight);
    display: inline-block;
    margin-bottom: 4px;
}

.leaflet-popup-content a {
    color: var(--m3-sys-color-primary);
    text-decoration: none;
}

.leaflet-popup-content a:hover {
    text-decoration: underline;
}

/* .leaflet-popup-tip { background: var(--m3-sys-color-surface-container-high); } */

.history-popup-table {
    width: 100%;
    border-collapse: collapse;
    font-size: var(--body-small-size);
    max-width: 280px;
    margin: -5px 0;
}

.history-popup-table td {
    padding: 3px 5px;
    vertical-align: top;
}

.history-popup-table td:first-child {
    text-align: center;
    width: 24px;
}

.history-popup-table .material-symbols-outlined {
    font-size: 15px;
    vertical-align: middle;
    opacity: 0.7;
    margin-right: 6px;
    margin-top: -2px;
}

.history-popup-table td[colspan="2"] {
    display: flex;
    align-items: center;
}

.history-popup-table td[colspan="2"] span[style*="display:inline-block"] {
    flex-shrink: 0;
}

/* Visibility toggle */
.shared-device {
    align-items: center;
}

.device-visibility-toggle {
    margin-left: 8px;
    margin-right: 4px;
    flex-shrink: 0;
}

/* Notification status */
#notification-status-container {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 8px;
}

#notification-status {
    font-size: var(--body-small-size);
    opacity: 0.7;
    text-align: right;
    flex-grow: 1;
    color: var(--m3-sys-color-on-surface-variant);
}

#unsubscribe-button {
    font-size: var(--label-medium-size);
    padding: 6px 12px;
    min-width: auto;
}

/* Leaflet z-index */
.leaflet-control-container {
    z-index: 2;
}

.leaflet-pane {
    z-index: 1;
}

/* Geofence list item */
.geofence-list-item {
    display: flex;
    align-items: center;
    padding: 12px;
    border-radius: 12px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
}

.geofence-list-item:last-child {
    border-bottom: none;
}

.geofence-list-item:hover,
.geofence-list-item:focus-visible {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 4%, transparent);
    outline: none;
}

.geofence-list-item:focus-visible,
#global-geofences-list .settings-item:focus-visible {
    outline: 2px solid var(--m3-sys-color-primary);
    outline-offset: 2px;
    border-radius: 4px;
}

.geofence-list-item .geofence-info,
.geofence-link-info {
    flex-grow: 1;
    margin-right: 16px;
    overflow: hidden;
}

.geofence-list-item .geofence-name,
.geofence-link-name {
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    font-weight: 500;
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.geofence-list-item .geofence-details,
.geofence-link-details {
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-on-surface-variant);
    opacity: 0.8;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Geofence Page List Actions */
#global-geofences-list .settings-item .geofence-edit,
#global-geofences-list .settings-item .geofence-remove {
    color: var(--m3-sys-color-on-surface-variant);
    opacity: 0.6;
    padding: 4px;
    margin-left: 8px;
    cursor: pointer;
    border-radius: 50%;
    transition: background-color 0.2s, opacity 0.2s;
}

#global-geofences-list .settings-item .geofence-edit:hover,
#global-geofences-list .settings-item .geofence-remove:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 8%, transparent);
    opacity: 0.8;
}

#global-geofences-list .settings-item .geofence-remove {
    color: var(--m3-sys-color-error);
}


/* Geofence Link List Actions */
.geofence-link-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
}

.geofence-link-item:last-child {
    border-bottom: none;
}

.geofence-link-item .geofence-link-toggles {
    display: flex;
    gap: 16px;
    align-items: center;
    flex-shrink: 0;
}

.geofence-link-toggle-label {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: var(--label-small-size);
    color: var(--m3-sys-color-on-surface-variant);
    gap: 2px;
    cursor: pointer;
}

.geofence-link-toggle-label input {
    accent-color: var(--m3-sys-color-primary);
    cursor: pointer;
    width: 16px;
    height: 16px;
}

.geofence-link-item .geofence-remove {
    margin-left: 8px;
    cursor: pointer;
    opacity: 0.6;
    color: var(--m3-sys-color-error);
    font-size: 22px;
    transition: opacity 0.2s;
}

.geofence-link-item .geofence-remove:hover {
    opacity: 1;
}

/* Leaflet Geofence Styles */
.geofence-circle {
    stroke-dasharray: 5, 5;
    stroke: var(--m3-sys-color-secondary);
    fill: var(--m3-sys-color-secondary);
    fill-opacity: 0.05;
    pointer-events: none;
}

.geofence-tooltip {
    background-color: var(--m3-sys-color-inverse-surface);
    border: 1px solid var(--m3-sys-color-outline);
    border-radius: 4px;
    padding: 2px 6px;
    font-size: var(--label-small-size);
    white-space: nowrap;
    color: var(--m3-sys-color-inverse-on-surface);
}

/* Geofence Page Styles */
.device-geofence-card .card-title {
    margin-bottom: 16px;
    display: flex;
    align-items: center;
}

.device-geofence-card .card-title svg {
    width: 36px;
    height: 36px;
    flex-shrink: 0;
}

.add-geofence-button .material-icons {
    font-size: 18px;
    vertical-align: bottom;
    margin-right: 4px;
}

.geofence-list {
    margin-top: 16px;
    border-top: 1px solid var(--m3-sys-color-outline-variant);
    padding-top: 16px;
}

.geofence-icon {
    color: var(--m3-sys-color-secondary);
    margin-right: 24px;
    opacity: 0.6;
}

.no-geofences-message {
    padding: 16px 8px;
    text-align: center;
    color: var(--m3-sys-color-on-surface-variant);
    font-style: italic;
    font-size: var(--body-medium-size);
}

/* Geofence Dialog Map Specifics */
#geofence-picker-map {
    position: relative;
    overflow: hidden;
}

#geofence-dialog .dialog-content #geofence-picker-map {
    height: 250px;
    margin-bottom: 16px;
    border-radius: 12px;
    background-color: var(--m3-sys-color-surface-container);
}

#geofence-dialog .map-dialog-controls {
    position: absolute;
    right: 8px;
    bottom: 8px;
    z-index: 1001;
}

#geofence-dialog .settings-item input[type="text"],
#geofence-dialog .settings-item input[type="number"] {
    width: 100%;
    margin-top: 8px;
    margin-left: 0;
}

#geofence-dialog .settings-item>div[style*="display: flex"] {
    width: 100%;
}

/* Dialog search bar */
.dialog-search-bar {
    display: flex;
    align-items: center;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 100px;
    padding: 6px 12px;
    margin-bottom: 12px;
    transition: background-color 0.3s;
}

.dialog-search-icon {
    color: var(--m3-sys-color-on-surface-variant);
    margin-right: 8px;
    opacity: 0.6;
    font-size: 18px;
    transition: color 0.3s, opacity 0.3s;
}

.dialog-search-input {
    border: none;
    background-color: transparent;
    flex-grow: 1;
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    outline: none;
    transition: color 0.3s;
}

.dialog-search-input::placeholder {
    color: var(--m3-sys-color-on-surface-variant);
    opacity: 0.8;
}

.dialog-search-error {
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-error);
    margin-left: 12px;
    margin-top: -8px;
    margin-bottom: 8px;
    display: none;
}

/* File Input Styles */
.hidden-file-input {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}

#selected-files-list,
#selected-import-file-list {
    margin-top: 12px;
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-on-surface-variant);
}

#selected-files-list ul {
    list-style: none;
    padding-left: 0;
    margin-top: 4px;
}

#selected-files-list li {
    margin-bottom: 4px;
    padding: 4px 8px;
    background-color: var(--m3-sys-color-surface-container);
    border-radius: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 90%;
}

#geofence-picker-search-results {
    top: 15%;
}

#search-results-container {
    top: 80%
}

/* Search Results Styles */
.search-results-container {
    position: absolute;
    width: 90%;
    max-width: 500px;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 16px;
    box-shadow: 0 4px 12px rgba(var(--m3-sys-color-shadow), 0.1);
    z-index: 105;
    max-height: 40vh;
    overflow-y: auto;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease-out;
}

.search-results-container.show {
    display: block;
    opacity: 1;
}

.search-result-category {
    padding: 12px 16px 8px 16px;
    font-size: var(--label-small-size);
    font-weight: var(--label-small-weight);
    color: var(--m3-sys-color-outline);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
}

.search-result-item {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    cursor: pointer;
    transition: background-color 0.2s;
    text-decoration: none;
    color: inherit;
}

.search-result-item:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 4%, transparent);
}

.search-result-icon {
    width: 24px;
    height: 24px;
    margin-right: 16px;
    opacity: 0.6;
    font-size: 24px;
    color: var(--m3-sys-color-on-surface-variant);
    flex-shrink: 0;
}

.search-result-text {
    flex-grow: 1;
    overflow: hidden;
}

.search-result-title {
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.search-result-description {
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-on-surface-variant);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.search-result-item .no-results {
    font-style: italic;
    opacity: 0.7;
    width: 100%;
    text-align: center;
    color: var(--m3-sys-color-on-surface-variant);
}

/* Dialog Search Results */
.dialog-search-results {
    position: absolute;
    /* top: auto; */
    left: 5%;
    right: 5%;
    width: auto;
    max-width: none;
    background-color: var(--m3-sys-color-surface-container-high);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(var(--m3-sys-color-shadow), 0.1);
    z-index: 106;
    max-height: 25vh;
    overflow-y: auto;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease-out;
}

.dialog-search-results.show {
    display: block;
    opacity: 1;
}

.dialog-search-results .search-result-item {
    padding: 10px 16px;
}

.dialog-search-results .search-result-icon {
    font-size: 20px;
    margin-right: 12px;
}

.dialog-search-results .search-result-title {
    font-size: var(--body-medium-size);
}

.dialog-search-results .search-result-description {
    font-size: var(--body-small-size);
}

.dialog-search-results .no-results {
    padding: 10px 16px;
    text-align: left;
}

/* Import/Export Styles */
#settings-import-export .settings-item {
    align-items: center;
}

#settings-import-export .button {
    margin-left: auto;
    padding: 8px 16px;
}

#settings-import-export .button .material-icons {
    font-size: 18px;
    vertical-align: bottom;
    margin-right: 4px;
}

#import-parts-selection,
#export-parts-selection {
    padding: 16px;
    border: 1px solid var(--m3-sys-color-outline-variant);
    border-radius: 12px;
    margin-top: 16px;
    background-color: var(--m3-sys-color-surface-container);
}

#import-parts-selection h4,
#export-parts-selection h4 {
    margin-bottom: 12px;
    font-size: var(--label-large-size);
    color: var(--m3-sys-color-outline);
}

#import-parts-selection label,
#export-parts-selection label {
    display: block;
    margin-bottom: 8px;
    cursor: pointer;
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
}

#import-parts-selection input[type="checkbox"],
#export-parts-selection input[type="checkbox"] {
    margin-right: 8px;
    accent-color: var(--m3-sys-color-primary);
}

#import-parts-selection span,
#export-parts-selection span {
    opacity: 0.7;
    color: var(--m3-sys-color-on-surface-variant);
}

#import-status-message,
#upload-status {
    font-size: var(--body-small-size);
    margin-top: 8px;
    min-height: 1.2em;
    color: var(--m3-sys-color-on-surface-variant);
}

/* Add Device Button on Devices Page */
#shared-page .no-devices-message button {
    margin-top: 16px;
}

/* Flash Messages */
.flash-messages {
    margin-bottom: 16px;
    padding: 0 16px;
}

.flash-messages .error {
    color: var(--m3-sys-color-error);
}

.flash-messages .success,
.flash-messages .info {
    color: var(--m3-sys-color-primary);
}

.flash-messages .warning {
    color: var(--m3-sys-color-secondary);
}

/* Login/Register Card */
.login-card {
    max-width: 400px;
    width: 90%;
    padding: 32px;
    text-align: center;
}

.login-card .button {
    width: 100%;
    margin-top: 16px;
}

.login-link {
    margin-top: 20px;
    font-size: var(--body-small-size);
}

.login-link a {
    color: var(--m3-sys-color-primary);
}

.remember-me {
    display: block;
    margin-top: 16px;
    text-align: left;
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-on-surface-variant);
}

.remember-me input {
    margin-right: 4px;
    vertical-align: middle;
    accent-color: var(--m3-sys-color-primary);
}


/* Manage Creds Card */
.credential-info {
    font-size: var(--body-small-size);
    opacity: 0.7;
    margin-bottom: 8px;
    color: var(--m3-sys-color-on-surface-variant);
}

.credential-info+.settings-item {
    margin-top: 16px;
}

.back-link {
    margin-left: 16px;
    margin-bottom: 16px;
    display: inline-block;
    color: var(--m3-sys-color-primary);
    text-decoration: none;
}

.asp-info {
    margin-top: 12px;
    padding: 12px;
    border: 1px solid var(--m3-sys-color-outline-variant);
    border-radius: 8px;
    font-size: var(--body-small-size);
    background-color: var(--m3-sys-color-surface-container-low);
    color: var(--m3-sys-color-on-surface-variant);
}

.asp-info strong,
.asp-info a {
    color: var(--m3-sys-color-primary);
}

.asp-info ul {
    padding-left: 20px;
    margin-top: 4px;
}

.form-field-error {
    color: var(--m3-sys-color-error);
    font-size: var(--body-small-size);
    margin-top: 4px;
    text-align: left;
}

/* Logout Success Card */
body.logout-success {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    text-align: center;
}

.message-card {
    max-width: 450px;
    width: 90%;
    padding: 32px;
}

.message-icon {
    font-size: 48px;
    color: var(--m3-sys-color-primary);
    margin-bottom: 16px;
}

.redirect-info {
    margin-top: 20px;
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-outline);
}

.redirect-info a {
    color: var(--m3-sys-color-primary);
}

/* --- Notification History Styles --- */
#notifications-history-list .notification-item {
    display: flex;
    padding: 16px;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
    gap: 16px;
    transition: background-color 0.2s;
    border-radius: 12px;
    margin: 8px 0;
}

#notifications-history-list .notification-item:last-child {
    border-bottom: none;
}

#notifications-history-list .notification-item.unread {
    background-color: color-mix(in srgb, var(--m3-sys-color-primary) 8%, transparent);
    /* Subtle highlight */
}

#notifications-history-list .notification-item.unread .notification-title {
    font-weight: var(--title-medium-weight);
    /* Make unread titles bolder */
}


#notifications-history-list .notification-icon {
    flex-shrink: 0;
    width: 32px;
    /* Slightly smaller icon */
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    /* background-color: var(--m3-sys-color-surface-container-highest); /* Circle background */
    /* border-radius: 50%; */
    color: var(--m3-sys-color-secondary);
    /* Default icon color */
}

#notifications-history-list .notification-icon .material-icons {
    font-size: 28px;
}

/* Specific icon colors */
#notifications-history-list .notification-item[data-type="geofence"] .notification-icon {
    color: var(--m3-sys-color-tertiary);
}

#notifications-history-list .notification-item[data-type="battery"] .notification-icon {
    color: var(--m3-sys-color-error);
}

#notifications-history-list .notification-item[data-type="welcome"] .notification-icon,
#notifications-history-list .notification-item[data-type="test"] .notification-icon {
    color: var(--m3-sys-color-primary);
}

#notifications-history-list .notification-content {
    flex-grow: 1;
    overflow: hidden;
}

#notifications-history-list .notification-title {
    font-size: var(--body-large-size);
    color: var(--m3-sys-color-on-surface);
    margin-bottom: 4px;
}

#notifications-history-list .notification-body {
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface-variant);
    line-height: 1.4;
    margin-bottom: 6px;
}

#notifications-history-list .notification-timestamp {
    font-size: var(--body-small-size);
    color: var(--m3-sys-color-outline);
}

#notifications-history-list .notification-actions {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    justify-content: space-between;
    /* Space out buttons */
    gap: 8px;
    /* Add gap */
}

#notifications-history-list .notification-actions button {
    padding: 4px;
    /* Smaller padding */
    min-width: auto;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--m3-sys-color-on-surface-variant);
    opacity: 0.7;
    border-radius: 50%;
    transition: background-color 0.2s, opacity 0.2s;
}

#notifications-history-list .notification-actions button:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 8%, transparent);
    opacity: 1;
}

#notifications-history-list .notification-actions button .material-icons {
    font-size: 20px;
    /* Smaller icons */
    display: block;
    /* Ensure icon takes space */
}

#notifications-history-list .notification-actions .delete-notification-button {
    color: var(--m3-sys-color-error);
}

.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
    background: var(--m3-sys-color-surface-container-high);
    color: var(--m3-sys-color-on-surface);
    box-shadow: 0 1px 4px rgba(var(--m3-sys-color-shadow), 0.15);
    border-radius: 8px;
}


/* --- START: Share Styles --- */

/* Share Indicator Icon in Device List */
.share-indicator {
    font-size: 16px;
    vertical-align: middle;
    margin-left: 4px;
    opacity: 0.7;
    color: var(--m3-sys-color-secondary);
    /* Or choose another suitable color */
    transition: color 0.3s, opacity 0.3s;
}

/* Share Device Dialog - Specific styles if needed */

#share-device-dialog .dialog-search-input,
/* Reuse style */
#edit-share-dialog .dialog-search-input,
#edit-share-dialog select#edit-share-duration-select {
    /* Style select like input */
    width: 100%;
    box-sizing: border-box;
    padding: 12px;
    margin-bottom: 0;
    border: 1px solid var(--m3-sys-color-outline);
    border-radius: 8px;
    font-size: var(--body-medium-size);
    color: var(--m3-sys-color-on-surface);
    background-color: var(--m3-sys-color-surface);
    outline: none;
    transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s;
    font-family: var(--font-family);
}

#share-device-dialog .dialog-search-input:focus-visible,
#edit-share-dialog .dialog-search-input:focus-visible,
#edit-share-dialog select#edit-share-duration-select:focus-visible {
    border-color: var(--m3-sys-color-primary);
    box-shadow: 0 0 0 1px var(--m3-sys-color-primary);
}

#edit-share-dialog p[style*="opacity: 0.7"] {
    /* Target sub-description text */
    margin-top: 4px;
}



/* Share Link Dialog */
#share-link-textarea {
    width: 100%;
    min-height: 60px;
    margin-top: 16px;
    font-family: monospace;
    font-size: 14px;
    padding: 8px;
    box-sizing: border-box;
    border: 1px solid var(--m3-sys-color-outline-variant);
    border-radius: 8px;
    background-color: var(--m3-sys-color-surface-container);
    color: var(--m3-sys-color-on-surface);
    resize: none;
    outline: none;
}

#share-link-textarea:focus-visible {
    border-color: var(--m3-sys-color-primary);
    box-shadow: 0 0 0 1px var(--m3-sys-color-primary);
}

#share-link-expiry-info {
    font-size: var(--body-small-size);
    opacity: 0.7;
    margin-top: 4px;
    color: var(--m3-sys-color-on-surface-variant);
}

#copy-share-link-button .material-icons {
    font-size: 18px;
    vertical-align: bottom;
    margin-right: 4px;
}

/* Active Shares List in Settings */
#settings-shares .settings-item.share-item {
    align-items: flex-start;
    border-bottom: 1px solid var(--m3-sys-color-outline-variant);
    padding: 16px 12px;
    /* Adjust padding */
    margin-bottom: 0;
    border-radius: 0;
    background-color: transparent;
    /* Make it blend more */
    box-shadow: none;
}


#settings-shares .settings-item .settings-item-text {
    margin-right: 8px;
}

#settings-shares .settings-item.share-item:last-child {
    border-bottom: none;
}


#settings-shares .share-details {
    font-size: 0.8rem;
}

#settings-shares .share-expiry.inactive {
    color: var(--m3-sys-color-outline);
    font-style: italic;
}

#settings-shares .share-expiry.expired {
    color: var(--m3-sys-color-error);
    font-weight: 500;
}

#settings-shares .share-link-display {
    margin-top: 4px;
    font-size: 0.8rem;
    word-break: break-all;
}

#settings-shares .share-link-display a {
    color: var(--m3-sys-color-primary);
    text-decoration: none;
}

#settings-shares .share-link-display a:hover {
    text-decoration: underline;
}

#settings-shares .share-note {
    font-size: 0.8rem;
    font-style: italic;
    color: var(--m3-sys-color-on-surface-variant);
    margin-top: 4px;
}

#settings-shares .revoke-share-button {
    margin-left: auto;
    color: var(--m3-sys-color-error);
    padding: 6px;
    /* Make tap target reasonable */
    min-width: auto;
    /* Override text-button min-width */
    flex-shrink: 0;
    /* Prevent shrinking */
    opacity: 0.7;
}

#settings-shares .share-status-icon {
    /* Icon indicating status */
    margin-right: 16px;
    opacity: 0.7;
    color: var(--m3-sys-color-secondary);
    /* Default greyish */
}

#settings-shares .share-status-icon.inactive {
    color: var(--m3-sys-color-outline);
    /* More muted for inactive */
    opacity: 0.5;
}

#settings-shares .share-status-icon.expired {
    color: var(--m3-sys-color-error);
    /* Error color for expired */
    opacity: 0.6;
}



#settings-shares .revoke-share-button:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-error) 8%, transparent);
    opacity: 1;
}

#settings-shares .revoke-share-button .material-icons {
    font-size: 20px;
    display: block;
}


#settings-shares .share-item-actions {
    display: flex;
    align-items: center;
    /* Align buttons vertically */
    gap: 0px;
    /* Reduce gap */
    margin-left: auto;
    flex-shrink: 0;
}

#settings-shares .share-item-actions button {
    padding: 6px;
    /* Smaller tap target */
    min-width: auto;
    opacity: 0.7;
    transition: background-color 0.2s, opacity 0.2s;
}

#settings-shares .share-item-actions button:hover {
    opacity: 1;
    background-color: color-mix(in srgb, var(--m3-sys-color-on-surface) 8%, transparent);
}

#settings-shares .share-item-actions button.revoke-share-button {
    color: var(--m3-sys-color-error);
}

#settings-shares .share-item-actions button.revoke-share-button:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-error) 8%, transparent);
}

#settings-shares .share-item-actions button.toggle-share-button.resume-share-button {
    color: var(--m3-sys-color-primary);
}

/* Color for resume */
#settings-shares .share-item-actions button.toggle-share-button.resume-share-button:hover {
    background-color: color-mix(in srgb, var(--m3-sys-color-primary) 8%, transparent);
}

#settings-shares .share-item-actions button.toggle-share-button.suspend-share-button {
    color: var(--m3-sys-color-on-surface-variant);
}

/* Default color for suspend */

#settings-shares .share-item-actions .material-icons {
    font-size: 20px;
    display: block;
}

/* Style inactive/expired items */
#settings-shares .share-item.share-inactive .settings-item-title,
#settings-shares .share-item.share-expired .settings-item-title,
#settings-shares .share-item.share-inactive .share-details,
#settings-shares .share-item.share-expired .share-details,
#settings-shares .share-item.share-inactive .share-link-display a,
#settings-shares .share-item.share-expired .share-link-display a {
    text-decoration: line-through;
    opacity: 0.6;
    color: var(--m3-sys-color-outline);
}

#settings-shares .share-item.share-inactive .share-link-display button,
#settings-shares .share-item.share-expired .share-link-display button {
    display: none;
    /* Hide copy button for inactive/expired */
}

#settings-shares .share-item.share-expired .edit-share-button,
#settings-shares .share-item.share-expired .toggle-share-button {
    display: none;
    /* Hide edit/toggle for expired */
}

/* Copy button in list */
.copy-share-button-list {
    padding: 2px 4px !important;
    /* Smaller */
    margin-left: 4px !important;
    min-width: auto !important;
    vertical-align: middle;
    opacity: 0.6;
}

.copy-share-button-list:hover {
    opacity: 1;
}

/* Share Device/Edit Share Dialogs */
#share-device-dialog .settings-item,
#edit-share-dialog .settings-item {
    padding: 12px 0;
    margin-bottom: 8px;
    background: none;
    box-shadow: none;
}


#share-device-dialog .settings-section-title,
#edit-share-dialog .settings-section-title {
    padding: 0;
    margin-bottom: 8px;
}

/* --- END: Share Styles --- */
// --------------------
// app\static\fonts\flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2
[Binary or unreadable file]

// --------------------
// app\static\fonts\kJEhBvYX7BgnkSrUwT8OhrdQw4oELdPIeeII9v6oFsI.woff2
[Binary or unreadable file]

// --------------------
// app\static\icons\favicon.svg
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev/svgjs" width="1000" height="1000"><style>
    #light-icon {
      display: inline;
    }
    #dark-icon {
      display: none;
    }

    @media (prefers-color-scheme: dark) {
      #light-icon {
        display: none;
      }
      #dark-icon {
        display: inline;
      }
    }
  </style><g id="light-icon"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev/svgjs" width="1000" height="1000"><g clip-path="url(#SvgjsClipPath1084)"><rect width="1000" height="1000" fill="#ffffff"></rect><g transform="matrix(1.25,0,0,1.25,0,0)"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev/svgjs" width="800px" height="800px"><svg width="800px" height="800px" viewBox="0 0 192 192" xmlns="http://www.w3.org/2000/svg" fill="none">
    <path stroke="#000000" stroke-linejoin="round" stroke-width="12" d="M96 22c-16.89 0-33.782 6.437-46.67 19.31-25.773 25.746-25.773 67.489 0 93.235 7.114 7.105 13.336 10.905 19.99 14.968l.002.001.002.001C76.974 154.187 85.196 159.208 96 170c10.804-10.792 19.027-15.813 26.676-20.485h.002c6.655-4.065 12.878-7.865 19.992-14.97 25.773-25.747 25.773-67.489 0-93.235C129.782 28.437 112.891 22 96 22Z" clip-rule="evenodd"></path>
    <path stroke="#000000" stroke-linecap="round" stroke-width="12" d="M74 118V58a4 4 0 0 1 4-4h36a4 4 0 0 1 4 4v60a4 4 0 0 1-4 4H78a4 4 0 0 1-4-4Z"></path>
</svg></svg></g></g><defs><clipPath id="SvgjsClipPath1084"><rect width="1000" height="1000" x="0" y="0" rx="500" ry="500"></rect></clipPath></defs></svg></g><g id="dark-icon"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev/svgjs" width="1000" height="1000"><g><g transform="matrix(1.25,0,0,1.25,0,0)" style="filter: invert(100%)"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev/svgjs" width="800px" height="800px"><svg width="800px" height="800px" viewBox="0 0 192 192" xmlns="http://www.w3.org/2000/svg" fill="none">
    <path stroke="#000000" stroke-linejoin="round" stroke-width="12" d="M96 22c-16.89 0-33.782 6.437-46.67 19.31-25.773 25.746-25.773 67.489 0 93.235 7.114 7.105 13.336 10.905 19.99 14.968l.002.001.002.001C76.974 154.187 85.196 159.208 96 170c10.804-10.792 19.027-15.813 26.676-20.485h.002c6.655-4.065 12.878-7.865 19.992-14.97 25.773-25.747 25.773-67.489 0-93.235C129.782 28.437 112.891 22 96 22Z" clip-rule="evenodd"></path>
    <path stroke="#000000" stroke-linecap="round" stroke-width="12" d="M74 118V58a4 4 0 0 1 4-4h36a4 4 0 0 1 4 4v60a4 4 0 0 1-4 4H78a4 4 0 0 1-4-4Z"></path>
</svg></svg></g></g></svg></g></svg>
// --------------------
// app\static\icons\icon.svg
<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo
Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 192 192" xmlns="http://www.w3.org/2000/svg"
    fill="none">
    <path stroke="#000000" stroke-linejoin="round" stroke-width="12"
        d="M96 22c-16.89 0-33.782 6.437-46.67 19.31-25.773 25.746-25.773 67.489 0 93.235 7.114 7.105 13.336 10.905 19.99 14.968l.002.001.002.001C76.974 154.187 85.196 159.208 96 170c10.804-10.792 19.027-15.813 26.676-20.485h.002c6.655-4.065 12.878-7.865 19.992-14.97 25.773-25.747 25.773-67.489 0-93.235C129.782 28.437 112.891 22 96 22Z"
        clip-rule="evenodd" />
    <path stroke="#000000" stroke-linecap="round" stroke-width="12"
        d="M74 118V58a4 4 0 0 1 4-4h36a4 4 0 0 1 4 4v60a4 4 0 0 1-4 4H78a4 4 0 0 1-4-4Z" />
</svg>
// --------------------
// app\static\js\api.js
// app/static/js/api.js

window.AppApi = {
    /** Base fetch function with error handling */
    _fetch: async function (url, options = {}) {
        console.log(`API Call: ${options.method || 'GET'} ${url}`, options.body ? (typeof options.body === 'string' ? 'JSON body' : 'FormData/Other body') : '');
        try {
            const defaultHeaders = {
                'Accept': 'application/json',
                ...(options.headers || {}), // Keep existing headers
            };

            // Set Content-Type for JSON, omit for FormData (browser sets it with boundary)
            if (options.body && typeof options.body === 'string') {
                defaultHeaders['Content-Type'] = 'application/json';
            }

            // --- START: CSRF Token Handling ---
            const method = options.method?.toUpperCase() || 'GET';
            if (method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS') {
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
                if (csrfToken) {
                    defaultHeaders['X-CSRFToken'] = csrfToken; // Flask-WTF default header name
                    console.log("[API] Adding X-CSRFToken header.");
                } else {
                    console.warn("[API] CSRF meta tag not found. POST/PUT/DELETE requests might fail.");
                    // Optional: Throw an error here if CSRF is critical for all POSTs
                    // throw new Error("CSRF token is missing. Cannot proceed with the request.");
                }
            }
            // --- END: CSRF Token Handling ---

            const response = await fetch(url, {
                ...options,
                headers: defaultHeaders, // Use the potentially modified headers
            });

            let data;
            const contentType = response.headers.get("content-type");
            if (contentType && contentType.includes("application/json")) {
                data = await response.json();
            } else if (!response.ok && contentType && contentType.includes("text/html")) {
                const text = await response.text();
                console.error(`API Error ${response.status}: Received HTML response from ${url}`, text.substring(0, 500));
                throw new Error(`Server error ${response.status}. Check server logs.`);
            } else {
                data = { status: response.status, statusText: response.statusText };
                if (!response.ok) { try { data.message = await response.text(); } catch (e) { /* ignore */ } }
            }

            if (!response.ok) {
                const errorMessage = data.error || data.description || data.message || data.statusText || `HTTP error ${response.status}`;
                const error = new Error(errorMessage);
                error.status = response.status;
                error.code = data.code || `HTTP_${response.status}`;
                error.data = data;
                console.error(`API Error ${error.status} (${error.code || 'N/A'}) on ${url}: ${error.message}`, error.data);
                throw error;
            }

            if (response.ok && (!contentType || !contentType.includes("application/json"))) {
                console.log(`API Response OK (${response.status}) from ${url} (Non-JSON)`);
            } else {
                console.log(`API Response OK from ${url}:`, data);
            }
            return data;
        } catch (error) {
            if (!error.status) { // Network error or CORS issue maybe
                console.error(`API Network Error on ${url}:`, error);
                error.message = `Network error or server unreachable: ${error.message}`;
                error.code = 'NETWORK_ERROR';
            }
            // Re-throw the potentially augmented error
            throw error;
        }
    },

    /** Fetch all devices and their latest status */
    fetchDevices: async function () { return await this._fetch('/api/devices'); },
    /** Fetch all global geofence definitions */
    fetchGlobalGeofences: async function () { return await this._fetch('/api/geofences'); },
    /** Update device display properties (name, label, color) */
    updateDeviceDisplay: async function (deviceId, displayData) { return await this._fetch(`/api/devices/${deviceId}`, { method: 'PUT', body: JSON.stringify(displayData), }); },
    /** Update the geofences linked to a device */
    updateDeviceGeofenceLinks: async function (deviceId, links) { return await this._fetch(`/api/devices/${deviceId}/geofence_links`, { method: 'PUT', body: JSON.stringify({ linked_geofences: links }), }); },
    /** Create a new global geofence */
    createGeofence: async function (geofenceData) { return await this._fetch('/api/geofences', { method: 'POST', body: JSON.stringify(geofenceData), }); },
    /** Update an existing global geofence */
    updateGeofence: async function (geofenceId, geofenceData) { return await this._fetch(`/api/geofences/${geofenceId}`, { method: 'PUT', body: JSON.stringify(geofenceData), }); },
    /** Delete a global geofence */
    deleteGeofence: async function (geofenceId) { return await this._fetch(`/api/geofences/${geofenceId}`, { method: 'DELETE', }); },
    /** Subscribe to push notifications */
    subscribePush: async function (subscriptionObject) { return await this._fetch('/api/subscribe', { method: 'POST', body: JSON.stringify(subscriptionObject), }); },
    /** Unsubscribe from push notifications */
    unsubscribePush: async function (endpoint) { return await this._fetch('/api/unsubscribe', { method: 'POST', body: JSON.stringify({ endpoint: endpoint }), }); },
    /** Fetch VAPID public key */
    getVapidKey: async function () { return await this._fetch('/api/vapid_public_key'); },

    // --- Config API Calls (Modified) ---
    /** Fetch a specific server-side config part */
    getConfigPart: async function (partName) {
        return await this._fetch(`/api/config/get_part/${partName}`);
    },

    /** Apply imported server-side config parts */
    applyImportedConfig: async function (partsToImport) {
        return await this._fetch('/api/config/import_apply', {
            method: 'POST',
            body: JSON.stringify({ parts: partsToImport }),
        });
    },

    // --- NEW API Calls ---
    /** Fetch user's theme preferences */
    fetchUserPreferences: async function () {
        return await this._fetch('/api/user/preferences');
    },
    /** Update user's theme preferences */
    updateUserPreferences: async function (themeMode, themeColor) {
        return await this._fetch('/api/user/preferences', {
            method: 'PUT',
            body: JSON.stringify({ theme_mode: themeMode, theme_color: themeColor }),
        });
    },


    testDeviceNotification: async function (deviceId, notificationType) {
        return await this._fetch(`/api/devices/${deviceId}/test_notification/${notificationType}`, {
            method: 'POST',
        });
    },

    // --- NEW: Notification History APIs ---
    fetchNotificationHistory: async function () {
        return await this._fetch('/api/notifications/history'); // Add limit/offset later if needed
    },
    markNotificationRead: async function (notificationId) {
        return await this._fetch(`/api/notifications/history/${notificationId}/read`, { method: 'PUT' });
    },
    markNotificationUnread: async function (notificationId) {
        return await this._fetch(`/api/notifications/history/${notificationId}/unread`, { method: 'PUT' });
    },
    deleteNotification: async function (notificationId) {
        return await this._fetch(`/api/notifications/history/${notificationId}`, { method: 'DELETE' });
    },
    deleteAllNotifications: async function () {
        return await this._fetch('/api/notifications/history', { method: 'DELETE' });
    },

    deleteDevice: async function (deviceId) {
        return await this._fetch(`/api/devices/${deviceId}`, { method: 'DELETE' });
    },

    /** Delete the current user's account */
    deleteAccount: async function () { // Add password if verification needed: (password)
        // const payload = password ? { password: password } : {};
        return await this._fetch('/api/user/delete', {
            method: 'DELETE',
            // body: password ? JSON.stringify(payload) : undefined, // Include if password needed
        });
    },

    // --- START: New Share API Calls ---
    /**
     * Creates a share link for a device.
     * @param {string} deviceId - The ID of the device to share.
     * @param {string} duration - Duration string (e.g., "1h", "24h", "7d", "indefinite").
     * @param {string} [note] - Optional note for the share.
     * @returns {Promise<object>} The created share details including share_url.
     */
    createDeviceShare: async function (deviceId, duration, note) {
        const payload = { duration: duration };
        if (note && note.trim().length > 0) payload.note = note.trim();
        return await this._fetch(`/api/devices/${deviceId}/share`, { method: 'POST', body: JSON.stringify(payload) });
    },
    fetchUserShares: async function () { return await this._fetch('/api/shares'); },
    revokeShare: async function (shareId) { return await this._fetch(`/api/shares/${shareId}`, { method: 'DELETE' }); },
    // --- START: New Share Management Functions ---
    /**
     * Toggles the active status of a share.
     * @param {string} shareId - The ID of the share.
     * @param {boolean} isActive - The desired active status (true=resume, false=suspend).
     * @returns {Promise<object>} The updated share object.
     */
    toggleShareStatus: async function (shareId, isActive) {
        return await this._fetch(`/api/shares/${shareId}/status`, {
            method: 'PUT',
            body: JSON.stringify({ active: !!isActive }) // Ensure boolean
        });
    },
    /**
     * Updates the duration and optionally the note of an existing share.
     * @param {string} shareId - The ID of the share.
     * @param {string} duration - New duration string (e.g., "1h", "indefinite").
     * @param {string|null} [note] - Optional new note (null to leave unchanged).
     * @returns {Promise<object>} The updated share object.
     */
    updateShareDuration: async function(shareId, duration, note = null) {
        const payload = { duration: duration };
        if (note !== null) { // Only include note if it's explicitly passed (even if empty string)
             payload.note = (note || "").trim();
        }
        return await this._fetch(`/api/shares/${shareId}/duration`, {
            method: 'PUT',
            body: JSON.stringify(payload)
        });
    }
    // --- END: New Share API Calls ---

    // Note: upload_device_file uses the base _fetch now, which includes CSRF
};
// --------------------
// app\static\js\app.js
// app/static/js/app.js
// FULL FILE

// --- Helper Functions (Moved from index.html) ---

// Function to dynamically import local fallback module for ES Modules
async function loadLocalModuleFallback(localPath, checkObject) {
    // Give the CDN module a moment to potentially load
    await new Promise(resolve => setTimeout(resolve, 500));

    // Check if the expected global object exists AND has expected functions
    const isUtilLoaded = window[checkObject] &&
        typeof window[checkObject].argbFromHex === 'function' &&
        typeof window[checkObject].themeFromSourceColor === 'function';

    if (!isUtilLoaded) { // Check if the required functions are present
        console.warn(`CDN module failed to define ${checkObject} correctly or is incomplete. Loading local fallback: ${localPath}`);
        try {
            // Dynamically import the local script
            const fallbackModule = await import(localPath);

            // Re-assign functions to the global object
            if (fallbackModule && typeof fallbackModule.argbFromHex === 'function') {
                // Assign based on the expected structure of material-color-utilities
                window[checkObject] = {
                    argbFromHex: fallbackModule.argbFromHex,
                    themeFromSourceColor: fallbackModule.themeFromSourceColor,
                    applyTheme: fallbackModule.applyTheme,
                    sourceColorFromImage: fallbackModule.sourceColorFromImage,
                    hexFromArgb: fallbackModule.hexFromArgb
                    // Add any other functions you might directly use from M3ColorUtils
                };
                console.log(`Successfully loaded and assigned local fallback module ${checkObject}`);
            } else {
                console.error(`Local fallback module ${localPath} loaded but had no valid exports.`);
                throw new Error(`Fallback module ${localPath} structure invalid.`);
            }

        } catch (error) {
            console.error(`Failed to load local fallback module ${checkObject} from ${localPath}:`, error);
            // Do not re-throw here, let initializeApp handle the missing M3ColorUtils
            // throw error;
        }
    } else {
        console.log(`CDN module ${checkObject} loaded successfully.`);
    }
}

// --- AppTheme definition (Moved from index.html) ---
window.AppTheme = {
    DEFAULT_SOURCE_COLOR: '#6750A4', // Default purple
    cssVariableMap: {
        // --- Keep all roles needed by your style.css ---
        primary: '--m3-sys-color-primary', onPrimary: '--m3-sys-color-on-primary', primaryContainer: '--m3-sys-color-primary-container', onPrimaryContainer: '--m3-sys-color-on-primary-container',
        secondary: '--m3-sys-color-secondary', onSecondary: '--m3-sys-color-on-secondary', secondaryContainer: '--m3-sys-color-secondary-container', onSecondaryContainer: '--m3-sys-color-on-secondary-container',
        tertiary: '--m3-sys-color-tertiary', onTertiary: '--m3-sys-color-on-tertiary', tertiaryContainer: '--m3-sys-color-tertiary-container', onTertiaryContainer: '--m3-sys-color-on-tertiary-container',
        error: '--m3-sys-color-error', onError: '--m3-sys-color-on-error', errorContainer: '--m3-sys-color-error-container', onErrorContainer: '--m3-sys-color-on-error-container',
        background: '--m3-sys-color-background', onBackground: '--m3-sys-color-on-background',
        surface: '--m3-sys-color-surface', onSurface: '--m3-sys-color-on-surface', surfaceVariant: '--m3-sys-color-surface-variant', onSurfaceVariant: '--m3-sys-color-on-surface-variant',
        outline: '--m3-sys-color-outline', outlineVariant: '--m3-sys-color-outline-variant',
        shadow: '--m3-sys-color-shadow', scrim: '--m3-sys-color-scrim',
        inverseSurface: '--m3-sys-color-inverse-surface', inverseOnSurface: '--m3-sys-color-inverse-on-surface', inversePrimary: '--m3-sys-color-inverse-primary',
        // Ensure missing surface roles are commented/removed here too if library doesn't support them
        // surfaceDim: '--m3-sys-color-surface-dim',
        // surfaceBright: '--m3-sys-color-surface-bright',
        // surfaceContainerLowest: '--m3-sys-color-surface-container-lowest',
        // surfaceContainerLow: '--m3-sys-color-surface-container-low',
        // surfaceContainer: '--m3-sys-color-surface-container',
        // surfaceContainerHigh: '--m3-sys-color-surface-container-high',
        // surfaceContainerHighest: '--m3-sys-color-surface-container-highest',
    },

    _debounce: function (func, wait) {
        let timeout;
        return (...args) => {
            const context = this;
            const later = () => {
                timeout = null;
                func.apply(context, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    _debouncedSavePreferences: null, // Initialized in setupThemeControls

    generatePalettesFromSource(hexColor) {
        // Ensure M3ColorUtils is loaded before calling this
        if (!window.M3ColorUtils) {
            console.error("M3ColorUtils not available for generatePalettesFromSource!");
            return null;
        }
        const { argbFromHex, themeFromSourceColor, hexFromArgb } = window.M3ColorUtils;

        try {
            const sourceArgb = argbFromHex(hexColor);
            const theme = themeFromSourceColor(sourceArgb);

            const extractMappedRolesToHex = (schemeObject, mode) => {
                const hexPalette = {};
                let foundCount = 0, missingCount = 0;
                // console.log(`--- [Theme Debug] Extracting ${mode} roles ---`); // Verbose
                for (const role in this.cssVariableMap) {
                    if (schemeObject[role] !== undefined && typeof schemeObject[role] === 'number') {
                        try {
                            hexPalette[role] = hexFromArgb(schemeObject[role]);
                            foundCount++;
                        } catch (e) {
                            // console.warn(`[Theme Debug] WARN: Could not convert ARGB for role "${role}"`); // Verbose
                            missingCount++;
                        }
                    } else {
                        // Only log if the role was expected in the map but missing in the scheme
                        // console.warn(`[Theme Debug] MISSING: Role "${role}" not found on ${mode} scheme.`); // Verbose
                        missingCount++;
                    }
                }
                // console.log(`--- [Theme Debug] ${mode} Extraction: Found ${foundCount}, Missing/Invalid ${missingCount} ---`); // Verbose
                return hexPalette;
            };

            const lightPaletteHex = extractMappedRolesToHex(theme.schemes.light, 'light');
            const darkPaletteHex = extractMappedRolesToHex(theme.schemes.dark, 'dark');

            return { light: lightPaletteHex, dark: darkPaletteHex };
        } catch (error) {
            console.error(`Error generating M3 palettes from ${hexColor}:`, error);
            return null;
        }
    },

    applyPaletteToCSS(palette) {
        if (!palette) { console.error("Cannot apply null palette to CSS."); return; }
        const targetStyle = document.body.style;
        let appliedCount = 0;
        for (const role in palette) {
            const cssVarName = this.cssVariableMap[role];
            if (cssVarName) { targetStyle.setProperty(cssVarName, palette[role]); appliedCount++; }
        }
        console.log(`[Theme] Applied ${appliedCount} CSS color variables to body style.`);
    },

    isDarkModeActive(themePreference) {
        if (themePreference === 'dark') return true;
        if (themePreference === 'light') return false;
        return window.matchMedia?.('(prefers-color-scheme: dark)').matches ?? false;
    },

    applyTheme(sourceHexColor, themePreference) {
        console.log(`[Theme] Applying theme: Color=${sourceHexColor}, Mode=${themePreference}`);
        const palettes = this.generatePalettesFromSource(sourceHexColor);

        if (!palettes) {
            console.error("[Theme] Failed to generate palettes. Applying default fallback.");
            const defaultPalettes = this.generatePalettesFromSource(this.DEFAULT_SOURCE_COLOR);
            if (defaultPalettes) {
                const isDarkFallback = this.isDarkModeActive(themePreference);
                this.applyPaletteToCSS(isDarkFallback ? defaultPalettes.dark : defaultPalettes.light);
                this._updateBodyAndMapTheme(isDarkFallback, defaultPalettes[isDarkFallback ? 'dark' : 'light']);
            } else { console.error("[Theme] FATAL: Could not generate even default palettes."); }
            return;
        }

        const isDark = this.isDarkModeActive(themePreference);
        const activePalette = isDark ? palettes.dark : palettes.light;
        this.applyPaletteToCSS(activePalette);
        this._updateBodyAndMapTheme(isDark, activePalette);
        console.log(`[Theme] Applied ${isDark ? 'dark' : 'light'} mode with generated palette.`);
    },

    _updateBodyAndMapTheme(isDark, activePalette) {
        const body = document.body;
        body.classList.remove('dark-theme', 'light-theme');
        body.classList.add(isDark ? 'dark-theme' : 'light-theme');

        const metaThemeColor = document.getElementById('meta-theme-color');
        if (metaThemeColor && activePalette?.surface) {
            metaThemeColor.setAttribute('content', activePalette.surface);
        }

        // Ensure AppMap and its function exist before calling
        if (window.AppMap && typeof window.AppMap.updateMapThemeStyle === 'function') {
            window.AppMap.updateMapThemeStyle(isDark);
        } else {
            console.warn("[Theme] AppMap.updateMapThemeStyle not available when updating theme.");
        }
    },

    setupThemeControls() {
        if (!this._debouncedSavePreferences) {
            this._debouncedSavePreferences = this._debounce(async (mode, color) => {
                console.log(`[Theme Debounced] Saving Prefs - Mode: ${mode}, Color: ${color}`);
                try {
                    if (window.AppApi && typeof window.AppApi.updateUserPreferences === 'function') {
                        await AppApi.updateUserPreferences(mode, color);
                        console.log("[Theme Debounced] Preferences saved to backend.");
                    } else { console.error("[Theme Debounced] AppApi.updateUserPreferences not available!"); }
                } catch (error) {
                    console.error("[Theme Debounced] Failed to save preferences to backend:", error);
                    if (window.AppUI) AppUI.showErrorDialog("Save Error", "Could not save theme preference to server.", 3000);
                }
            }, 1000);
        }

        const colorPicker = document.getElementById('theme-color-picker');
        const themeRadios = document.querySelectorAll('input[name="theme"]');
        const resetColorButton = document.getElementById('reset-theme-color-button');

        colorPicker?.addEventListener('input', (e) => {
            const newColor = e.target.value;
            AppState.userColor = newColor;
            this.applyTheme(newColor, AppState.currentTheme);
            this._debouncedSavePreferences(AppState.currentTheme, newColor);
        });

        themeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    const newMode = e.target.value;
                    // Use AppUI.setTheme which updates state and calls applyTheme
                    if (window.AppUI) AppUI.setTheme(newMode);
                    this._debouncedSavePreferences(newMode, AppState.userColor);
                }
            });
        });

        resetColorButton?.addEventListener('click', () => {
            console.log("Resetting theme color to default.");
            const defaultColor = this.DEFAULT_SOURCE_COLOR;
            AppState.userColor = defaultColor;
            if (colorPicker) colorPicker.value = defaultColor;
            this.applyTheme(defaultColor, AppState.currentTheme);
            this._debouncedSavePreferences(AppState.currentTheme, defaultColor);
        });

        // Listen for system theme changes ONLY if current preference is 'system'
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        // Remove previous listener if it exists (to prevent duplicates on hot-reload)
        if (mediaQuery._themeChangeListener) {
            mediaQuery.removeEventListener('change', mediaQuery._themeChangeListener);
        }
        // Define the new listener
        mediaQuery._themeChangeListener = (e) => {
            if (AppState.currentTheme === 'system') {
                console.log("System theme changed, re-applying theme...");
                this.applyTheme(AppState.userColor, 'system');
            }
        };
        // Add the new listener
        mediaQuery.addEventListener('change', mediaQuery._themeChangeListener);

        console.log("[Theme] Theme controls setup complete.");
    },

    initializeTheme() {
        // Ensure AppState exists and has loaded preferences
        if (!window.AppState) { console.error("[Theme Init] AppState not available!"); return; }
        // Ensure M3ColorUtils is ready before proceeding
        if (!window.M3ColorUtils) {
            console.error("[Theme Init] M3ColorUtils not available! Theme initialization failed.");
            // Apply basic fallback class based on AppState pref
            const isDarkFallback = this.isDarkModeActive(AppState.currentTheme);
            document.body.classList.remove('dark-theme', 'light-theme');
            document.body.classList.add(isDarkFallback ? 'dark-theme' : 'light-theme');
            return;
        }

        console.log(`[Theme] Initializing with Color=${AppState.userColor}, Mode=${AppState.currentTheme}`);
        const colorPicker = document.getElementById('theme-color-picker');
        if (colorPicker) colorPicker.value = AppState.userColor;
        document.querySelectorAll('input[name="theme"]').forEach(radio => { radio.checked = (radio.value === AppState.currentTheme); });

        this.applyTheme(AppState.userColor, AppState.currentTheme);
        this.setupThemeControls();
    }
};
// --- End AppTheme definition ---


// --- AppActions ---
window.AppActions = {
    refreshDevices: async function () {
        console.log("Action: Refresh Devices triggered.");
        const listContainer = document.getElementById('shared-devices-list-container');
        const listElement = document.getElementById('shared-devices-list');
        const loadingIndicator = document.getElementById('devices-loading-indicator');
        const lastUpdatedElement = document.getElementById('devices-last-updated');
        const noDevicesMessage = document.getElementById('no-devices-message');
        const errorMessageElement = document.getElementById('devices-error-message');

        if (loadingIndicator) loadingIndicator.style.display = 'block';
        if (lastUpdatedElement) lastUpdatedElement.textContent = 'Updating...';
        if (noDevicesMessage) noDevicesMessage.style.display = 'none';
        if (errorMessageElement) errorMessageElement.style.display = 'none';
        if (listElement) listElement.style.display = 'none'; // Hide list while loading

        try {
            const data = await AppApi.fetchDevices();
            // Clear currently viewed device if it no longer exists in the data
            if (AppState.currentViewedDeviceId && !data?.devices?.some(d => d.id === AppState.currentViewedDeviceId)) {
                console.log(`Currently viewed device ${AppState.currentViewedDeviceId} no longer exists. Clearing view.`);
                AppState.currentViewedDeviceId = null;
            }

            // Update local state regardless of code, API provides current snapshot
            AppState.setCurrentDeviceData(data.devices || []);
            AppUI.renderDevicesList(AppState.getCurrentDeviceData());

            // Update status text based on API response code AND error message
            let statusText = 'Last updated: Unknown'; // Default
            if (data.code === 'NO_DEVICE_FILES') {
                statusText = 'No devices configured';
            } else if (data.code === 'NO_APPLE_CREDS') {
                statusText = 'Credentials needed';
            } else if (data.fetch_errors && data.fetch_errors.includes("2FA Required")) {
                // *** Check for specific 2FA error message from cache ***
                statusText = `Update Failed: ${data.fetch_errors}`; // Display the user-friendly message
                if (window.AppUI) AppUI.showErrorDialog("Authentication Failed", `${data.fetch_errors}<br>Please update your credentials in Settings.`, 5000); // Show dialog briefly
            } else if (data.code === 'CACHE_EMPTY' || data.code === 'CACHE_EMPTY_CONFIG_RETURNED') {
                statusText = `Waiting for first fetch... (${data.fetch_errors || 'No data yet'})`;
            } else if (data.last_updated) { // OK case
                try { const d = new Date(data.last_updated); statusText = `Last updated: ${AppUtils.formatTimeRelative(d)}`; }
                catch (e) { statusText = `Last updated: ${data.last_updated}`; }
            } else if (data.fetch_errors) { // Other fetch errors
                statusText = `Update Failed: ${data.fetch_errors}`;
            }
            // *** Update the element ***
            if (lastUpdatedElement) lastUpdatedElement.textContent = statusText;

            // Refresh map/links if relevant page is visible
            if (document.getElementById('index-page')?.style.display === 'block' && window.AppMap) {
                AppMap.updateMapView();
            }
            if (document.getElementById('geofences-page')?.style.display === 'block') {
                AppUI.renderDeviceGeofenceLinks(); // Refresh links on geofence page too
            }
        } catch (error) {
            console.error("Error refreshing devices:", error);
            if (error.code !== 'NO_APPLE_CREDS' && error.status !== 401 && error.status !== 403 && !(error.message && error.message.includes("2FA Required"))) {
                if (window.AppUI) AppUI.showErrorDialog("Device Refresh Error", `Could not refresh devices.<br>Details: ${error.message} (${error.code || 'N/A'})`);
            }
            if (errorMessageElement) {
                errorMessageElement.textContent = `Error: ${error.message}`;
                errorMessageElement.style.display = 'block';
            }
            if (lastUpdatedElement) lastUpdatedElement.textContent = 'Update failed';
            // Render empty list on error (unless it was just creds missing)
            if (error.code !== 'NO_APPLE_CREDS' && error.status !== 401 && error.status !== 403 && listElement) {
                if (window.AppUI) AppUI.renderDevicesList([]);
            }
        } finally {
            if (loadingIndicator) loadingIndicator.style.display = 'none';
            // Show list element only if it has content after rendering
            if (listElement) {
                listElement.style.display = listElement.hasChildNodes() ? 'block' : 'none';
            }
        }
    },

    refreshGeofencesAndDevices: async function () {
        console.log("Action: Refreshing Geofences and Devices");
        const globalLoading = document.getElementById('global-geofences-loading');
        const linksLoading = document.getElementById('device-links-loading');
        if (globalLoading) globalLoading.style.display = 'block';
        if (linksLoading) linksLoading.style.display = 'block';
        try {
            // Fetch geofences first
            const geoData = await AppApi.fetchGlobalGeofences();
            AppState.setGlobalGeofences(geoData || []);
            AppUI.renderGlobalGeofences(); // Render global list

            // Then refresh devices (which might depend on geofences being loaded)
            await AppActions.refreshDevices(); // Await device refresh

            // Render links and map layers AFTER both are loaded
            AppUI.renderDeviceGeofenceLinks();
            if (window.AppMap) AppMap.redrawGeofenceLayer();

        } catch (error) {
            console.error("Error refreshing geofences/devices:", error);
            if (error.code !== 'NO_DEVICE_FILES' && error.code !== 'NO_APPLE_CREDS') {
                if (window.AppUI) AppUI.showErrorDialog("Data Load Error", `Could not load geofence/device data.<br>Details: ${error.message} (${error.code || 'N/A'})`);
            }
        } finally {
            if (globalLoading) globalLoading.style.display = 'none';
            if (linksLoading) linksLoading.style.display = 'none';
        }
    },

    fetchInitialData: async function () {
        console.log("Action: Fetching initial data (devices & geofences)");
        try {
            // Fetch geofences first as devices might link to them
            const geoData = await AppApi.fetchGlobalGeofences();
            AppState.setGlobalGeofences(geoData || []);
            AppUI.renderGlobalGeofences(); // Render the global list early

            // Then fetch devices
            await AppActions.refreshDevices(); // Await device refresh (renders device list)

            // Final map updates after both are available
            if (window.AppMap) {
                AppMap.redrawGeofenceLayer();
                // AppMap.updateMapView(); // updateMapView will be called by refreshDevices completion if map page active
            }
            AppUI.renderDeviceGeofenceLinks(); // Render links on geofence page if needed

        } catch (error) {
            console.error("Initial data fetch failed:", error);
            // Avoid showing error if it's just missing creds/files
            if (error.code !== 'NO_DEVICE_FILES' && error.code !== 'NO_APPLE_CREDS') {
                if (window.AppUI) AppUI.showErrorDialog("Initial Load Failed", `Could not load initial device/geofence data.<br>Details: ${error.message} (${error.code || 'N/A'})`);
            }
        }
    },

    handleRemoveDevice: async function (deviceId) {
        const device = AppState.getDeviceDisplayInfo(deviceId);
        const deviceName = device?.name || deviceId; // Use name or ID for message
        console.log(`[Action] Confirmed removal for device ${deviceId} (${deviceName})`);
        // Optional: Show a temporary "Deleting..." dialog/indicator
        AppUI.showConfirmationDialog("Deleting...", `Removing device "${deviceName}" and its data...`, null, null);
        const progressDialog = document.getElementById('confirmation-dialog');
        if (progressDialog) progressDialog.querySelector('.dialog-actions').style.display = 'none';

        try {
            const result = await AppApi.deleteDevice(deviceId);
            console.log(`[Action] Device removal API result for ${deviceId}:`, result);
            AppUI.closeDialog('confirmation-dialog'); // Close deleting dialog

            // --- Update Frontend State ---
            // Remove from main data list
            AppState.currentDeviceData = AppState.currentDeviceData.filter(d => d.id !== deviceId);
            // Remove marker
            if (AppState.deviceMarkers[deviceId]) {
                const map = AppState.getMap();
                if (map && map.hasLayer(AppState.deviceMarkers[deviceId])) {
                    map.removeLayer(AppState.deviceMarkers[deviceId]);
                }
                delete AppState.deviceMarkers[deviceId];
            }
            // Remove history layer
            AppMap.clearDeviceHistoryLayer(deviceId); // Use existing map function
            // Remove visibility setting
            if (deviceId in AppState.deviceVisibility) {
                delete AppState.deviceVisibility[deviceId];
                AppState.saveDeviceVisibilityState(); // Save the updated visibility state
            }
            // --- End Frontend State Update ---

            AppUI.showConfirmationDialog("Device Removed", result.message || `Device "${deviceName}" removed successfully.`);
            AppUI.renderDevicesList(AppState.getCurrentDeviceData()); // Re-render device list on shared page
            if (document.getElementById('geofences-page')?.style.display === 'block') {
                AppUI.renderDeviceGeofenceLinks(); // Re-render links on geofence page
            }
            if (document.getElementById('index-page')?.style.display === 'block') {
                AppMap.updateMapView(); // Update map view
            }

        } catch (error) {
            AppUI.closeDialog('confirmation-dialog'); // Close deleting dialog
            console.error("Error removing device:", error);
            AppUI.showErrorDialog("Removal Failed", `Could not remove device "${deviceName}".<br>Details: ${error.message}`);
            // Optionally trigger a full refresh if state might be inconsistent
            // AppActions.refreshDevices();
        }
    },

    handleEditDeviceSubmit: async function () {
        const id = document.getElementById('edit-device-id').value;
        const nameInput = document.getElementById('edit-device-name').value.trim();
        const label = document.getElementById('edit-device-label').value.trim();
        const color = document.getElementById('edit-device-color').value;
        if (!id) return;
        const name = nameInput || document.getElementById('edit-device-name').placeholder || id;
        const payload = { name: name, label: label || '❓', color: color };
        const saveButton = document.getElementById('save-device-edit-button');
        if (!saveButton) return;
        saveButton.disabled = true;
        saveButton.innerHTML = `<div class="spinner" style="width:18px;height:18px;border-width:2px;margin:0 auto;"></div>`;
        try {
            const updatedConfig = await AppApi.updateDeviceDisplay(id, payload);
            console.log("Save successful, updated display info:", updatedConfig);
            const dataIndex = AppState.currentDeviceData.findIndex(d => d.id === id);
            if (dataIndex > -1) {
                const existingGeofences = AppState.currentDeviceData[dataIndex].geofences || [];
                AppState.currentDeviceData[dataIndex] = { ...AppState.currentDeviceData[dataIndex], ...updatedConfig, geofences: updatedConfig.geofences || existingGeofences };
            } else {
                console.warn("Edited device not found in local data cache after save.");
                await AppActions.refreshDevices();
            }
            // Refresh UI
            if (document.getElementById('shared-page')?.style.display !== 'none') { AppUI.renderDevicesList(AppState.getCurrentDeviceData()); }
            if (document.getElementById('geofences-page')?.style.display !== 'none') { AppUI.renderDeviceGeofenceLinks(); }
            if (document.getElementById('index-page')?.style.display !== 'none' && window.AppMap) { AppMap.updateMapView(); }
            AppUI.closeDialog('edit-device-dialog');
            AppUI.showConfirmationDialog("Device Updated", `Display settings for "${updatedConfig.name}" saved.`);
        } catch (error) {
            console.error("Error saving device config:", error);
            if (window.AppUI) AppUI.showErrorDialog("Save Failed", `Could not save settings.<br>Details: ${error.message}`);
        } finally {
            if (saveButton) { saveButton.disabled = false; saveButton.innerHTML = 'Save Display Info'; }
        }
    },

    handleGeofenceDialogSubmit: async function () {
        const editId = document.getElementById('geofence-edit-id').value;
        const isEditing = !!editId;
        const name = document.getElementById('geofence-name').value.trim();
        const radius = parseFloat(document.getElementById('geofence-radius').value);
        const lat = parseFloat(document.getElementById('geofence-lat').value);
        const lng = parseFloat(document.getElementById('geofence-lng').value);

        if (!name) { if (window.AppUI) AppUI.showErrorDialog("Input Required", "Geofence name cannot be empty."); return; }
        if (isNaN(lat) || isNaN(lng)) { if (window.AppUI) AppUI.showErrorDialog("Input Required", "Please select a location on the map."); return; }
        if (isNaN(radius) || radius <= 0) { if (window.AppUI) AppUI.showErrorDialog("Input Required", "Please enter a valid positive radius."); return; }

        const geofenceData = { name, lat, lng, radius };
        const saveButton = document.getElementById('geofence-dialog-save-button');
        if (!saveButton) return;
        saveButton.disabled = true;
        saveButton.innerHTML = `<div class="spinner" style="width:18px;height:18px;border-width:2px;margin:0 auto;"></div>`;

        try {
            let savedGeofence;
            if (isEditing) {
                savedGeofence = await AppApi.updateGeofence(editId, geofenceData);
                const index = AppState.globalGeofenceData.findIndex(gf => gf.id === editId);
                if (index > -1) AppState.globalGeofenceData[index] = savedGeofence;
                else AppState.globalGeofenceData.push(savedGeofence);
            } else {
                savedGeofence = await AppApi.createGeofence(geofenceData);
                AppState.globalGeofenceData.push(savedGeofence);
            }
            AppState.globalGeofenceData.sort((a, b) => a.name.localeCompare(b.name));
            console.log(`Global geofence ${isEditing ? 'updated' : 'created'} successfully.`);

            AppUI.renderGlobalGeofences();
            AppUI.renderDeviceGeofenceLinks();
            if (window.AppMap) AppMap.redrawGeofenceLayer();

            AppUI.closeDialog('geofence-dialog');
            AppUI.showConfirmationDialog(`Geofence ${isEditing ? 'Updated' : 'Created'}`, `Geofence "${savedGeofence.name}" saved.`);
        } catch (error) {
            console.error(`Error ${isEditing ? 'updating' : 'creating'} geofence:`, error);
            if (error.status === 409) { if (window.AppUI) AppUI.showErrorDialog("Name Conflict", error.message || "A geofence with this name already exists."); }
            else { if (window.AppUI) AppUI.showErrorDialog("Save Failed", `Could not save geofence.<br>Details: ${error.message}`); }
        } finally {
            if (saveButton) { saveButton.disabled = false; saveButton.innerHTML = `Save Geofence`; }
        }
    },

    handleRemoveGlobalGeofence: async function (geofenceId) {
        const geofenceToRemove = AppState.globalGeofenceData.find(gf => gf.id === geofenceId);
        if (!geofenceToRemove) { if (window.AppUI) AppUI.showErrorDialog("Error", "Geofence not found in local data."); return; }
        console.log(`Confirmed removal for ${geofenceId}`);
        try {
            const result = await AppApi.deleteGeofence(geofenceId);
            AppState.globalGeofenceData = AppState.globalGeofenceData.filter(gf => gf.id !== geofenceId);
            console.log(`Global geofence "${geofenceToRemove.name}" removed successfully.`);
            if (window.AppUI) AppUI.showConfirmationDialog("Geofence Removed", result.message || `Geofence "${geofenceToRemove.name}" removed.`);

            AppUI.renderGlobalGeofences();
            if (window.AppMap) AppMap.redrawGeofenceLayer();
            AppActions.refreshDevices().then(() => {
                if (document.getElementById('geofences-page')?.style.display === 'block') {
                    AppUI.renderDeviceGeofenceLinks();
                }
            });
        } catch (error) {
            console.error("Error removing global geofence:", error);
            if (window.AppUI) AppUI.showErrorDialog("Removal Failed", `Could not remove geofence.<br>Details: ${error.message}`);
        }
    },

    handleSaveDeviceGeofenceLinks: async function (deviceId, cardElement) {
        const saveButton = cardElement.querySelector('.save-links-button');
        if (!saveButton) return;
        saveButton.disabled = true;
        saveButton.innerHTML = `<div class="spinner" style="width: 18px; height: 18px; border-width: 2px; margin: 0 auto;"></div>`;

        const linkItems = cardElement.querySelectorAll('.geofence-link-item');
        const updatedLinksPayload = Array.from(linkItems).map(item => {
            const gfId = item.dataset.geofenceId;
            const notifyEntryInput = item.querySelector('input[data-notify-type="entry"]');
            const notifyExitInput = item.querySelector('input[data-notify-type="exit"]');
            return { id: gfId, notify_entry: notifyEntryInput?.checked ?? false, notify_exit: notifyExitInput?.checked ?? false };
        });

        const deviceName = AppState.getDeviceDisplayInfo(deviceId).name;

        try {
            const responseData = await AppApi.updateDeviceGeofenceLinks(deviceId, updatedLinksPayload);
            const dataIndex = AppState.currentDeviceData.findIndex(d => d.id === deviceId);
            if (dataIndex > -1) {
                AppState.currentDeviceData[dataIndex].geofences = responseData.linked_geofences || [];
            } else { console.warn(`Device ${deviceId} not found in cache after saving links.`); }
            console.log("Device links saved successfully.");
            if (window.AppUI) AppUI.showConfirmationDialog("Links Saved", `Geofence links and notifications for ${deviceName} saved.`);
            saveButton.style.display = 'none';
            AppUI.renderAddGeofenceDropdown(cardElement, deviceId);
            if (document.getElementById('index-page')?.style.display !== 'none' && window.AppMap) { AppMap.redrawGeofenceLayer(); }
        } catch (error) {
            console.error("Error saving device links:", error);
            if (window.AppUI) AppUI.showErrorDialog("Save Failed", `Could not save geofence links.<br>Details: ${error.message}`);
        } finally {
            if (saveButton) { saveButton.disabled = false; saveButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Save Changes`; }
        }
    },

    _debouncedSearchHandler: null, // Holder for debounced function

    performSearch: async function (query) { // Main app bar search
        if (query.length < 2) { AppUI.renderSearchResults([], 'search-results-container'); AppUI.hideSearchResults('search-results-container'); return; }
        console.log("Performing search for:", query); let results = []; const lowerQuery = query.toLowerCase();
        const appActions = [
            { type: 'action', target: 'settings', name: 'Settings', keywords: ['settings', 'theme', 'history', 'map defaults', 'config'], icon: 'settings' },
            { type: 'action', target: 'geofences', name: 'Geofences', keywords: ['geofence', 'fence', 'area', 'zone', 'boundary'], icon: 'radar' },
            { type: 'action', target: 'shared', name: 'Devices', keywords: ['device', 'item', 'accessory', 'shared', 'list'], icon: 'devices' },
            { type: 'action', target: 'places', name: 'Saved Places', keywords: ['place', 'saved', 'favorite', 'star'], icon: 'star_outline' },
            { type: 'action', target: 'history', name: 'Location History', keywords: ['history', 'timeline', 'past'], icon: 'history' },
            { type: 'action', target: 'notifications-history', name: 'Notification History', keywords: ['notification', 'alert', 'message'], icon: 'history_toggle_off' }, // Added History
            { type: 'action', target: 'dialog:help-dialog', name: 'Help & Feedback', keywords: ['help', 'info', 'guide', 'feedback'], icon: 'help_outline' },
            { type: 'action', target: 'manage_apple_creds', name: 'Manage Apple Credentials', keywords: ['apple', 'credential', 'password', 'account', 'login'], icon: 'security' },
            { type: 'action', target: 'settings', section: 'settings-upload-section', name: 'Upload Device Files', keywords: ['upload', 'file', 'key', 'plist', 'add device'], icon: 'upload_file' },
            { type: 'action', target: 'settings', section: 'settings-import-export', name: 'Import/Export Config (Backup)', keywords: ['import', 'export', 'config', 'backup', 'restore', 'setting'], icon: 'import_export' },
            { type: 'action', target: 'index', name: 'Map View', keywords: ['map', 'view', 'overview'], icon: 'map' },
            { type: 'action', target: 'settings', section: 'settings-notifications', name: 'Notifications (Settings)', keywords: ['notifications'], icon: 'notifications' },
            { type: 'action', target: 'settings', section: 'settings-account-management', name: 'Delete Account', keywords: ['delete', 'remove', 'account', 'danger'], icon: 'delete_forever' },
        ];
        appActions.forEach(action => { if (action.name.toLowerCase().includes(lowerQuery) || action.keywords.some(k => k.includes(lowerQuery))) { results.push({ ...action, description: action.description || `Go to ${action.name}` }); } });
        AppState.getCurrentDeviceData().forEach(device => { const displayInfo = AppState.getDeviceDisplayInfo(device.id); if (displayInfo.name.toLowerCase().includes(lowerQuery) || device.id.toLowerCase().includes(lowerQuery)) { results.push({ type: 'device', id: device.id, name: displayInfo.name, description: displayInfo.status || 'Device', icon: 'devices', svg_icon: displayInfo.svg_icon }); } });
        AppState.savedPlaces.forEach((place, index) => { if (place.name.toLowerCase().includes(lowerQuery) || (place.description && place.description.toLowerCase().includes(lowerQuery))) { results.push({ type: 'place', placeIndex: index, name: place.name, description: place.description || 'Saved Place', icon: 'star' }); } });
        AppState.getGlobalGeofences().forEach(gf => { if (gf.name.toLowerCase().includes(lowerQuery)) { results.push({ type: 'geofence', id: gf.id, name: gf.name, description: `Radius: ${gf.radius}m`, icon: 'radar' }); } });
        try {
            const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(query)}&limit=4`;
            // Use AppConfig if available, otherwise default
            const appVersion = window.AppConfig?.APP_VERSION || '?.?.?';
            const response = await fetch(url, { headers: { 'User-Agent': `FindMyWebApp/${appVersion}` } });
            if (!response.ok) { console.error(`Nominatim search failed: ${response.status}`); }
            else { const nominatimData = await response.json(); nominatimData.forEach(loc => { results.push({ type: 'location', query: loc.display_name, name: loc.display_name.split(',')[0], description: loc.display_name, icon: 'travel_explore', lat: parseFloat(loc.lat), lng: parseFloat(loc.lon) }); }); }
        } catch (error) { console.error("Nominatim search error during global search:", error); }
        AppUI.renderSearchResults(results, 'search-results-container'); AppUI.showSearchResults('search-results-container');
    },

    initDebouncedSearch: function () {
        // Ensure AppUtils is defined
        if (window.AppUtils && typeof AppUtils.debounce === 'function') {
            this._debouncedSearchHandler = AppUtils.debounce(this.performSearch, 350);
        } else {
            console.error("AppUtils or AppUtils.debounce not found! Search debouncing will not work.");
            // Fallback to immediate search (can be laggy)
            this._debouncedSearchHandler = this.performSearch;
        }
    },

    handleExportConfig: async function () {
        const checkboxes = document.querySelectorAll('#export-parts-selection input[name="export_part"]:checked');
        const selectedParts = Array.from(checkboxes).map(cb => cb.value);
        if (selectedParts.length === 0) { if (window.AppUI) AppUI.showErrorDialog("Export Error", "Please select at least one part to export."); return; }

        const exportData = {
            export_format: "findmyapp_combined_v1",
            app_version: window.AppConfig?.APP_VERSION || "?.?.?", // Use AppConfig
            timestamp: new Date().toISOString(),
            client: {}, server: {}
        };
        const errors = [];

        if (window.AppUI) AppUI.showConfirmationDialog("Exporting...", "Gathering configuration data...", null, null);

        // Gather Client Data
        if (selectedParts.includes('clientSettings')) { exportData.client.clientSettings = { theme: AppState.currentTheme, userColor: AppState.userColor, isShowingAllDevices: AppState.isShowingAllDevices, showDeviceHistory: AppState.showDeviceHistory, historyTimeFilterHours: AppState.historyTimeFilterHours, locationHistoryEnabled: AppState.locationHistoryEnabled }; }
        if (selectedParts.includes('savedPlaces')) { exportData.client.savedPlaces = AppState.savedPlaces; }
        if (selectedParts.includes('locationHistory')) { exportData.client.locationHistory = AppState.locationHistory; }
        if (selectedParts.includes('deviceVisibility')) { exportData.client.deviceVisibility = AppState.deviceVisibility; }

        // Gather Server Data
        const serverPartsToFetch = selectedParts.filter(p => ['devices', 'geofences'].includes(p));
        if (serverPartsToFetch.length > 0) {
            try {
                for (const part of serverPartsToFetch) { console.log(`Fetching server part: ${part}`); const partData = await AppApi.getConfigPart(part); exportData.server[part] = partData; }
            } catch (error) { console.error("Error fetching server config parts for export:", error); errors.push(`Failed to fetch server part (${error.message})`); }
        }

        if (window.AppUI) AppUI.closeDialog('confirmation-dialog');

        if (errors.length > 0) { if (window.AppUI) AppUI.showErrorDialog("Export Failed", `Could not gather all selected configuration parts.<br>Errors: ${errors.join(', ')}`); return; }
        if (Object.keys(exportData.client).length === 0 && Object.keys(exportData.server).length === 0) { if (window.AppUI) AppUI.showErrorDialog("Export Error", "No data was gathered for the selected parts."); return; }

        // Trigger Download
        try {
            const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' });
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-'); const filename = `findmyapp_config_${timestamp}.json`;
            const link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); window.URL.revokeObjectURL(link.href);
            console.log(`Config exported successfully as ${filename}`);
        } catch (error) { console.error("Error triggering config download:", error); if (window.AppUI) AppUI.showErrorDialog("Download Failed", `Could not create download file.<br>Details: ${error.message}`); }
    },

    handleImportFileSelected: async function (file) {
        console.log("[Action] Processing selected import file...");
        const statusMessage = document.getElementById('import-status-message'); const partsSelectionDiv = document.getElementById('import-parts-selection'); const confirmButton = document.getElementById('confirm-import-button');
        if (!statusMessage || !partsSelectionDiv || !confirmButton) { console.error("[Action] Import UI elements missing. Aborting."); return; }

        AppState.clearImportData(); partsSelectionDiv.style.display = 'none'; partsSelectionDiv.innerHTML = '<h4 class="settings-section-title">Select Parts to Import</h4>'; confirmButton.style.display = 'none'; confirmButton.disabled = true; statusMessage.textContent = ''; statusMessage.style.color = 'inherit';
        statusMessage.textContent = 'Reading file...'; console.log(`[Action] Reading import file: ${file.name}`);

        try {
            const fileContent = await file.text(); console.log("[Action] Import file read."); const parsedData = JSON.parse(fileContent); AppState.setImportData(parsedData); console.log("[Action] Import file parsed:", parsedData);
            if (!parsedData.export_format || !parsedData.export_format.startsWith('findmyapp_combined_')) { throw new Error(`Unsupported format: ${parsedData.export_format || 'Unknown'}.`); }
            console.log(`[Action] Format validated: ${parsedData.export_format}`);

            const availableParts = {};
            const partDefinitions = { clientSettings: { name: 'UI/Map/Theme Settings', data: parsedData.client?.clientSettings }, savedPlaces: { name: `Saved Places`, data: parsedData.client?.savedPlaces }, locationHistory: { name: `Location History`, data: parsedData.client?.locationHistory }, deviceVisibility: { name: `Device Visibility`, data: parsedData.client?.deviceVisibility }, devices: { name: `Device Configs`, data: parsedData.server?.devices }, geofences: { name: `Geofences`, data: parsedData.server?.geofences } };
            let hasParts = false;
            for (const partKey in partDefinitions) {
                const partInfo = partDefinitions[partKey]; let count = 0; const dataToCheck = partKey.startsWith('client') ? parsedData.client?.[partKey] : parsedData.server?.[partKey];
                if (dataToCheck !== null && dataToCheck !== undefined) { if (Array.isArray(dataToCheck)) count = dataToCheck.length; else if (typeof dataToCheck === 'object') count = Object.keys(dataToCheck).length; else count = 1; }
                if (count > 0) { availableParts[partKey] = `${partInfo.name}${count > 1 ? ` (${count})` : ''}`; hasParts = true; }
            }

            if (hasParts) {
                const fileInfoTime = parsedData.timestamp ? AppUtils.formatTimeRelative(new Date(parsedData.timestamp)) : 'N/A';
                statusMessage.textContent = `File Read. Format: ${parsedData.export_format}, Ver: ${parsedData.app_version || 'N/A'}, Created: ${fileInfoTime}`; partsSelectionDiv.innerHTML = '<h4 class="settings-section-title">Select Parts to Import</h4>';
                Object.keys(availableParts).forEach(partKey => { const labelText = availableParts[partKey]; const label = document.createElement('label'); label.innerHTML = `<input type="checkbox" name="import_part" value="${partKey}" checked> ${labelText}`; partsSelectionDiv.appendChild(label); });
                partsSelectionDiv.style.display = 'block'; confirmButton.style.display = 'inline-flex'; confirmButton.disabled = false;
            } else { statusMessage.textContent = "No importable parts found in this file."; statusMessage.style.color = 'var(--m3-sys-color-error)'; }
        } catch (error) {
            console.error("[Action] Error reading or parsing import file:", error); statusMessage.textContent = `Error reading file: ${error.message}`; statusMessage.style.color = 'var(--m3-sys-color-error)'; AppState.clearImportData(); AppUI.resetImportDialog();
        }
    },

    handleImportConfirm: async function () {
        console.log("[Action] Confirm Import button clicked.");
        const statusMessage = document.getElementById('import-status-message'); const partsSelectionDiv = document.getElementById('import-parts-selection'); const confirmButton = document.getElementById('confirm-import-button');
        const selectedParts = Array.from(partsSelectionDiv.querySelectorAll('input[name="import_part"]:checked')).map(cb => cb.value); const importedData = AppState.getImportData();

        if (selectedParts.length === 0) { statusMessage.textContent = "Please select at least one part to import."; statusMessage.style.color = 'var(--m3-sys-color-error)'; return; }
        if (!importedData) { statusMessage.textContent = "Import data not found. Please select file again."; statusMessage.style.color = 'var(--m3-sys-color-error)'; AppUI.resetImportDialog(); return; }

        confirmButton.disabled = true; confirmButton.innerHTML = `<div class="spinner" style="width:18px;height:18px;border-width:2px;margin:0 auto;"></div> Importing...`; statusMessage.textContent = `Checking for potential overwrites...`; statusMessage.style.color = 'inherit';

        let needsOverwriteConfirm = false; let overwriteItems = [];
        const getPartName = (partKey) => ({ devices: 'Device configurations', geofences: 'Geofences', savedPlaces: 'Saved Places', locationHistory: 'Location History', clientSettings: 'UI/Map/Theme settings', deviceVisibility: 'Device visibility' }[partKey] || partKey);
        const hasExisting = (partKey) => { switch (partKey) { case 'devices': return AppState.currentDeviceData.length > 0; case 'geofences': return AppState.globalGeofenceData.length > 0; case 'savedPlaces': return AppState.savedPlaces.length > 0; case 'locationHistory': return AppState.locationHistory.length > 0; case 'clientSettings': return true; case 'deviceVisibility': return Object.keys(AppState.deviceVisibility).length > 0; default: return false; } };

        selectedParts.forEach(partKey => { const dataToCheck = partKey.startsWith('client') ? importedData.client?.[partKey] : importedData.server?.[partKey]; if (dataToCheck !== undefined && hasExisting(partKey)) { const partName = getPartName(partKey); if (!overwriteItems.includes(partName)) { needsOverwriteConfirm = true; overwriteItems.push(partName); } } });

        if (needsOverwriteConfirm) {
            const confirmationMessage = `Importing selected parts (${overwriteItems.join(', ')}) will <strong>completely replace</strong> existing data for those parts. Continue?`; console.log("[Action] Showing overwrite confirmation.");
            AppUI.showConfirmationDialog("Confirm Overwrite", confirmationMessage, () => { console.log("[Action] Overwrite confirmed."); AppActions._proceedWithImport(selectedParts, importedData); }, () => { console.log("[Action] Overwrite cancelled."); statusMessage.textContent = "Import cancelled."; confirmButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Import Selected`; confirmButton.disabled = false; AppUI.resetImportDialog(); });
        } else { console.log("[Action] No overwrite needed. Proceeding."); AppActions._proceedWithImport(selectedParts, importedData); }
    },

    _proceedWithImport: async function (selectedParts, importedData) {
        console.log("[Action] Proceeding with import for parts:", selectedParts);
        const statusMessage = document.getElementById('import-status-message'); const confirmButton = document.getElementById('confirm-import-button');
        let clientImported = false; let serverImported = false; const serverPartsPayload = {}; const clientErrors = []; const serverErrors = [];

        statusMessage.textContent = `Importing selected parts (${selectedParts.join(', ')})...`; statusMessage.style.color = 'inherit';
        if (confirmButton) confirmButton.disabled = true;

        // Process Client Parts
        console.log("[Action] Processing client parts...");
        try {
            if (selectedParts.includes('clientSettings') && importedData.client?.clientSettings) {
                console.log("[Action] Importing client settings..."); const settings = importedData.client.clientSettings;
                if (settings.theme_mode !== undefined) AppState.currentTheme = settings.theme_mode;
                if (settings.theme_color !== undefined) AppState.userColor = settings.theme_color;
                if (window.AppTheme && typeof window.AppTheme.applyTheme === 'function') { AppTheme.applyTheme(AppState.userColor, AppState.currentTheme); }
                if (settings.isShowingAllDevices !== undefined) AppState.isShowingAllDevices = settings.isShowingAllDevices;
                if (settings.showDeviceHistory !== undefined) AppState.showDeviceHistory = settings.showDeviceHistory;
                if (settings.historyTimeFilterHours !== undefined) AppState.historyTimeFilterHours = parseInt(settings.historyTimeFilterHours, 10) || AppState.historyTimeFilterHours;
                if (settings.locationHistoryEnabled !== undefined) AppState.locationHistoryEnabled = settings.locationHistoryEnabled;
                AppState.saveMapToggles(); AppState.saveLocationHistoryEnabled(); clientImported = true; console.log("[Action] Client settings imported.");
            }
            if (selectedParts.includes('savedPlaces') && importedData.client?.savedPlaces) { console.log("[Action] Importing saved places..."); AppState.savedPlaces = importedData.client.savedPlaces; AppState.saveSavedPlaces(); clientImported = true; }
            if (selectedParts.includes('locationHistory') && importedData.client?.locationHistory) { console.log("[Action] Importing location history..."); AppState.locationHistory = importedData.client.locationHistory; AppState.saveLocationHistory(); clientImported = true; }
            if (selectedParts.includes('deviceVisibility') && importedData.client?.deviceVisibility) { console.log("[Action] Importing device visibility..."); AppState.deviceVisibility = importedData.client.deviceVisibility; AppState.saveDeviceVisibilityState(); clientImported = true; }
        } catch (e) { clientErrors.push(`Client settings import failed: ${e.message}`); console.error("[Action] Client import error:", e); }

        // Prepare Server Parts
        console.log("[Action] Preparing server parts...");
        if (selectedParts.includes('devices') && importedData.server?.devices) serverPartsPayload.devices = importedData.server.devices;
        if (selectedParts.includes('geofences') && importedData.server?.geofences) serverPartsPayload.geofences = importedData.server.geofences;

        // Process Server Parts
        const hasServerParts = selectedParts.some(p => ['devices', 'geofences'].includes(p));
        if (hasServerParts) {
            console.log("[Action] Sending server config parts to backend:", Object.keys(serverPartsPayload));
            try { const serverResult = await AppApi.applyImportedConfig(serverPartsPayload); serverImported = true; console.log("[Action] Server config import response:", serverResult); if (serverResult.details?.errors?.length > 0) serverErrors.push(...serverResult.details.errors); }
            catch (e) { serverErrors.push(`Server config import API call failed: ${e.message}`); console.error("[Action] Server config import API error:", e); }
        }

        // Save theme prefs separately if client settings were chosen but no other server parts
        const hasThemeParts = selectedParts.includes('clientSettings');
        if (hasThemeParts && !hasServerParts) {
            console.log("[Action] Saving only theme preferences to backend.");
            try {
                await AppApi.updateUserPreferences(AppState.currentTheme, AppState.userColor);
                serverImported = true; // Mark as server interaction occurred
                console.log("[Action] Theme preferences saved successfully.");
            } catch (e) { serverErrors.push(`Failed to save theme preferences: ${e.message}`); console.error("[Action] Theme preferences save API error:", e); }
        }

        // Finalize and Report
        let finalMessage = ""; let messageColor = 'inherit'; let needsRefresh = false;
        if (clientImported || serverImported) { finalMessage = "Import complete."; needsRefresh = true; }
        else if (clientErrors.length > 0 || serverErrors.length > 0) { finalMessage = "Import completed with errors."; }
        else { finalMessage = "Import finished, but no changes were applied."; }
        if (clientErrors.length > 0 || serverErrors.length > 0) { finalMessage += " Errors: " + [...clientErrors, ...serverErrors].join('; '); messageColor = 'var(--m3-sys-color-error)'; }
        else if (clientImported || serverImported) { messageColor = 'var(--m3-sys-color-primary)'; }
        statusMessage.textContent = finalMessage; statusMessage.style.color = messageColor;

        if (needsRefresh) {
            console.log("[Action] Refreshing UI and data after import..."); AppUI.setupSettingsPage(); await AppActions.refreshGeofencesAndDevices(); AppUI.renderSavedPlacesList(); AppUI.renderLocationHistory(); console.log("[Action] UI and data refresh complete.");
        }

        if (confirmButton) { confirmButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Import Selected`; confirmButton.disabled = false; }
        AppUI.resetImportDialog();
    }
};

// --- Main Initialization Sequence ---
async function initializeApp() {
    console.log(`FindMy App (${window.AppConfig?.APP_VERSION || '?.?.?'}) Initializing...`);

    // 0. Check/Load ES Module Fallback FIRST
    const m3UtilsLocalPath = '/static/libs/material-color/material-color-utilities.esm.js';
    try {
        // *** AWAIT the fallback check to complete ***
        await loadLocalModuleFallback(m3UtilsLocalPath, 'M3ColorUtils');
        // *** ----------------------------------- ***
    } catch (err) {
        console.error("Critical error loading Material Color Utilities. Theming will be broken.", err);
        // Continue without dynamic theming if it fails? Or show blocking error?
        // Let's try to continue for now, but log the error clearly.
    }

    // 1. Load state FIRST
    AppState.loadInitialState();

    // 2. Fetch user preferences
    try {
        console.log("Fetching user preferences...");
        const prefs = await AppApi.fetchUserPreferences();
        AppState.setCurrentUserPreferences(prefs);
    } catch (error) {
        console.error("Failed to fetch user preferences:", error);
    }

    // 3. Initialize theme system (CRITICAL: Check if M3ColorUtils actually loaded)
    if (window.AppTheme && typeof window.AppTheme.initializeTheme === 'function') {
        // *** ADDED CHECK for window.M3ColorUtils ***
        if (window.M3ColorUtils) {
            AppTheme.initializeTheme();
        } else {
            // Log error and apply basic theme class if utils are missing
            console.error("AppTheme exists, but M3ColorUtils failed to load! Applying basic theme class only.");
            const isDarkFallback = (window.AppTheme && typeof window.AppTheme.isDarkModeActive === 'function')
                ? AppTheme.isDarkModeActive(AppState.currentTheme)
                : (AppState.currentTheme === 'dark' || (AppState.currentTheme === 'system' && window.matchMedia?.('(prefers-color-scheme: dark)').matches));
            document.body.classList.remove('dark-theme', 'light-theme');
            document.body.classList.add(isDarkFallback ? 'dark-theme' : 'light-theme');
        }
        // *** END CHECK ***
    } else {
        // THIS is the error message you are seeing
        console.error("AppTheme or initializeTheme not found! Theme will not be dynamic.");
        // Apply basic fallback class as well
        const isDarkFallback = (AppState.currentTheme === 'dark' || (AppState.currentTheme === 'system' && window.matchMedia?.('(prefers-color-scheme: dark)').matches));
        document.body.classList.remove('dark-theme', 'light-theme');
        document.body.classList.add(isDarkFallback ? 'dark-theme' : 'light-theme');
    }

    // 4. Setup UI (uses theme state)
    AppUI.setupSettingsPage();
    AppUI.changePage('index'); // Load initial page
    AppActions.initDebouncedSearch(); // Setup search

    // Start map initialization (which will handle its own readiness and data fetching)
    if (window.AppMap && typeof window.AppMap.initMap === 'function') {
        AppMap.initMap(); // Let initMap handle the flow internally
    } else {
        console.error("AppMap or AppMap.initMap not found!");
        if (window.AppMap) AppMap.showMapErrorPlaceholder("Map code failed to load.");
    }

    // 5. Register Service Worker
    if (window.AppNotifications) {
        AppNotifications.registerServiceWorker()
            .then(() => console.log("Service worker registration sequence completed."))
            .catch(error => console.error("Service worker registration failed on startup:", error));
    } else { console.error("AppNotifications object not found!"); }


    // 6. Fetch initial map/device data
    AppActions.fetchInitialData().catch(err => console.error("Error during initial data fetch:", err));

    // --- Global Event Listeners ---
    // Defer Leaflet-dependent listeners slightly
    function setupMapListeners() {
        // Check for Leaflet (L), AppMap, and AppUI readiness
        if (typeof L !== 'undefined' && window.AppMap && window.AppUI) {
            console.log("Setting up Leaflet-dependent event listeners.");
            const indexPage = document.getElementById('index-page');
            indexPage?.addEventListener('click', (e) => {
                const buttonId = e.target.closest('.map-control-button')?.id;
                const mapInstance = AppState.getMap(); // Get map instance
                if (!mapInstance) return; // Don't act if map isn't ready

                if (buttonId === 'zoom-in') mapInstance.zoomIn();
                else if (buttonId === 'zoom-out') mapInstance.zoomOut();
                else if (buttonId === 'my-location') AppMap.locateMe();
                else if (buttonId === 'show-all-button') AppUI.toggleShowAllDevices();
                else if (buttonId === 'show-history-button') AppUI.toggleShowHistory();
            });
            document.getElementById('refresh-button')?.addEventListener('click', () => AppMap.locateMe());
            // Add other Leaflet-dependent listeners here if needed
        } else {
            console.warn("Leaflet (L) or AppMap/AppUI not defined when setting up map event listeners. Retrying...");
            setTimeout(setupMapListeners, 500); // Retry after a delay
        }
    }
    setTimeout(setupMapListeners, 100); // Initial attempt after small delay

    // Setup listeners NOT dependent on Leaflet
    const mainContent = document.getElementById('main-content');
    const body = document.body;
    const searchInput = document.getElementById('location-search-input');
    const searchResultsContainer = document.getElementById('search-results-container');
    document.getElementById('menu-button')?.addEventListener('click', () => AppUI.openDrawer());
    document.getElementById('drawer-overlay')?.addEventListener('click', () => AppUI.closeDrawer());
    document.getElementById('drawer-close-button')?.addEventListener('click', () => AppUI.closeDrawer());
    document.getElementById('drawer')?.addEventListener('click', (e) => {
        const drawerItem = e.target.closest('.drawer-item');
        const anchor = e.target.closest('a');
        if (!drawerItem && !anchor) return;
        const page = drawerItem?.dataset.page || anchor?.dataset.page;
        const dialog = drawerItem?.dataset.dialog || anchor?.dataset.dialog;
        const targetAction = anchor?.dataset.target;
        const section = drawerItem?.dataset.section || anchor?.dataset.section;

        if (anchor && anchor.href.includes('logout')) { AppUI.closeDrawer(); return; }
        else if (anchor && anchor.href.includes('manage_apple_creds')) { AppUI.closeDrawer(); return; }
        else if (page) { e.preventDefault(); AppUI.changePage(page, section); AppUI.closeDrawer(); }
        else if (dialog) { e.preventDefault(); AppUI.openDialog(dialog); AppUI.closeDrawer(); }
    });
    document.getElementById('more-button')?.addEventListener('click', (e) => { e.stopPropagation(); AppUI.openMoreMenu(); });
    document.getElementById('more-menu-dialog-overlay')?.addEventListener('click', () => AppUI.closeMoreMenu());
    document.querySelector('.bottom-nav')?.addEventListener('click', (e) => {
        const navLink = e.target.closest('.nav-link');
        if (navLink && navLink.dataset.page) { e.preventDefault(); AppUI.changePage(navLink.dataset.page); }
    });
    body.addEventListener('click', (e) => {
        const closeButton = e.target.closest('[data-close-dialog]');
        if (closeButton) { AppUI.closeDialog(closeButton.dataset.closeDialog); }
        else if (e.target.classList.contains('dialog-overlay') && !e.target.id.includes('more-menu')) { const dialogId = e.target.id.replace('-overlay', ''); AppUI.closeDialog(dialogId); }
    });
    document.getElementById('add-place-button')?.addEventListener('click', () => AppUI.openAddPlaceDialog());
    document.getElementById('add-place-dialog-button')?.addEventListener('click', () => AppUI.handleAddPlaceSubmit());
    document.getElementById('share-button')?.addEventListener('click', () => { AppUI.openDialog('share-location-dialog'); AppUI.copyShareLocationText(); });
    document.getElementById('copy-share-button')?.addEventListener('click', () => AppUI.copyShareLocationText());
    document.getElementById('refresh-devices-button')?.addEventListener('click', () => AppActions.refreshDevices());
    document.getElementById('clear-history-button')?.addEventListener('click', () => { AppUI.showConfirmationDialog("Clear History?", "Are you sure you want to clear all your location history?", () => { AppState.clearLocationHistory(); AppUI.renderLocationHistory(); }); });
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            if (query.length === 0) { AppUI.hideSearchResults(); }
            else { AppActions._debouncedSearchHandler(query); }
        });
        searchInput.addEventListener('focus', (e) => {
            const query = e.target.value.trim();
            if (query.length >= 2) { AppActions.performSearch(query); }
        });
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const firstResult = searchResultsContainer?.querySelector('.search-result-item');
                if (firstResult) { firstResult.click(); }
            }
        });
        document.addEventListener('click', (event) => {
            if (!searchInput.contains(event.target) && !searchResultsContainer?.contains(event.target) && !event.target.closest('.app-bar')) {
                AppUI.hideSearchResults();
            }
        });
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && searchResultsContainer?.classList.contains('show')) {
                AppUI.hideSearchResults();
                searchInput.blur();
            }
        });
    }
    document.getElementById('add-global-geofence-button')?.addEventListener('click', () => AppUI.openAddGlobalGeofenceDialog());
    document.getElementById('test-notification-button')?.addEventListener('click', () => AppNotifications.handleTestNotification());
    const globalGeofencesList = document.getElementById('global-geofences-list');
    globalGeofencesList?.addEventListener('click', (e) => {
        const editBtn = e.target.closest('.geofence-edit');
        const removeBtn = e.target.closest('.geofence-remove');
        const item = e.target.closest('.settings-item[data-geofence-id]');
        if (editBtn) { e.stopPropagation(); AppUI.openEditGlobalGeofenceDialog(editBtn.dataset.geofenceId); }
        else if (removeBtn) { e.stopPropagation(); const id = removeBtn.dataset.geofenceId; const name = item?.querySelector('.settings-item-title')?.textContent || id; AppUI.confirmRemoveItem('geofence', id, name, AppActions.handleRemoveGlobalGeofence); }
        else if (item) { AppUI.openEditGlobalGeofenceDialog(item.dataset.geofenceId); }
    });
    globalGeofencesList?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            const item = e.target.closest('.settings-item[data-geofence-id]');
            if (item && !e.target.closest('.geofence-edit, .geofence-remove')) { e.preventDefault(); AppUI.openEditGlobalGeofenceDialog(item.dataset.geofenceId); }
        }
    });
    const deviceGeofenceLinksList = document.getElementById('device-geofence-links-list');
    deviceGeofenceLinksList?.addEventListener('click', (e) => {
        const unlinkBtn = e.target.closest('.geofence-remove[data-geofence-id]');
        const linkBtn = e.target.closest('.link-geofence-button');
        const saveBtn = e.target.closest('.save-links-button[data-device-id]');
        const cardElement = e.target.closest('.device-geofence-card');
        if (!cardElement) return;
        const deviceId = cardElement.id.replace('device-link-card-', '');
        if (unlinkBtn) {
            e.stopPropagation();
            const geofenceIdToUnlink = unlinkBtn.dataset.geofenceId;
            const itemToRemove = cardElement.querySelector(`.geofence-link-item[data-geofence-id="${geofenceIdToUnlink}"]`);
            if (itemToRemove) { itemToRemove.remove(); cardElement.querySelector('.save-links-button').style.display = 'inline-flex'; AppUI.renderAddGeofenceDropdown(cardElement, deviceId); if (cardElement.querySelectorAll('.geofence-link-item').length === 0) { cardElement.querySelector('.linked-geofences-list').innerHTML = '<p class="no-geofences-message" style="padding: 8px 0; font-style: italic; opacity: 0.7;">No geofences linked yet.</p>'; } }
        } else if (linkBtn) {
            e.stopPropagation();
            const selectElement = cardElement.querySelector('.add-geofence-select');
            const geofenceIdToAdd = selectElement.value;
            const errorElement = cardElement.querySelector(`#link-error-${deviceId}`);
            errorElement.style.display = 'none';
            if (!geofenceIdToAdd) { errorElement.textContent = 'Please select a geofence to link.'; errorElement.style.display = 'block'; return; }
            const geofenceToAdd = AppState.globalGeofenceData.find(gf => gf.id === geofenceIdToAdd);
            if (!geofenceToAdd) { errorElement.textContent = 'Selected geofence definition not found.'; errorElement.style.display = 'block'; return; }
            const list = cardElement.querySelector('.linked-geofences-list');
            const noItemsMsg = list.querySelector('.no-geofences-message');
            if (noItemsMsg) noItemsMsg.remove();
            const newLinkItem = document.createElement('div');
            newLinkItem.className = 'geofence-link-item'; newLinkItem.dataset.geofenceId = geofenceIdToAdd;
            newLinkItem.innerHTML = `<div class="geofence-link-info"><div class="geofence-link-name">${geofenceToAdd.name}</div><div class="geofence-link-details">Radius: ${geofenceToAdd.radius}m</div></div><div class="geofence-link-toggles"><label class="geofence-link-toggle-label" title="Notify on Entry"><input type="checkbox" data-notify-type="entry"> Entry</label><label class="geofence-link-toggle-label" title="Notify on Exit"><input type="checkbox" data-notify-type="exit"> Exit</label><span class="material-icons geofence-remove" title="Unlink Geofence" data-geofence-id="${geofenceIdToAdd}" style="margin-left: 8px; cursor: pointer; opacity: 0.6; color: var(--m3-sys-color-error);" tabindex="0" role="button" aria-label="Unlink ${geofenceToAdd.name}">link_off</span></div>`; list.appendChild(newLinkItem); cardElement.querySelector('.save-links-button').style.display = 'inline-flex'; AppUI.renderAddGeofenceDropdown(cardElement, deviceId);
        } else if (saveBtn) { e.stopPropagation(); AppActions.handleSaveDeviceGeofenceLinks(deviceId, cardElement); }
    });
    deviceGeofenceLinksList?.addEventListener('change', (e) => {
        if (e.target.matches('.geofence-link-toggles input[type="checkbox"]')) {
            const cardElement = e.target.closest('.device-geofence-card');
            if (cardElement) { cardElement.querySelector('.save-links-button').style.display = 'inline-flex'; }
        }
    });
    const settingsPage = document.getElementById('settings-page');
    settingsPage?.addEventListener('change', (e) => {
        if (e.target.id === 'location-history-toggle') { AppState.locationHistoryEnabled = e.target.checked; AppState.saveLocationHistoryEnabled(); console.log("Location history enabled:", AppState.locationHistoryEnabled); if (!AppState.locationHistoryEnabled) { AppState.clearLocationHistory(); } if (document.getElementById('history-page')?.style.display === 'block') { AppUI.renderLocationHistory(); } }
        else if (e.target.id === 'show-all-default-toggle') { AppState.isShowingAllDevices = e.target.checked; AppState.saveMapToggles(); if (document.getElementById('index-page')?.style.display !== 'none' && window.AppUI) { AppUI.updateShowAllButtonState(); AppMap.updateMapView(); } }
        else if (e.target.id === 'show-history-default-toggle') { AppState.showDeviceHistory = e.target.checked; AppState.saveMapToggles(); if (document.getElementById('index-page')?.style.display !== 'none' && window.AppUI) { AppUI.updateShowHistoryButtonState(); AppMap.updateHistoryLayersVisibility(); } }
    });
    document.getElementById('enable-notifications-button')?.addEventListener('click', () => AppNotifications.handleNotificationPermission());
    document.getElementById('unsubscribe-button')?.addEventListener('click', () => AppNotifications.unsubscribeUser());
    // document.getElementById('test-notification-button')?.addEventListener('click', () => AppNotifications.handleTestNotification('test')); // Moved to setupSettingsPage
    const sharedDevicesList = document.getElementById('shared-devices-list');
    sharedDevicesList?.addEventListener('click', (e) => {
        const deviceItem = e.target.closest('.shared-device[data-device-id]');
        const menuButton = e.target.closest('.device-menu[data-device-index]');
        const visibilityToggle = e.target.closest('.device-visibility-toggle input');
        if (visibilityToggle) { /* Handled by change listener */ }
        else if (menuButton) { e.stopPropagation(); const index = parseInt(menuButton.dataset.deviceIndex, 10); AppUI.openDeviceMenu(index, menuButton); }
        else if (deviceItem && window.AppMap) { AppMap.viewDeviceOnMap(deviceItem.dataset.deviceId); }
    });
    sharedDevicesList?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            const deviceItem = e.target.closest('.shared-device[data-device-id]');
            const menuButton = e.target.closest('.device-menu[data-device-index]');
            const visibilityToggle = e.target.closest('.device-visibility-toggle input');
            if (visibilityToggle) { e.preventDefault(); visibilityToggle.click(); }
            else if (menuButton) { e.preventDefault(); const index = parseInt(menuButton.dataset.deviceIndex, 10); AppUI.openDeviceMenu(index, menuButton); }
            else if (deviceItem && window.AppMap) { e.preventDefault(); AppMap.viewDeviceOnMap(deviceItem.dataset.deviceId); }
        }
    });
    sharedDevicesList?.addEventListener('change', (e) => { if (e.target.matches('.device-visibility-toggle input[data-device-id]')) { AppUI.handleDeviceVisibilityToggle(e.target); } });
    const savedPlacesList = document.getElementById('saved-places-list');
    savedPlacesList?.addEventListener('click', (e) => {
        const placeItem = e.target.closest('.shared-device[data-place-index]');
        const menuButton = e.target.closest('.device-menu[data-place-index]');
        if (menuButton) { e.stopPropagation(); const index = parseInt(menuButton.dataset.placeIndex, 10); AppUI.openPlaceMenu(index, menuButton); }
        else if (placeItem && window.AppMap) { const index = parseInt(placeItem.dataset.placeIndex, 10); AppMap.viewPlaceOnMap(index); }
    });
    savedPlacesList?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            const placeItem = e.target.closest('.shared-device[data-place-index]');
            const menuButton = e.target.closest('.device-menu[data-place-index]');
            if (menuButton) { e.preventDefault(); const index = parseInt(menuButton.dataset.placeIndex, 10); AppUI.openPlaceMenu(index, menuButton); }
            else if (placeItem && window.AppMap) { e.preventDefault(); const index = parseInt(placeItem.dataset.placeIndex, 10); AppMap.viewPlaceOnMap(index); }
        }
    });
    document.getElementById('export-config-button')?.addEventListener('click', AppActions.handleExportConfig);
    document.getElementById('import-config-file-input')?.addEventListener('change', AppUI.handleImportFileSelection); // UI handles change
    document.getElementById('confirm-import-button')?.addEventListener('click', AppActions.handleImportConfirm); // Action handles confirm
    document.getElementById('place-picker-my-location')?.addEventListener('click', () => AppMap.centerDialogMapOnUserLocation('place'));
    document.getElementById('geofence-picker-my-location')?.addEventListener('click', () => AppMap.centerDialogMapOnUserLocation('geofence'));
    document.getElementById('delete-account-button')?.addEventListener('click', () => {
        AppUI.showConfirmationDialog(
            "Delete Account?",
            "<strong>This action is permanent and cannot be undone.</strong><br>All your devices, geofences, settings, and stored credentials will be deleted.<br><br>Are you absolutely sure you want to delete your account?",
            async () => { // onConfirm
                console.log("Account deletion confirmed by user.");
                AppUI.showConfirmationDialog("Deleting...", "Deleting your account and data...", null, null);
                const progressDialog = document.getElementById('confirmation-dialog');
                if (progressDialog) progressDialog.querySelector('.dialog-actions').style.display = 'none';
                try {
                    await AppApi.deleteAccount();
                    console.log("Account deletion successful on backend. Redirecting...");
                    window.location.href = '/logged-out';
                } catch (error) {
                    console.error("Account deletion failed:", error);
                    AppUI.closeDialog('confirmation-dialog');
                    AppUI.showErrorDialog("Deletion Failed", `Could not delete account: ${error.message}`);
                }
            },
            () => { console.log("Account deletion cancelled."); } // onCancel
        );
    });

    // Notification History Page Listeners
    document.getElementById('mark-all-read-button')?.addEventListener('click', () => AppUI.handleMarkAllRead());
    document.getElementById('clear-all-history-button')?.addEventListener('click', () => AppUI.handleClearAllHistory());


    console.log("App initialization sequence complete.");
}

// --- Main Initialization Trigger ---
document.addEventListener('DOMContentLoaded', initializeApp);
// --------------------
// app\static\js\config.js
// app/static/js/config.js

// Values passed from the backend via window object (in index.html)
const VAPID_PUBLIC_KEY = window.VAPID_PUBLIC_KEY || null;
const LOW_BATTERY_THRESHOLD = window.LOW_BATTERY_THRESHOLD || 15;
const APP_VERSION = window.APP_VERSION || "?.?.?";

// --- Notification Icon/Badge URLs ---
const DEFAULT_NOTIFICATION_ICON_URL = window.DEFAULT_NOTIFICATION_ICON_URL || '/static/icons/favicon.svg';
const WELCOME_NOTIFICATION_ICON_URL = window.WELCOME_NOTIFICATION_ICON_URL || DEFAULT_NOTIFICATION_ICON_URL;
const GEOFENCE_BADGE_URL = window.GEOFENCE_BADGE_URL || '/static/icons/badge-icon.png'; // Fallback to default badge
const BATTERY_BADGE_URL = window.BATTERY_BADGE_URL || '/static/icons/badge-icon.png'; // Fallback to default badge
const TEST_NOTIFICATION_ICON_URL = window.TEST_ICON_BADGE_URL || DEFAULT_NOTIFICATION_ICON_URL; // Icon for Test
const TEST_NOTIFICATION_BADGE_URL = window.TEST_ICON_BADGE_URL || '/static/icons/badge-icon.png'; // Badge for Test
const DEFAULT_BADGE_URL = window.DEFAULT_BADGE_URL || '/static/icons/badge-icon.png';
// --- ----------------------------- ---


// Other client-side constants
const MAX_HISTORY_POINTS = 50; // Max location history items to keep
const SAVE_VISIBILITY_DEBOUNCE = 500; // ms delay before saving visibility state
const FETCH_DEVICES_INTERVAL = 5 * 60 * 1000; // Optional: Interval for background refresh (e.g., 5 minutes) - can be disabled if relying solely on scheduler


// Leaflet pane configuration (centralized)
const LEAFLET_PANES = {
    GEOFECE: { name: 'geofencePane', zIndex: 350 },
    HISTORY_LINE: { name: 'historyLinePane', zIndex: 450 },
    HISTORY_POINT: { name: 'historyPointPane', zIndex: 500 },
    MARKERS: { name: 'markerPane', zIndex: 600 }, // Default marker pane zIndex
    POPUPS: { name: 'popupPane', zIndex: 650 }, // Default popup pane zIndex
    SAVED_PLACES: { name: 'savedPlacePane', zIndex: 550 }, // Optional: Custom pane for places
    SEARCH: { name: 'searchPane', zIndex: 800 }, // Optional: Pane for search marker
    USER: { name: 'userLocationPane', zIndex: 900 }, // Optional: Pane for user marker
};

// Export constants
window.AppConfig = {
    VAPID_PUBLIC_KEY,
    LOW_BATTERY_THRESHOLD,
    APP_VERSION,
    DEFAULT_NOTIFICATION_ICON_URL, // Keep for potential fallback in SW
    WELCOME_NOTIFICATION_ICON_URL, // Needed? Maybe not directly
    GEOFENCE_BADGE_URL,            // Needed? Maybe not directly
    BATTERY_BADGE_URL,             // Needed? Maybe not directly
    TEST_NOTIFICATION_ICON_URL,    // Needed for JS test trigger
    TEST_NOTIFICATION_BADGE_URL,   // Needed for JS test trigger
    DEFAULT_BADGE_URL,             // Keep for potential fallback in SW
    MAX_HISTORY_POINTS,
    SAVE_VISIBILITY_DEBOUNCE,
    FETCH_DEVICES_INTERVAL,
    LEAFLET_PANES
};
// --------------------
// app\static\js\map.js
// app/static/js/map.js
// FULL window.AppMap DEFINITION

window.AppMap = {
    // --- Leaflet Icon Definitions (Keep as before) ---
    userLocationIcon: L.divIcon({ className: 'current-location-marker', iconSize: [14, 14], iconAnchor: [7, 7] }),
    savedPlaceIcon: L.divIcon({ className: 'custom-marker saved-place-marker', html: '<span class="material-icons">star</span>', iconSize: [36, 36], iconAnchor: [18, 36], popupAnchor: [0, -36] }),
    searchIcon: L.divIcon({ className: 'custom-marker search-location-marker', html: '<span class="material-icons">search</span>', iconSize: [36, 36], iconAnchor: [18, 36], popupAnchor: [0, -36] }),
    geofenceCenterIcon: L.divIcon({ className: 'custom-marker search-location-marker', html: '<span class="material-icons">location_searching</span>', iconSize: [36, 36], iconAnchor: [18, 18], popupAnchor: [0, -18] }),
    placePickerIcon: L.divIcon({ className: 'custom-marker search-location-marker', html: '<span class="material-icons">add_location</span>', iconSize: [36, 36], iconAnchor: [18, 36], popupAnchor: [0, -36] }),

    getDeviceLeafletIcon: function (label, color, svg_icon_html) {
        const size = 36;
        if (svg_icon_html) {
            return L.divIcon({
                className: 'custom-marker shared-device-marker',
                html: svg_icon_html,
                iconSize: [size, size],
                iconAnchor: [size / 2, size],
                popupAnchor: [0, -size]
            });
        } else {
            const fallbackSvg = window.AppUtils
                ? AppUtils.generateDeviceIconSVG(label, color, size)
                : `<div style="width:${size}px; height:${size}px; border-radius:50%; background-color:${color || '#ccc'}; display:flex; align-items:center; justify-content:center; color:white; font-size:18px; font-weight:bold;">${(label || '?').substring(0, 1)}</div>`;
            console.warn(`SVG icon missing or AppUtils unavailable for device label ${label}, using JS fallback.`);
            return L.divIcon({
                className: 'custom-marker shared-device-marker fallback-icon',
                html: fallbackSvg,
                iconSize: [size, size],
                iconAnchor: [size / 2, size],
                popupAnchor: [0, -size]
            });
        }
    },

    getHistoryPointOptions: function (color, opacity = 0.5, radius = 5) {
        const defaultColor = window.AppUtils ? AppUtils.getDefaultColorForId("history") : '#888888';
        return {
            radius: radius, fillColor: color || defaultColor, color: "#FFFFFF",
            weight: 1, opacity: opacity, fillOpacity: opacity * 0.8,
            pane: AppConfig.LEAFLET_PANES.HISTORY_POINT.name
        };
    },

    getHistoryLineOptions: function (color, opacity = 0.3, weight = 1.5) {
        const defaultColor = window.AppUtils ? AppUtils.getDefaultColorForId("history_line") : '#aaaaaa';
        return {
            color: color || defaultColor, weight: weight, opacity: opacity,
            pane: AppConfig.LEAFLET_PANES.HISTORY_LINE.name
        };
    },

    // --- NEW/Updated Placeholder Helpers ---
    showMapPlaceholder: function (message = "Loading map...") {
        const placeholder = document.getElementById('map-placeholder');
        if (placeholder) {
            placeholder.innerHTML = `<div class="spinner"></div><p>${message}</p>`;
            placeholder.style.display = 'flex'; // Ensure it's displayed before adding class
            // Use a tiny delay before adding 'visible' to ensure the transition plays
            requestAnimationFrame(() => {
                requestAnimationFrame(() => { // Double RAF for belt-and-suspenders
                    placeholder.classList.add('visible');
                });
            });
        }
        console.log("[Map Placeholder] SHOW:", message);
    },

    hideMapPlaceholder: function () {
        const placeholder = document.getElementById('map-placeholder');
        if (placeholder) {
            placeholder.classList.remove('visible');
            // Optional: Set display: none after transition ends for performance,
            // but visibility:hidden usually suffices.
            // placeholder.addEventListener('transitionend', () => {
            //    if (!placeholder.classList.contains('visible')) {
            //        placeholder.style.display = 'none';
            //    }
            // }, { once: true });
        }
        console.log("[Map Placeholder] HIDE");
    },

    showMapErrorPlaceholder: function (message = "Could not load map.") {
        const placeholder = document.getElementById('map-placeholder');
        if (placeholder) {
            placeholder.innerHTML = `<span class="material-icons error">error_outline</span><p>${message}</p>`;
            placeholder.style.display = 'flex'; // Ensure display before class
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    placeholder.classList.add('visible');
                });
            });
        }
        console.error("[Map Placeholder] ERROR:", message);
    },
    // --- END: Placeholder Helpers ---


    // --- Initialization (Incorporating Fixes) ---
    initMap: function () {
        // --- *** ADD INITIALIZATION GUARD *** ---
        if (AppState.getMap()) {
            console.warn("Map already initialized (AppState.map exists). Skipping re-initialization.");
            return; // Exit if map object already exists in state
        }
        // --- ****************************** ---

        console.log("Initializing map..."); // This should now only log once
        const mapElement = document.getElementById('map');
        if (!mapElement) { this.showMapErrorPlaceholder("Map container element not found!"); return; }
        this.showMapPlaceholder("Initializing map...");
        AppState.mapReady = false; // Ensure flag is false initially

        try {
            const mapInstance = L.map('map', { zoomControl: false, attributionControl: false }).setView([20, 0], 3);
            AppState.setMap(mapInstance); // <<< Set map in state EARLY
            let initialLoadComplete = false;
            let loadTimeoutHandle = null;

            const onMapAndDataReady = () => {
                console.log("[Map Init] Map ready, data fetched. Updating view and hiding placeholder.");
                if (window.AppUI) AppUI.updateHistorySliderLabel();
                if (window.AppUI) AppUI.updateShowHistoryButtonState();
                if (window.AppUI) AppUI.updateShowAllButtonState();
                this.updateMapView();
                this.hideMapPlaceholder();
            };

            const setupMapElements = () => { // Runs on map 'load' or timeout
                if (loadTimeoutHandle) clearTimeout(loadTimeoutHandle);
                if (initialLoadComplete) return;
                initialLoadComplete = true;
                console.log("Map visually ready (load/timeout). Setting up layers & fetching data.");

                // --- Setup Panes ---
                Object.values(AppConfig.LEAFLET_PANES).forEach(paneConfig => {
                    if (paneConfig.name !== 'markerPane' && paneConfig.name !== 'popupPane') {
                        mapInstance.createPane(paneConfig.name);
                        const paneElement = mapInstance.getPane(paneConfig.name);
                        if (paneElement) {
                            paneElement.style.zIndex = paneConfig.zIndex;
                            if (paneConfig.name === AppConfig.LEAFLET_PANES.GEOFECE.name) paneElement.style.pointerEvents = 'none';
                        } else console.error(`Failed to create/get pane: ${paneConfig.name}`);
                    } else {
                        const paneElement = mapInstance.getPane(paneConfig.name);
                        if (paneElement) paneElement.style.zIndex = paneConfig.zIndex;
                    }
                });
                console.log("Map panes created.");

                // --- SET MAP READY FLAG ---
                AppState.mapReady = true;
                console.log("AppState.mapReady set to true.");

                // --- Tile Layer, Controls, Layer Groups, Theme, Listeners ---
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapInstance);
                L.control.attribution({ prefix: '...' }).addTo(mapInstance);
                AppState.geofenceLayerGroup = L.layerGroup([], { pane: AppConfig.LEAFLET_PANES.GEOFECE.name }).addTo(mapInstance);
                this.updateMapThemeStyle(AppState.currentTheme === 'dark' || (AppState.currentTheme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches));
                document.getElementById('history-slider')?.addEventListener('input', this.handleHistorySliderChange.bind(this));

                // --- Attempt to add user marker NOW that map is ready ---
                if (AppState.locationMarker && this.shouldShowUserLocation()) {
                    console.log("User location marker exists, attempting addLayer immediately after map setup.");
                    if (!mapInstance.hasLayer(AppState.locationMarker)) {
                        try {
                            mapInstance.addLayer(AppState.locationMarker);
                            console.log("Added initial user location marker immediately after map setup.");
                        } catch (addLayerError) {
                            console.error("Error adding pre-existing user location marker immediately:", addLayerError);
                        }
                    }
                }

                // --- Render static markers ---
                this.renderSavedPlaceMarkers();

                // --- Fetch initial data, THEN update view and hide placeholder ---
                // Use AppActions if available, otherwise log error
                if (window.AppActions && typeof AppActions.fetchInitialData === 'function') {
                    AppActions.fetchInitialData().then(() => {
                        console.log("[Map Init] Initial data fetched (inside setupMapElements).");
                        onMapAndDataReady(); // Call final handler
                    }).catch(err => {
                        console.error("Error fetching initial data after map load:", err);
                        this.showMapErrorPlaceholder(`Data load failed: ${err.message}`);
                    });
                } else {
                    console.error("AppActions not available to fetch initial data!");
                    this.showMapErrorPlaceholder("Application Error: Cannot fetch data.");
                }
            }; // End setupMapElements

            mapInstance.once('load', () => {
                console.log("Map initial 'load' event fired.");
                setupMapElements();
            });

            loadTimeoutHandle = setTimeout(() => {
                if (!initialLoadComplete) {
                    console.warn("Map 'load' event timeout reached. Assuming map is ready enough.");
                    setupMapElements();
                }
            }, 8000);

            this.locateMeInitial();
            console.log("Map object created. Waiting for visual readiness...");

        } catch (error) {
            console.error("Error initializing map:", error);
            this.showMapErrorPlaceholder(`Map initialization failed: ${error.message}`);
            AppState.mapReady = false; // Ensure flag is false on error
            if (AppState.getMap()) { // Attempt cleanup if map object was partially created
                try { AppState.getMap().remove(); AppState.setMap(null); } catch (e) { }
            }
        }
    }, // End initMap

    updateMapThemeStyle: function (isDark) {
        const mapInstance = AppState.getMap();
        if (!mapInstance) return;
        let tileLayer = null;
        mapInstance.eachLayer(layer => {
            if (layer instanceof L.TileLayer && layer._url && layer._url.includes('openstreetmap')) {
                tileLayer = layer;
            }
        });
        if (tileLayer && tileLayer.getContainer) {
            const container = tileLayer.getContainer();
            if (container) {
                container.style.filter = isDark ? 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)' : '';
            }
        } else {
            console.warn("Could not find OSM tile layer to apply theme filter.");
        }
    },

    invalidateMapSize: function () {
        const mapInstance = AppState.getMap();
        if (mapInstance) {
            console.log("[Map Resize] Invalidating map size...");
            // --- Show placeholder BEFORE invalidating ---
            this.showMapPlaceholder("Adjusting map layout...");

            // Use requestAnimationFrame for smoother integration with browser rendering
            requestAnimationFrame(() => {
                try {
                    mapInstance.invalidateSize({ animate: false }); // Invalidate immediately
                    console.log("[Map Resize] invalidateSize() called.");

                    // --- Hide placeholder AFTER a short delay ---
                    // This allows the browser time to reflow and render the resized map tiles
                    setTimeout(() => {
                        this.hideMapPlaceholder();
                        console.log("[Map Resize] Placeholder hidden after delay.");
                    }, 150); // Adjust delay as needed (e.g., 100-200ms)

                } catch (e) {
                    console.error("[Map Resize] Error during invalidateSize:", e);
                    // Ensure placeholder hides even if invalidateSize fails
                    this.hideMapPlaceholder();
                }
            });
        }
    },

    // --- Geolocation & User Location ---
    locateMeInitial: function (callback) {
        console.log("Attempting initial location...");
        if (!navigator.geolocation) {
            if (window.AppUI) AppUI.showErrorDialog("Geolocation Unavailable", "Your browser does not support geolocation.");
            else console.error("Geolocation Unavailable");
            if (callback) callback();
            return;
        }
        navigator.geolocation.getCurrentPosition(
            (pos) => {
                this.initialPositionSuccess(pos); // Pass position object
                if (callback) callback();
            },
            (err) => {
                this.handleLocationError(err, "Initial location check failed.");
                if (callback) callback();
            },
            { timeout: 8000, enableHighAccuracy: false } // Options
        );
    },

    initialPositionSuccess: function (position) {
        console.log("Initial location success:", position.coords);
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        // --- ONLY create/update marker object here ---
        this.updateUserLocationMarker(lat, lng);
        // --- Defer adding to map until map is ready (handled in setupMapElements) ---
        this.updateLocationInfo(lat, lng); // Update text info immediately
        this.reverseGeocode(lat, lng); // Start geocoding immediately
    },

    locateMe: function () {
        console.log("Attempting location update...");
        document.getElementById('location-address-text').textContent = "Fetching address...";
        document.getElementById('location-coordinates-text').textContent = "Fetching coordinates...";
        document.getElementById('last-updated-text').textContent = "Updating...";
        if (!navigator.geolocation) {
            if (window.AppUI) AppUI.showErrorDialog("Geolocation Unavailable");
            else console.error("Geolocation Unavailable");
            return;
        }
        navigator.geolocation.getCurrentPosition(
            this.showPosition.bind(this), // Pass method reference
            (err) => this.handleLocationError(err, "Could not update location."), // Pass error handler
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Options
        );
    },

    showPosition: function (position) { // Called on *subsequent* location updates
        console.log("Location update success:", position.coords);
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        this.updateUserLocationMarker(lat, lng); // Update marker object state
        this.updateLocationInfo(lat, lng);
        this.reverseGeocode(lat, lng);
        // --- Let updateMapView handle adding/removing based on state ---
        this.updateMapView();
    },

    updateUserLocationMarker: function (lat, lng) {
        if (!AppState.locationMarker) {
            console.log("Creating user location marker object.");
            AppState.locationMarker = L.marker([lat, lng], {
                icon: this.userLocationIcon, zIndexOffset: 1000,
                pane: AppConfig.LEAFLET_PANES.USER.name // Specify pane
            });
        } else {
            AppState.locationMarker.setLatLng([lat, lng]);
            console.log("Updated user location marker object position.");
        }
        // NO addLayer here
    },


    updateLocationInfo: function (lat, lng) {
        document.getElementById('location-coordinates-text').textContent = `${lat.toFixed(5)}°, ${lng.toFixed(5)}°`;
        AppState.lastUpdateTime = new Date();
        document.getElementById('last-updated-text').textContent = `Last updated: ${window.AppUtils ? AppUtils.formatTimeRelative(AppState.lastUpdateTime) : 'just now'}`;
    },

    reverseGeocode: function (latitude, longitude) {
        const apiUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}&addressdetails=1`;
        console.log("Fetching address for:", latitude.toFixed(5), longitude.toFixed(5));
        // Use AppConfig if available, otherwise default
        const appVersion = window.AppConfig?.APP_VERSION || '?.?.?';
        fetch(apiUrl, { headers: { 'User-Agent': `FindMyWebApp/${appVersion}` } })
            .then(res => {
                if (!res.ok) return res.text().then(text => { throw new Error(`Nominatim error! status: ${res.status}, response: ${text}`) });
                return res.json();
            })
            .then(data => {
                let addr = data?.display_name || "Address not found";
                document.getElementById('location-address-text').textContent = addr;
                AppState.addToLocationHistory({
                    time: window.AppUtils ? AppUtils.formatTime(AppState.lastUpdateTime || new Date()) : new Date().toLocaleTimeString(),
                    location: "My Location",
                    address: addr,
                    lat: latitude,
                    lng: longitude
                });
            })
            .catch(err => {
                console.error("Reverse geocoding error:", err);
                document.getElementById('location-address-text').textContent = "Error fetching address";
                AppState.addToLocationHistory({
                    time: window.AppUtils ? AppUtils.formatTime(AppState.lastUpdateTime || new Date()) : new Date().toLocaleTimeString(),
                    location: "My Location",
                    address: "Error fetching address",
                    lat: latitude,
                    lng: longitude
                });
            });
    },

    handleLocationError: function (error, contextMessage = "Unable to retrieve your location.") {
        console.error("Geolocation Error:", error.code, error.message);
        let userMessage = contextMessage;
        switch (error.code) {
            case error.PERMISSION_DENIED: userMessage = "Location access denied by browser."; break;
            case error.POSITION_UNAVAILABLE: userMessage = "Location information is unavailable."; break;
            case error.TIMEOUT: userMessage = "Location request timed out."; break;
            default: userMessage = "An unknown error occurred getting location."; break;
        }
        if (window.AppUI) AppUI.showErrorDialog("Location Error", userMessage);
        else console.error("Location Error:", userMessage);

        document.getElementById('location-coordinates-text').textContent = "Location unavailable";
        document.getElementById('location-address-text').textContent = "Could not determine location";
        const lastUpdatedEl = document.getElementById('last-updated-text');
        if (lastUpdatedEl?.textContent.includes("Updating")) {
            lastUpdatedEl.textContent = "Update failed";
        }
    },

    shouldShowUserLocation: function () {
        // Show user location if not viewing a specific device AND no search result is active
        return !AppState.currentViewedDeviceId && !AppState.searchMarker;
    },

    // --- Map Markers & History ---
    updateDeviceMarker: function (deviceId) {
        const displayInfo = AppState.getDeviceDisplayInfo(deviceId);
        const latestReport = displayInfo.rawLocation;
        const mapInstance = AppState.getMap();
        if (!mapInstance) return;

        if (!latestReport || latestReport.lat == null || latestReport.lon == null) {
            // If no location, remove existing marker if it exists
            if (AppState.deviceMarkers[deviceId]) {
                if (mapInstance.hasLayer(AppState.deviceMarkers[deviceId])) {
                    mapInstance.removeLayer(AppState.deviceMarkers[deviceId]);
                }
                delete AppState.deviceMarkers[deviceId];
            }
            return; // No location to show
        }

        const markerLatLng = [latestReport.lat, latestReport.lon];
        const markerIcon = this.getDeviceLeafletIcon(displayInfo.label, displayInfo.color, displayInfo.svg_icon);
        const popupContent = this.generateHistoryPopupContent(latestReport, displayInfo);

        if (AppState.deviceMarkers[deviceId]) {
            // Update existing marker
            AppState.deviceMarkers[deviceId].setLatLng(markerLatLng).setIcon(markerIcon).setPopupContent(popupContent);
        } else {
            // Create new marker
            AppState.deviceMarkers[deviceId] = L.marker(markerLatLng, {
                icon: markerIcon,
                zIndexOffset: 600, // Default marker zIndex
                pane: AppConfig.LEAFLET_PANES.MARKERS.name // Ensure uses correct pane
            }).bindPopup(popupContent);
        }
        // Visibility (adding/removing from map) is handled in updateMapView
    },

    // --- History Trail Functions ---
    createOrUpdateDeviceHistoryLayer: function (deviceId) {
        const displayInfo = AppState.getDeviceDisplayInfo(deviceId);
        const reports = displayInfo.reports; // Get the full reports list from state
        const mapInstance = AppState.getMap();
        if (!mapInstance) return;

        // Clear layer if no reports
        if (!reports || reports.length < 1) {
            this.clearDeviceHistoryLayer(deviceId);
            return;
        }

        // Initialize layer group if it doesn't exist
        if (!AppState.deviceHistoryLayers[deviceId]) {
            AppState.deviceHistoryLayers[deviceId] = L.layerGroup([]);
            // console.log(`Created history LayerGroup for ${deviceId}`);
        } else {
            AppState.deviceHistoryLayers[deviceId].clearLayers(); // Clear before rebuilding
        }

        const historyPointsLatLngs = [];
        const historyPoints = [];
        const now = Date.now();
        const filterCutoff = now - (AppState.historyTimeFilterHours * 60 * 60 * 1000);

        reports.forEach((report) => {
            if (report.lat != null && report.lon != null && report.timestamp) {
                try {
                    const reportTime = new Date(report.timestamp).getTime();
                    // Filter points outside the selected time window
                    if (!isNaN(reportTime) && reportTime >= filterCutoff) {
                        const latLng = L.latLng(report.lat, report.lon);
                        historyPointsLatLngs.push(latLng);

                        // Calculate opacity based on age within the window
                        const ageRatio = Math.max(0, (reportTime - filterCutoff)) / (now - filterCutoff || 1);
                        const opacity = 0.3 + ageRatio * 0.5; // Fade older points
                        const radius = this.getHistoryPointOptions().radius; // Get default radius

                        // Create point marker and assign to correct pane
                        const pointMarker = L.circleMarker(latLng, {
                            ...this.getHistoryPointOptions(displayInfo.color, opacity, radius), // Pass calculated opacity and radius
                            pane: AppConfig.LEAFLET_PANES.HISTORY_POINT.name // Assign history point pane
                        }).bindPopup(this.generateHistoryPopupContent(report, displayInfo)); // Add popup
                        historyPoints.push(pointMarker);
                    }
                } catch (e) {
                    console.warn(`Error processing report timestamp for history: ${report.timestamp}`, e);
                }
            }
        });

        // Add polyline if more than one point, assign to correct pane
        if (historyPointsLatLngs.length > 1) {
            const line = L.polyline(historyPointsLatLngs, {
                ...this.getHistoryLineOptions(displayInfo.color), // Get line style options
                pane: AppConfig.LEAFLET_PANES.HISTORY_LINE.name // Assign history line pane
            });
            AppState.deviceHistoryLayers[deviceId].addLayer(line);
        }

        // Add all circle markers to the layer group
        historyPoints.forEach(marker => AppState.deviceHistoryLayers[deviceId].addLayer(marker));

        // Visibility of the layer group is handled separately by updateHistoryLayersVisibility
    },

    rebuildAllHistoryLayers: function () {
        // console.log("Rebuilding all history layers..."); // Can be noisy
        AppState.getCurrentDeviceData().forEach(device => this.createOrUpdateDeviceHistoryLayer(device.id));
        this.updateHistoryLayersVisibility(); // Update visibility after rebuilding
    },

    updateSingleHistoryLayerVisibility: function (deviceId) {
        const layer = AppState.deviceHistoryLayers[deviceId];
        const mapInstance = AppState.getMap();
        if (!layer || !mapInstance) return;

        const displayInfo = AppState.getDeviceDisplayInfo(deviceId);
        // Determine if history for this specific device should be shown
        const shouldShowHistory = AppState.showDeviceHistory && // Global toggle must be on
            displayInfo.isVisible && // Device must be visible
            (AppState.isShowingAllDevices || AppState.currentViewedDeviceId === deviceId); // AND (showing all OR viewing this specific device)

        if (shouldShowHistory) {
            if (!mapInstance.hasLayer(layer)) {
                layer.addTo(mapInstance); // Add layer group to map
            }
        } else {
            if (mapInstance.hasLayer(layer)) {
                mapInstance.removeLayer(layer); // Remove layer group from map
            }
        }
    },

    updateHistoryLayersVisibility: function () {
        // console.log("Updating visibility for all history layers..."); // Can be noisy
        // Iterate through all devices that might have a history layer
        Object.keys(AppState.deviceHistoryLayers).forEach(deviceId => this.updateSingleHistoryLayerVisibility(deviceId));
    },

    clearDeviceHistoryLayer: function (deviceId) {
        const mapInstance = AppState.getMap();
        if (AppState.deviceHistoryLayers[deviceId]) {
            if (mapInstance && mapInstance.hasLayer(AppState.deviceHistoryLayers[deviceId])) {
                mapInstance.removeLayer(AppState.deviceHistoryLayers[deviceId]);
            }
            delete AppState.deviceHistoryLayers[deviceId]; // Remove from state
        }
    },

    clearAllDeviceHistoryLayers: function () {
        Object.keys(AppState.deviceHistoryLayers).forEach(id => this.clearDeviceHistoryLayer(id));
        console.log("Cleared all device history layers.");
    },

    handleHistorySliderChange: function (event) { // Event listener callback
        const hours = parseInt(event.target.value, 10);
        if (isNaN(hours)) return;
        AppState.historyTimeFilterHours = hours; // Update state
        if (window.AppUI) AppUI.updateHistorySliderLabel(); // Update UI label
        AppState.saveMapToggles(); // Save the setting to localStorage

        if (AppState.showDeviceHistory) { // Only rebuild if history is currently visible
            console.log("History slider changed, rebuilding visible history layers...");
            this.rebuildAllHistoryLayers(); // Rebuild layers based on new time filter
        }
    },
    // --- End History Trail Functions ---

    updateAllDeviceMarkers: function () {
        // console.log("Updating all device markers..."); // Can be noisy
        const mapInstance = AppState.getMap();
        if (!mapInstance) return;
        const currentDeviceData = AppState.getCurrentDeviceData(); // Get fresh data

        // Update or create markers for current devices
        currentDeviceData.forEach(device => this.updateDeviceMarker(device.id));

        // Remove markers for devices that are no longer in the current data
        Object.keys(AppState.deviceMarkers).forEach(existingMarkerId => {
            if (!currentDeviceData.some(d => d.id === existingMarkerId)) {
                if (mapInstance.hasLayer(AppState.deviceMarkers[existingMarkerId])) {
                    mapInstance.removeLayer(AppState.deviceMarkers[existingMarkerId]);
                }
                delete AppState.deviceMarkers[existingMarkerId]; // Remove from state
                console.log(`Removed stale marker for ${existingMarkerId}`);
            }
        });
        // Visibility of markers is handled by updateMapView
    },

    generateHistoryPopupContent: function (report, displayInfo) {
        if (!report) return "No data available for this point.";

        // Safely create Date objects
        const markerTime = report.timestamp ? new Date(report.timestamp) : null;
        const publishedTime = report.published_at ? new Date(report.published_at) : null;

        const lat = report.lat;
        const lon = report.lon;
        const googleMapsLink = (lat != null && lon != null) ? `https://www.google.com/maps?q=${lat},${lon}` : '#';

        // Use AppUtils for parsing if available
        const [mappedBattPercent, batteryStatusStr] = window.AppUtils
            ? AppUtils._parseBatteryInfo(report.battery, report.status, AppConfig.LOW_BATTERY_THRESHOLD)
            : [null, report.battery || report.status || 'Unknown'];

        let batteryPercentStr = 'N/A';
        if (mappedBattPercent !== null) {
            batteryPercentStr = `${mappedBattPercent.toFixed(0)}%`;
        } else if (batteryStatusStr !== 'Unknown') {
            batteryPercentStr = batteryStatusStr;
        }

        // Helper for icons
        const icon = (name) => `<span class="material-symbols-outlined">${name}</span>`;

        // Get small SVG icon (use AppUtils or basic fallback)
        const smallSvgIconHtml = window.AppUtils
            ? AppUtils.generateDeviceIconSVG(displayInfo.label, displayInfo.color, 20)
            : `<div style="display:inline-block; width:20px; height:20px; border-radius:50%; background-color:${displayInfo.color || '#ccc'}; vertical-align:middle; margin-right: 5px;"></div>`; // Very basic circle fallback

        const labelHtml = `<span style="display:inline-block; width:20px; height:20px; vertical-align:middle; margin-right: 5px;">${smallSvgIconHtml}</span>`;

        // Build HTML table content
        let content = `<div style="font-size: var(--body-small-size); max-width: 280px;"><table class="history-popup-table">`;
        content += `<tr><td>${icon('sell')}</td><td colspan="2" style="font-weight: bold;">${labelHtml}${displayInfo.name}</td></tr>`;
        content += `<tr><td>${icon('schedule')}</td><td>Located:</td><td>${markerTime ? (window.AppUtils ? AppUtils.formatTime(markerTime) : markerTime.toLocaleString()) : 'N/A'}</td></tr>`;
        // Show published time only if different from location timestamp
        if (publishedTime && (!markerTime || publishedTime.getTime() !== markerTime.getTime())) {
            content += `<tr><td>${icon('publish')}</td><td>Reported:</td><td>${window.AppUtils ? AppUtils.formatTime(publishedTime) : publishedTime.toLocaleString()}</td></tr>`;
        }
        content += `<tr><td>${icon('location_on')}</td><td>Coords:</td><td><a href="${googleMapsLink}" target="_blank">${lat != null ? `${lat.toFixed(5)}°, ${lon.toFixed(5)}°` : 'N/A'}</a></td></tr>`;
        content += `<tr><td>${icon('battery_std')}</td><td>Battery:</td><td>${batteryPercentStr}${report.status !== null ? ` <small>(S:${report.status})</small>` : ''}</td></tr>`;
        content += `<tr><td>${icon('my_location')}</td><td>Accuracy:</td><td>${report.horizontalAccuracy != null ? `±${report.horizontalAccuracy.toFixed(0)}m` : 'N/A'}</td></tr>`;
        if (report.altitude != null) {
            content += `<tr><td>${icon('height')}</td><td>Altitude:</td><td>${report.altitude.toFixed(0)}m ${report.verticalAccuracy != null ? `(±${report.verticalAccuracy.toFixed(0)}m)` : ''}</td></tr>`;
        }
        if (report.description) {
            content += `<tr><td>${icon('info')}</td><td>Desc:</td><td>${report.description}</td></tr>`;
        }
        if (report.confidence != null) {
            content += `<tr><td>${icon('verified')}</td><td>Confidence:</td><td>${report.confidence}</td></tr>`;
        }
        content += `</table></div>`;
        return content;
    },

    // --- Saved Places ---
    renderSavedPlaceMarkers: function () {
        // console.log("Rendering saved place markers..."); // Can be noisy
        const mapInstance = AppState.getMap();
        if (!mapInstance) return;
        const savedPlaces = AppState.savedPlaces;

        // Remove markers that no longer exist in savedPlaces
        AppState.savedPlaceMarkers = AppState.savedPlaceMarkers.filter(marker => {
            const markerLL = marker.getLatLng();
            const stillExists = savedPlaces.some(p => p.lat === markerLL.lat && p.lng === markerLL.lng);
            if (!stillExists && mapInstance.hasLayer(marker)) {
                mapInstance.removeLayer(marker); // Remove from map if deleted
            }
            return stillExists; // Keep in the array only if it still exists
        });

        // Add markers for places that don't have one yet
        savedPlaces.forEach(p => {
            if (p.lat != null && p.lng != null) {
                // Check if a marker for this exact place already exists in our array
                const markerExists = AppState.savedPlaceMarkers.some(m => {
                    const ll = m.getLatLng();
                    return ll.lat === p.lat && ll.lng === p.lng;
                });

                if (!markerExists) {
                    const m = L.marker([p.lat, p.lng], {
                        icon: this.savedPlaceIcon,
                        zIndexOffset: 550, // z-index
                        pane: AppConfig.LEAFLET_PANES.SAVED_PLACES.name // Assign pane
                    }).bindPopup(`<b>${p.name}</b><br>${p.description || 'Saved Place'}`);
                    AppState.savedPlaceMarkers.push(m); // Add new marker to our array
                    // Adding to map is handled by updateMapView
                }
            }
        });
        // Visibility (adding/removing from map) is handled by updateMapView
    },

    clearSavedPlaceMarkersFromDisplay: function () {
        const mapInstance = AppState.getMap();
        if (!mapInstance) return;
        AppState.savedPlaceMarkers.forEach(m => {
            if (mapInstance.hasLayer(m)) mapInstance.removeLayer(m);
        });
        console.log("Cleared saved place markers from map display.");
        // Note: This only removes them from view, doesn't delete from AppState.savedPlaceMarkers array
    },

    // --- Search ---
    searchLocation: function () {
        console.warn("AppMap.searchLocation called, but global search should handle this now via AppActions.performSearch.");
        // This function can potentially be removed if not used elsewhere.
    },

    geocodeAddress: function (address, focusInput = true) {
        console.log(`Geocoding address: "${address}"`);
        AppState.currentViewedDeviceId = null; // Stop viewing specific device
        if (window.AppUI) AppUI.changePage('index'); // Switch to map page
        this.clearSearchMarker(); // Remove previous search marker

        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`;
        // Use AppConfig if available, otherwise default
        const appVersion = window.AppConfig?.APP_VERSION || '?.?.?';
        fetch(url, { headers: { 'User-Agent': `FindMyWebApp/${appVersion}` } })
            .then(res => {
                if (!res.ok) return res.text().then(text => { throw new Error(`Nominatim error ${res.status}: ${text}`) });
                return res.json();
            })
            .then(data => {
                if (data?.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lng = parseFloat(result.lon);
                    console.log("Geocode result:", result.display_name, lat, lng);

                    // Update search bar text if requested
                    if (focusInput) {
                        const searchInput = document.getElementById('location-search-input');
                        if (searchInput) searchInput.value = result.display_name; // Display full result name
                    }

                    // Add marker and update map view
                    this.addSearchMarker(lat, lng, result.display_name);
                    this.updateMapView(); // Focus on the search result
                } else {
                    console.warn("Location not found:", address);
                    if (window.AppUI) AppUI.showErrorDialog("Search Result", `Could not find location for "${address}".`);
                }
            })
            .catch(err => {
                console.error("Geocoding error:", err);
                if (window.AppUI) AppUI.showErrorDialog("Search Error", "An error occurred while searching.");
            });
    },

    addSearchMarker: function (lat, lng, address) {
        // Create the marker object and store it in state
        AppState.searchMarker = L.marker([lat, lng], {
            icon: this.searchIcon,
            zIndexOffset: 900, // High z-index
            pane: AppConfig.LEAFLET_PANES.SEARCH.name // Assign search pane
        }).bindPopup(`<b>Search Result:</b><br>${address}`);
        // Visibility (adding/removing from map) is handled by updateMapView
    },

    clearSearchMarker: function () {
        if (AppState.searchMarker) {
            const mapInstance = AppState.getMap();
            if (mapInstance && mapInstance.hasLayer(AppState.searchMarker)) {
                mapInstance.removeLayer(AppState.searchMarker);
            }
            AppState.searchMarker = null; // Clear from state
        }
    },

    clearSearchMarkerAndFocus: function () {
        // Wrapper function for convenience, e.g., called when search bar is cleared
        if (AppState.searchMarker) {
            this.clearSearchMarker();
            this.updateMapView(); // Refocus map based on remaining elements
        }
    },

    // --- Map View Update ---
    updateMapView: function () {
        // --- *** ADD GUARD CONDITION *** ---
        if (!AppState.mapReady) {
            console.warn("updateMapView called before map is ready (AppState.mapReady is false). Skipping layer additions.");
            return; // Exit early if map panes aren't ready
        }
        // --- ************************* ---

        // console.log("Updating map view..."); // Can be noisy
        const mapInstance = AppState.getMap();
        if (!mapInstance) {
            console.error("updateMapView called but map instance is null.");
            return;
        }

        let bounds = L.latLngBounds();
        let activeElements = [];

        // Update state/objects first (these don't rely on mapReady)
        this.updateAllDeviceMarkers(); // Ensures marker objects exist/are updated
        this.renderSavedPlaceMarkers(); // Ensures place marker objects exist/are updated
        this.rebuildAllHistoryLayers(); // Recreates history layers based on filters, updates their visibility state
        this.redrawGeofenceLayer();    // Recreates geofence layers

        // --- Add/Remove layers to the map (SAFE NOW due to guard clause) ---
        const showUser = this.shouldShowUserLocation();
        if (showUser && AppState.locationMarker && (AppState.locationMarker.getLatLng().lat !== 0 || AppState.locationMarker.getLatLng().lng !== 0)) {
            if (!mapInstance.hasLayer(AppState.locationMarker)) {
                try { mapInstance.addLayer(AppState.locationMarker); }
                catch (e) { console.error("Error adding user marker in updateMapView:", e); }
            }
            if (mapInstance.hasLayer(AppState.locationMarker)) {
                bounds.extend(AppState.locationMarker.getLatLng());
                activeElements.push(AppState.locationMarker);
            }
        } else {
            if (AppState.locationMarker && mapInstance.hasLayer(AppState.locationMarker)) {
                mapInstance.removeLayer(AppState.locationMarker);
            }
        }

        // Device Markers
        Object.keys(AppState.deviceMarkers).forEach(deviceId => {
            const marker = AppState.deviceMarkers[deviceId];
            const displayInfo = AppState.getDeviceDisplayInfo(deviceId);
            const shouldShowDeviceMarker = displayInfo.isVisible && (AppState.isShowingAllDevices || AppState.currentViewedDeviceId === deviceId);
            if (marker) {
                if (shouldShowDeviceMarker) {
                    if (!mapInstance.hasLayer(marker)) {
                        try { mapInstance.addLayer(marker); }
                        catch (e) { console.error(`Error adding device marker ${deviceId}:`, e); }
                    }
                    if (mapInstance.hasLayer(marker)) {
                        bounds.extend(marker.getLatLng());
                        activeElements.push(marker);
                    }
                } else {
                    if (mapInstance.hasLayer(marker)) mapInstance.removeLayer(marker);
                }
            }
        });

        // History Layer Bounds (Visibility already handled, just extend bounds if on map)
        if (AppState.showDeviceHistory) {
            Object.keys(AppState.deviceHistoryLayers).forEach(deviceId => {
                const layer = AppState.deviceHistoryLayers[deviceId];
                if (layer && mapInstance.hasLayer(layer) && typeof layer.getBounds === 'function') {
                    try {
                        const layerBounds = layer.getBounds();
                        if (layerBounds.isValid()) { bounds.extend(layerBounds); }
                    } catch (e) { console.warn(`Could not get bounds for history layer ${deviceId}`, e); }
                }
            });
        }

        // Saved Place Markers
        AppState.savedPlaceMarkers.forEach(marker => {
            if (AppState.isShowingAllDevices) {
                if (!mapInstance.hasLayer(marker)) {
                    try { mapInstance.addLayer(marker); }
                    catch (e) { console.error("Error adding saved place marker:", e); }
                }
                if (mapInstance.hasLayer(marker)) {
                    bounds.extend(marker.getLatLng());
                    activeElements.push(marker);
                }
            } else {
                if (mapInstance.hasLayer(marker)) mapInstance.removeLayer(marker);
            }
        });

        // Search Marker
        if (AppState.searchMarker) {
            const shouldShowSearch = !AppState.isShowingAllDevices && !AppState.currentViewedDeviceId;
            if (shouldShowSearch) {
                if (!mapInstance.hasLayer(AppState.searchMarker)) {
                    try { mapInstance.addLayer(AppState.searchMarker); }
                    catch (e) { console.error("Error adding search marker:", e); }
                }
                if (mapInstance.hasLayer(AppState.searchMarker)) {
                    bounds.extend(AppState.searchMarker.getLatLng());
                    activeElements.push(AppState.searchMarker);
                }
            } else {
                if (mapInstance.hasLayer(AppState.searchMarker)) mapInstance.removeLayer(AppState.searchMarker);
            }
        }

        // --- Fit Bounds or Set View (Keep existing logic) ---
        if (activeElements.length > 0 && bounds.isValid()) {
            if (activeElements.length === 1) {
                const singleElement = activeElements[0];
                let zoomLevel = 16;
                if (singleElement === AppState.searchMarker) zoomLevel = 15;
                else if (singleElement === AppState.locationMarker) { zoomLevel = Math.max(mapInstance.getZoom(), 15); }
                mapInstance.setView(singleElement.getLatLng(), zoomLevel);
            } else {
                mapInstance.fitBounds(bounds, { padding: [50, 50], maxZoom: 17 });
            }
        } else if (showUser && AppState.locationMarker && mapInstance.hasLayer(AppState.locationMarker)) {
            mapInstance.setView(AppState.locationMarker.getLatLng(), Math.max(mapInstance.getZoom(), 15));
        } else if (activeElements.length === 0) {
            console.log("No active elements to focus on. Map view unchanged.");
        }

        // Update UI button states
        if (window.AppUI) AppUI.updateShowAllButtonState();
        if (window.AppUI) AppUI.updateShowHistoryButtonState();
    }, // End updateMapView


    // --- Map Interactions ---
    viewDeviceOnMap: function (deviceId) {
        const device = AppState.getDeviceDisplayInfo(deviceId);
        if (!device || device.lat == null || device.lng == null) {
            if (window.AppUI) AppUI.showErrorDialog("Location Unavailable", `No recent location found for "${device?.name || deviceId}".`);
            return;
        }
        console.log("Viewing device on map:", device.name);
        AppState.currentViewedDeviceId = deviceId; // Set the currently viewed device
        this.clearSearchMarker(); // Clear any active search
        if (window.AppUI) AppUI.changePage('index'); // Ensure map page is visible

        // Use setTimeout to ensure page change/render completes before map interaction
        setTimeout(() => {
            const mapInstance = AppState.getMap();
            if (!mapInstance) return;
            this.updateMapView(); // Update map to show only this device (and history if enabled)
            // Use another short delay before opening popup
            setTimeout(() => {
                const marker = AppState.deviceMarkers[deviceId];
                if (marker && mapInstance.hasLayer(marker)) { // Check if marker exists and is on map
                    try { marker.openPopup(); } // Attempt to open its popup
                    catch (e) { console.warn("Error opening popup for device:", deviceId, e); }
                }
            }, 200); // Delay for popup opening
        }, 50); // Delay after page change
    },

    viewPlaceOnMap: function (placeIndex) {
        const place = AppState.savedPlaces[placeIndex];
        if (!place || place.lat == null || place.lng == null) {
            if (window.AppUI) AppUI.showErrorDialog("Location Unavailable", "No coordinates saved for this place.");
            return;
        }
        console.log("Viewing place on map:", place.name);
        AppState.currentViewedDeviceId = null; // Not viewing a specific device
        this.clearSearchMarker(); // Clear any active search
        if (window.AppUI) AppUI.changePage('index'); // Ensure map page is visible

        setTimeout(() => {
            const mapInstance = AppState.getMap();
            if (!mapInstance) return;
            // Don't call updateMapView here, as it might zoom out if 'Show All' isn't active
            // Instead, manually center and zoom, and ensure the marker is visible
            let targetMarker = AppState.savedPlaceMarkers.find(m => {
                const ll = m.getLatLng();
                return ll.lat === place.lat && ll.lng === place.lng;
            });

            // Center map on the place
            mapInstance.setView([place.lat, place.lng], 16); // Set desired zoom level

            // Ensure the marker is added and open popup
            if (targetMarker) {
                if (!mapInstance.hasLayer(targetMarker)) {
                    mapInstance.addLayer(targetMarker); // Add if not already present
                }
                targetMarker.openPopup(); // Open popup
            } else {
                console.warn("Could not find marker for saved place index:", placeIndex);
            }
        }, 50); // Delay after page change
    },

    viewGeofenceOnMap: function (geofenceId) {
        const geofence = AppState.getGlobalGeofences().find(gf => gf.id === geofenceId);
        if (!geofence || geofence.lat == null || geofence.lng == null) {
            if (window.AppUI) AppUI.showErrorDialog("Geofence Error", `Could not find data or location for geofence ID "${geofenceId}".`);
            return;
        }
        console.log("Viewing geofence on map:", geofence.name);
        AppState.currentViewedDeviceId = null; // Not viewing specific device
        this.clearSearchMarker(); // Clear search
        if (window.AppUI) AppUI.changePage('index'); // Ensure map page

        setTimeout(() => {
            const mapInstance = AppState.getMap();
            if (!mapInstance) return;

            let targetLayer = null;
            // Find the circle layer associated with this geofence ID
            AppState.geofenceLayerGroup?.eachLayer(layer => {
                // Check if it's a circle and has the matching geofenceId option
                if (layer instanceof L.Circle && layer.options && layer.options.geofenceId === geofenceId) {
                    targetLayer = layer;
                }
            });

            // Fit map bounds to the geofence area
            // Calculate bounds slightly larger than the circle radius for padding
            mapInstance.fitBounds(L.latLng(geofence.lat, geofence.lng).toBounds(geofence.radius * 2.5), { maxZoom: 16 });

            // Open the tooltip associated with the geofence circle
            if (targetLayer && targetLayer.openTooltip) {
                targetLayer.openTooltip(); // Open the tooltip (usually name)
            } else {
                console.warn("Could not find layer or tooltip for geofence", geofenceId);
            }
        }, 50); // Delay after page change
    },


    // --- Dialog Maps ---
    initPlacePickerDialogMap: function () {
        const searchInput = document.getElementById('place-picker-search-input');
        const searchError = document.getElementById('place-picker-search-error');
        const mapId = 'place-picker-map';
        const mapState = AppState.placePickerDialog;

        if (mapState.map) {
            // If map exists, just reset and center it
            mapState.map.invalidateSize(); // Ensure size is correct
            searchInput.value = ''; // Clear search
            searchError.style.display = 'none'; // Hide error
            this.centerDialogMapOnUserLocation('place', true); // Attempt to center on user
            return; // Don't reinitialize
        }

        try {
            const mapEl = document.getElementById(mapId);
            if (!mapEl) { console.error("Place picker map element not found:", mapId); return; }

            mapState.map = L.map(mapId, { zoomControl: false, attributionControl: false }).setView([0, 0], 2); // Default view
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapState.map);

            // Create marker, make draggable
            mapState.marker = L.marker([0, 0], { // Initial position (will be updated)
                icon: this.placePickerIcon,
                draggable: true,
                zIndexOffset: 1000 // Ensure draggable marker is on top
            }).addTo(mapState.map);

            // Update coordinates on marker drag
            mapState.marker.on('dragend', e => {
                const p = e.target.getLatLng();
                document.getElementById('new-place-lat').value = p.lat.toFixed(5);
                document.getElementById('new-place-lng').value = p.lng.toFixed(5);
            });

            // Update marker position and coordinates on map click
            mapState.map.on('click', e => {
                mapState.marker.setLatLng(e.latlng);
                document.getElementById('new-place-lat').value = e.latlng.lat.toFixed(5);
                document.getElementById('new-place-lng').value = e.latlng.lng.toFixed(5);
            });

            this.centerDialogMapOnUserLocation('place', true); // Attempt to center on user initially
            // Invalidate size after dialog is fully visible
            setTimeout(() => { if (mapState.map) mapState.map.invalidateSize(); }, 200);
        } catch (error) {
            console.error("Error initializing place picker map:", error);
            if (window.AppUI) AppUI.showErrorDialog("Map Error", "Could not initialize map.");
            if (window.AppUI) AppUI.closeDialog('add-place-dialog'); // Close dialog on error
        }
    },

    destroyPlacePickerDialogMap: function () {
        const mapState = AppState.placePickerDialog;
        if (mapState.map) {
            console.log("Destroying place picker dialog map");
            // Remove event listeners before removing map
            mapState.marker?.off(); // Remove listeners from marker
            mapState.map.off(); // Remove listeners from map
            mapState.map.remove(); // Remove map instance
            mapState.map = null;
            mapState.marker = null;
        }
    },

    initGeofenceDialogMap: function (centerLatLng, zoom, initialRadius) {
        const searchInput = document.getElementById('geofence-picker-search-input');
        const searchError = document.getElementById('geofence-picker-search-error');
        const radiusInput = document.getElementById('geofence-radius');
        const mapId = 'geofence-picker-map';
        const mapState = AppState.geofenceDialog;

        // If map already exists, just update its state
        if (mapState.map) {
            mapState.map.setView(centerLatLng, zoom);
            if (mapState.marker) mapState.marker.setLatLng(centerLatLng);
            if (mapState.circle) {
                mapState.circle.setLatLng(centerLatLng);
                mapState.circle.setRadius(initialRadius);
            }
            // Invalidate size shortly after potential dialog resize/display change
            setTimeout(() => { if (mapState.map) mapState.map.invalidateSize(); }, 100);
            // Reset UI elements
            searchInput.value = '';
            searchError.style.display = 'none';
            radiusInput.value = initialRadius;
            return; // Don't reinitialize
        }

        // Initialize map if it doesn't exist
        try {
            const mapEl = document.getElementById(mapId);
            if (!mapEl) { console.error("Geofence picker map element not found:", mapId); return; }

            mapState.map = L.map(mapId, { zoomControl: false, attributionControl: false }).setView(centerLatLng, zoom);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapState.map);

            // Create draggable center marker
            mapState.marker = L.marker(centerLatLng, {
                icon: this.geofenceCenterIcon,
                draggable: true,
                zIndexOffset: 1000 // Keep marker on top
            }).addTo(mapState.map);

            // Create radius circle
            mapState.circle = L.circle(centerLatLng, {
                radius: initialRadius,
                color: 'var(--m3-sys-color-primary)', // Use CSS variable
                fillColor: 'var(--m3-sys-color-primary)',
                fillOpacity: 0.15,
                weight: 2
            }).addTo(mapState.map);

            // Event listeners
            mapState.marker.on('drag', this.updateGeofenceFromMarker.bind(this));
            mapState.marker.on('dragend', this.updateGeofenceFromMarker.bind(this));
            mapState.map.on('click', (e) => {
                if (mapState.marker) mapState.marker.setLatLng(e.latlng);
                this.updateGeofenceFromMarker(); // Update inputs and circle
            });
            radiusInput.addEventListener('input', this.updateGeofenceCircleFromRadius.bind(this));
            radiusInput.addEventListener('change', this.updateGeofenceCircleFromRadius.bind(this)); // Also on change

            // Invalidate size after dialog is fully visible
            setTimeout(() => { if (mapState.map) mapState.map.invalidateSize(); }, 200);
        } catch (error) {
            console.error("Error initializing geofence picker map:", error);
            if (window.AppUI) AppUI.showErrorDialog("Map Error", "Could not initialize map.");
            if (window.AppUI) AppUI.closeDialog('geofence-dialog'); // Close dialog on error
        }
    },

    destroyGeofenceDialogMap: function () {
        const mapState = AppState.geofenceDialog;
        if (mapState.map) {
            console.log("Destroying geofence dialog map");
            const radiusInput = document.getElementById('geofence-radius');
            // Remove specific listeners added during init
            if (radiusInput) {
                radiusInput.removeEventListener('input', this.updateGeofenceCircleFromRadius);
                radiusInput.removeEventListener('change', this.updateGeofenceCircleFromRadius);
            }
            mapState.marker?.off(); // Remove listeners from marker
            mapState.map.off(); // Remove listeners from map
            mapState.map.remove(); // Remove map instance
            mapState.map = null;
            mapState.marker = null;
            mapState.circle = null;
        }
    },

    updateGeofenceFromMarker: function () {
        const mapState = AppState.geofenceDialog;
        if (!mapState.marker) return;

        const latLng = mapState.marker.getLatLng();
        // Update input fields
        document.getElementById('geofence-lat').value = latLng.lat.toFixed(5);
        document.getElementById('geofence-lng').value = latLng.lng.toFixed(5);
        // Update circle position
        if (mapState.circle) {
            mapState.circle.setLatLng(latLng);
        }
    },

    updateGeofenceCircleFromRadius: function () {
        const mapState = AppState.geofenceDialog;
        if (!mapState.circle) return;

        const radiusInput = document.getElementById('geofence-radius');
        const radius = parseFloat(radiusInput.value);
        // Update circle radius if valid
        if (!isNaN(radius) && radius > 0) {
            mapState.circle.setRadius(radius);
        }
    },

    centerDialogMapOnUserLocation: function (dialogType) {
        console.log(`Centering ${dialogType} dialog map on user location...`);
        if (!navigator.geolocation) {
            if (window.AppUI) AppUI.showErrorDialog("Geolocation Unavailable", "Cannot get your current location.");
            return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const latLng = L.latLng(lat, lng);
                console.log("User location for dialog:", lat, lng);

                let mapState, map, marker, circle, latInputId, lngInputId;

                if (dialogType === 'place') {
                    mapState = AppState.placePickerDialog;
                    latInputId = 'new-place-lat';
                    lngInputId = 'new-place-lng';
                } else if (dialogType === 'geofence') {
                    mapState = AppState.geofenceDialog;
                    latInputId = 'geofence-lat';
                    lngInputId = 'geofence-lng';
                } else {
                    console.error("Invalid dialog type for centering:", dialogType);
                    return;
                }

                map = mapState.map;
                marker = mapState.marker;
                circle = mapState.circle; // Will be null for 'place' dialog

                if (map) {
                    map.setView(latLng, 15); // Zoom in closer than default
                }
                if (marker) {
                    marker.setLatLng(latLng); // Move marker to user location
                }
                if (circle) { // Only update circle for geofence dialog
                    circle.setLatLng(latLng); // Move circle center
                }
                // Update coordinate input fields
                const latInput = document.getElementById(latInputId);
                const lngInput = document.getElementById(lngInputId);
                if (latInput) latInput.value = lat.toFixed(5);
                if (lngInput) lngInput.value = lng.toFixed(5);

            },
            (error) => {
                // Use the shared error handler
                this.handleLocationError(error, `Could not center ${dialogType} map on your location.`);
            },
            // Geolocation options
            { enableHighAccuracy: true, timeout: 8000, maximumAge: 60000 } // Allow cached position up to 1 min
        );
    },


    handleDialogSearch: function (mapStateObj, searchInputId, searchErrorId, latInputId, lngInputId, radiusInputId = null) {
        const searchInput = document.getElementById(searchInputId);
        const errorElement = document.getElementById(searchErrorId);
        const query = searchInput.value.trim();
        errorElement.textContent = '';
        errorElement.style.display = 'none';

        if (!query || !mapStateObj || !mapStateObj.map || !mapStateObj.marker) {
            console.warn("Dialog search prerequisites not met.");
            return; // Exit if essential elements are missing
        }

        console.log(`Dialog search started for '${query}'`);
        searchInput.disabled = true; // Disable input during search

        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(query)}&limit=1`;
        // Use AppConfig if available, otherwise default
        const appVersion = window.AppConfig?.APP_VERSION || '?.?.?';
        fetch(url, { headers: { 'User-Agent': `FindMyWebApp/${appVersion}` } })
            .then(res => {
                if (!res.ok) return res.text().then(text => { throw new Error(`Nominatim error ${res.status}: ${text}`) });
                return res.json();
            })
            .then(data => {
                if (data?.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lng = parseFloat(result.lon);
                    const latLng = L.latLng(lat, lng);

                    // Update map view, marker position, and coordinate inputs
                    mapStateObj.map.setView(latLng, 15); // Zoom in on result
                    mapStateObj.marker.setLatLng(latLng);
                    document.getElementById(latInputId).value = lat.toFixed(5);
                    document.getElementById(lngInputId).value = lng.toFixed(5);

                    // Update circle position if it's the geofence dialog
                    if (radiusInputId && mapStateObj.circle) {
                        mapStateObj.circle.setLatLng(latLng);
                    }
                    // Optionally update the search input with the full result name
                    // searchInput.value = result.display_name;
                } else {
                    // No results found
                    errorElement.textContent = `Could not find "${query}".`;
                    errorElement.style.display = 'block';
                }
            })
            .catch(err => {
                console.error("Dialog geocoding error:", err);
                errorElement.textContent = `Search error: ${err.message}.`;
                errorElement.style.display = 'block';
            })
            .finally(() => {
                searchInput.disabled = false; // Re-enable input
            });
    },

    // --- Geofence Layer ---
    redrawGeofenceLayer: function () {
        const mapInstance = AppState.getMap();
        const layerGroup = AppState.geofenceLayerGroup;
        const geofences = AppState.getGlobalGeofences(); // Get current global geofences

        if (!mapInstance || !layerGroup) return; // Ensure map and layer group exist

        // console.log("Redrawing geofence layer on main map..."); // Can be noisy
        layerGroup.clearLayers(); // Remove all existing geofence circles/tooltips

        geofences.forEach(gf => {
            // Create the circle for the geofence
            const circle = L.circle([gf.lat, gf.lng], {
                radius: gf.radius,
                className: 'geofence-circle', // CSS class for styling
                pane: AppConfig.LEAFLET_PANES.GEOFECE.name, // Assign to non-interactive pane
                geofenceId: gf.id // Store ID for potential future identification
            });

            // Bind a tooltip (shows on hover) with the geofence name
            circle.bindTooltip(gf.name, {
                permanent: false, // Show only on hover/focus by default
                sticky: true, // Follow the mouse cursor
                direction: 'top', // Position above the cursor
                className: 'geofence-tooltip', // CSS class for styling
                // offset: L.point(0, -gf.radius) // Optional: Offset slightly above circle edge
            });

            // Add the styled circle with tooltip to the layer group
            layerGroup.addLayer(circle);
        });
        // console.log(`Added ${geofences.length} geofences to map layer.`); // Can be noisy
    },

}; // End of window.AppMap definition
// --------------------
// app\static\js\notifications.js
// app/static/js/notifications.js


window.AppNotifications = {
    registerServiceWorker: function () {
        if (!('serviceWorker' in navigator)) {
            console.warn('Service workers are not supported.');
            this.updateNotificationButtonState(); // Update UI to show not supported
            return Promise.reject('Service workers not supported');
        }

        console.log("Registering Service Worker at /sw.js");
        // Register SW script located at the root, controlling the root scope
        return navigator.serviceWorker.register("/public/sw.js", { scope: '/' })
            .then(reg => {
                console.log('Service Worker registered successfully. Scope:', reg.scope);
                AppState.swRegistration = reg; // Store registration in state

                reg.onupdatefound = () => {
                    const installingWorker = reg.installing;
                    if (installingWorker == null) return;
                    installingWorker.onstatechange = () => {
                        if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            console.log('New content is available; please refresh.');
                            AppUI.showConfirmationDialog("Update Available", "A new version of the app is available. Please refresh the page.", () => window.location.reload());
                        } else if (installingWorker.state === 'installed') {
                            console.log('Content is cached for offline use.');
                        }
                    };
                };

                this.updateNotificationButtonState();
                return navigator.serviceWorker.ready;
            })
            .then(readyRegistration => {
                console.log('Service Worker is active and ready.');
                AppState.swRegistration = readyRegistration; // Ensure state has the active registration
                this.ensureSubscription();

                navigator.serviceWorker.addEventListener('message', event => {
                    console.log('[Client] Received message from SW:', event.data);
                    if (event.data?.type === 'focusDevice' && event.data.deviceId) {
                        console.log(`[Client] Attempting to focus on device ${event.data.deviceId}`);
                        if (document.getElementById('index-page')?.style.display !== 'block') {
                            AppUI.changePage('index');
                            setTimeout(() => AppMap.viewDeviceOnMap(event.data.deviceId), 300);
                        } else {
                            AppMap.viewDeviceOnMap(event.data.deviceId);
                        }
                    }
                });
                return readyRegistration;
            })
            .catch(err => {
                console.error('Service Worker registration failed:', err);
                let message = `Could not register service worker. Check console for details. Error: ${err.message}`;
                if (err.name === 'SecurityError') { message = `Registration failed due to security restrictions. Ensure the page is served over HTTPS (except for localhost) and the 'Service-Worker-Allowed' header is correctly set if the script is not at the root. Error: ${err.message}`; }
                AppUI.showErrorDialog("Service Worker Error", message);
                this.updateNotificationButtonState();
                throw err;
            });

        navigator.serviceWorker.addEventListener('controllerchange', () => {
            console.log('Service Worker controller changed (new worker activated). Reloading recommended.');
            // window.location.reload();
        });
    },

    updateNotificationButtonState: function () {
        const notifyButton = document.getElementById('enable-notifications-button');
        const notifyStatus = document.getElementById('notification-status');
        const unsubscribeButton = document.getElementById('unsubscribe-button');
        const testButton = document.getElementById('test-notification-button');

        if (!notifyButton || !notifyStatus || !unsubscribeButton || !testButton) {
            // console.warn("Notification UI elements not found. Cannot update state.");
            return;
        }

        unsubscribeButton.style.display = 'none';
        notifyButton.disabled = false;
        notifyButton.textContent = "Enable Notifications";
        testButton.style.display = 'none';

        if (!('Notification' in window) || !('PushManager' in window) || !('serviceWorker' in navigator)) {
            notifyStatus.textContent = "Not supported by browser";
            notifyButton.disabled = true;
            notifyButton.textContent = "Notifications N/A";
            return;
        }

        if (!AppConfig.VAPID_PUBLIC_KEY) {
            notifyStatus.textContent = "Disabled by server";
            notifyButton.disabled = true;
            notifyButton.textContent = "Notifications N/A";
            return;
        }

        const permission = Notification.permission;
        notifyStatus.textContent = `Permission: ${permission}`;

        if (!AppState.swRegistration) {
            if (permission === 'denied') { notifyStatus.textContent = "Blocked by browser"; notifyButton.textContent = "Notifications Blocked"; notifyButton.disabled = true; }
            else if (permission === 'default') { notifyStatus.textContent = "Click to enable"; }
            else { notifyStatus.textContent = "Enabled (Initializing...)"; notifyButton.textContent = "Subscribe"; }
            return;
        }

        AppState.swRegistration.pushManager.getSubscription()
            .then(subscription => {
                AppState.currentPushSubscription = subscription;

                switch (permission) {
                    case 'granted':
                        if (subscription) {
                            notifyStatus.textContent = "Enabled & Subscribed"; notifyButton.textContent = "Subscribed"; notifyButton.disabled = true; unsubscribeButton.style.display = 'inline-flex'; unsubscribeButton.disabled = false; testButton.style.display = 'inline-flex';
                        } else { notifyStatus.textContent = "Enabled, Not Subscribed"; notifyButton.textContent = "Subscribe"; notifyButton.disabled = false; }
                        break;
                    case 'denied':
                        notifyStatus.textContent = "Blocked by browser"; notifyButton.textContent = "Notifications Blocked"; notifyButton.disabled = true; break;
                    case 'default':
                        notifyStatus.textContent = "Click to enable"; notifyButton.textContent = "Enable Notifications"; notifyButton.disabled = false; break;
                }
            }).catch(err => { console.error("Error getting push subscription state:", err); notifyStatus.textContent = "Error checking status"; notifyButton.disabled = true; });
    },

    handleNotificationPermission: async function () {
        const button = document.getElementById('enable-notifications-button');
        if (!('Notification' in window) || !('PushManager' in window) || !('serviceWorker' in navigator) || !AppConfig.VAPID_PUBLIC_KEY) {
            AppUI.showErrorDialog("Not Supported", "Notifications are not supported, or server configuration is incomplete."); this.updateNotificationButtonState(); return;
        }
        button.disabled = true;

        const currentPermission = Notification.permission;

        try {
            if (currentPermission === 'granted') {
                if (!AppState.currentPushSubscription) { console.log("Permission granted, attempting to subscribe..."); button.textContent = "Subscribing..."; await this.subscribeUser(); }
                else { console.log("Already subscribed."); this.updateNotificationButtonState(); }
                return;
            }
            if (currentPermission === 'denied') { AppUI.showErrorDialog("Permission Blocked", "Notification permission was previously blocked. Please enable it in your browser settings for this site."); this.updateNotificationButtonState(); return; }

            console.log("Requesting notification permission...");
            button.textContent = "Requesting Permission...";
            const permissionResult = await Notification.requestPermission();
            console.log('Notification permission result:', permissionResult);

            if (permissionResult === 'granted') { console.log('Permission granted, attempting to subscribe...'); button.textContent = "Subscribing..."; await this.subscribeUser(); }
            else { console.warn('Notification permission denied or dismissed.'); AppUI.showErrorDialog("Permission Denied", "You denied or dismissed the notification permission request."); this.updateNotificationButtonState(); }
        } catch (error) { console.error('Error handling notification permission or subscription:', error); AppUI.showErrorDialog("Error", `An error occurred: ${error.message}`); this.updateNotificationButtonState(); }
    },

    subscribeUser: async function () {
        console.log("Attempting to subscribe user...");
        if (!AppConfig.VAPID_PUBLIC_KEY) { AppUI.showErrorDialog("Error", "Server VAPID key missing."); this.updateNotificationButtonState(); return null; }
        if (!AppState.swRegistration) { AppUI.showErrorDialog("Error", "Service worker not ready."); this.updateNotificationButtonState(); return null; }

        try {
            const applicationServerKey = AppUtils.urlBase64ToUint8Array(AppConfig.VAPID_PUBLIC_KEY);
            console.log("Calling pushManager.subscribe...");
            const subscription = await AppState.swRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: applicationServerKey });
            console.log('User subscribed successfully:', subscription);
            AppState.currentPushSubscription = subscription;

            console.log("Sending subscription to backend...");
            try {
                const backendResponse = await AppApi.subscribePush(subscription);
                console.log(`Backend subscription sync successful:`, backendResponse);
                if (backendResponse && backendResponse.message) { AppUI.showConfirmationDialog("Subscribed!", "You have successfully subscribed to notifications."); }
                else { AppUI.showErrorDialog("Subscription Issue", "Subscribed locally, but server response was unexpected. Notifications might not work."); }
            } catch (backendError) {
                console.error("Failed to send subscription to backend:", backendError);
                AppUI.showErrorDialog("Subscription Issue", `Subscribed locally, but failed to sync with the server: ${backendError.message}. Notifications might not work until sync succeeds.`);
            }
            this.updateNotificationButtonState();
            return subscription;
        } catch (err) {
            console.error('Failed to subscribe the user:', err);
            AppState.currentPushSubscription = null;
            if (err.name === 'NotAllowedError' || Notification.permission === 'denied') { AppUI.showErrorDialog("Subscription Failed", "Notification permission was denied. Please enable it in browser settings."); }
            else { AppUI.showErrorDialog("Subscription Failed", `Could not subscribe to notifications. Error: ${err.name} - ${err.message}`); }
            this.updateNotificationButtonState();
            return null;
        }
    },

    unsubscribeUser: async function () {
        const subscription = AppState.currentPushSubscription;
        if (!subscription) { AppUI.showErrorDialog("Not Subscribed", "You are not currently subscribed."); this.updateNotificationButtonState(); return; }
        const unsubscribeButton = document.getElementById('unsubscribe-button');
        unsubscribeButton.disabled = true; unsubscribeButton.textContent = "Unsubscribing...";
        console.log("Attempting to unsubscribe:", subscription.endpoint);
        let backendError = null;
        try {
            const successful = await subscription.unsubscribe();
            if (successful) {
                console.log("Unsubscribed successfully on client.");
                const endpointToRemove = subscription.endpoint;
                AppState.currentPushSubscription = null;
                try { await AppApi.unsubscribePush(endpointToRemove); console.log("Sent unsubscribe request to backend."); }
                catch (error) { backendError = error; console.error("Error sending unsubscribe request to backend:", backendError); AppUI.showConfirmationDialog("Unsubscribed (Partial)", "Unsubscribed locally, but could not notify the server. You might receive old notifications temporarily."); }
                if (!backendError) { AppUI.showConfirmationDialog("Unsubscribed", "You have been unsubscribed from notifications."); }
                this.updateNotificationButtonState();
            } else { console.error("Client unsubscribe method returned false."); AppUI.showErrorDialog("Unsubscribe Failed", "Could not unsubscribe on the client. Please try again."); this.updateNotificationButtonState(); }
        } catch (error) { console.error("Error during client unsubscribe:", error); AppUI.showErrorDialog("Unsubscribe Failed", `An error occurred during client unsubscribe: ${error.message}`); this.updateNotificationButtonState(); }
    },

    ensureSubscription: async function () {
        console.log("Ensuring subscription status...");
        if (!AppState.swRegistration || !('Notification' in window) || Notification.permission !== 'granted') {
            console.log("Cannot ensure subscription: SW not ready, Notifications not supported, or permission not granted.");
            AppState.currentPushSubscription = null; this.updateNotificationButtonState(); return;
        }
        try {
            const subscription = await AppState.swRegistration.pushManager.getSubscription();
            AppState.currentPushSubscription = subscription;
            console.log(`EnsureSubscription: User ${subscription ? 'is' : 'is NOT'} subscribed.`);
        } catch (error) { console.error("Error checking subscription:", error); AppState.currentPushSubscription = null; }
        finally { this.updateNotificationButtonState(); }
    },

    handleTestNotification: function (notificationType = 'test') { // Accept type
        console.log(`Attempting to show ${notificationType} notification via SW...`);
        const sw = AppState.swRegistration;
        if (sw && 'showNotification' in sw) {
            // Use icons based on type passed from config/backend
            const iconUrl = window.AppConfig.TEST_NOTIFICATION_ICON_URL || '/static/icons/favicon.svg';
            const badgeUrl = window.AppConfig.TEST_NOTIFICATION_ICON_URL || '/static/icons/badge-icon.png'; // Same as icon for test

            const payload = {
                title: "Test Notification",
                body: "This is a test message from the app!",
                icon: iconUrl, // Use static path
                badge: badgeUrl, // Use static path
                tag: `${notificationType}-notification-` + Date.now(),
                data: { type: notificationType } // Pass type in data
            };
            sw.showNotification(payload.title, {
                body: payload.body,
                icon: payload.icon,
                badge: payload.badge,
                tag: payload.tag,
                data: payload.data
            })
                .then(() => { AppUI.showConfirmationDialog("Test Sent", "If notifications are enabled and allowed, you should see a test notification."); })
                .catch(err => { console.error("Error showing test notification:", err); AppUI.showErrorDialog("Test Failed", `Could not show notification: ${err.message}`); });
        } else { AppUI.showErrorDialog("Test Failed", "Service worker not ready or does not support showing notifications."); }
    }
};
// --------------------
// app\static\js\share_page.js
// app/static/js/share_page.js

window.SharePage = {
    map: null,
    marker: null,
    shareId: null,
    fetchInterval: null,
    lastTimestamp: null,
    pollIntervalMs: 30 * 1000, // Poll every 30 seconds
    isInitialLoad: true,

    // --- UI Sub-object ---
    UI: {
        elements: {},
        cacheElements: function () {
            this.elements.overlay = document.getElementById('loading-overlay');
            this.elements.message = document.getElementById('loading-message');
            this.elements.spinner = this.elements.overlay?.querySelector('.spinner');
            this.elements.errorIcon = this.elements.overlay?.querySelector('.material-symbols-outlined'); // Cache error icon
            this.elements.title = document.getElementById('share-title');
            this.elements.infoCard = document.getElementById('info-card');
            this.elements.infoTitle = document.getElementById('info-card-title');
            this.elements.infoIcon = document.getElementById('info-card-icon');
            this.elements.infoTime = document.getElementById('info-card-time');
            this.elements.infoBattery = document.getElementById('info-card-battery');
            this.elements.infoBatteryIcon = document.getElementById('info-card-battery-icon');
            this.elements.infoNoteContainer = document.getElementById('info-card-note-container');
            this.elements.infoNote = document.getElementById('info-card-note');
            this.elements.zoomInBtn = document.getElementById('zoom-in'); // Cache new zoom buttons
            this.elements.zoomOutBtn = document.getElementById('zoom-out');
        },
        displayMessage: function (message, isError = false, showSpinner = !isError, iconName = 'cloud_off') {
            if (!this.elements.overlay || !this.elements.message) this.cacheElements();
            if (!this.elements.overlay || !this.elements.message) return;

            this.elements.overlay.classList.remove('hidden');
            this.elements.overlay.classList.toggle('error', isError); // Add error class to overlay
            if (this.elements.spinner) this.elements.spinner.style.display = showSpinner ? 'block' : 'none';
            if (this.elements.errorIcon) {
                this.elements.errorIcon.style.display = isError ? 'inline-block' : 'none';
                this.elements.errorIcon.textContent = iconName; // Set the icon
            }
            this.elements.message.innerHTML = message;
            this.elements.message.className = isError ? 'error-message' : '';
        },
        hideOverlay: function () {
            if (!this.elements.overlay) this.cacheElements();
            if (this.elements.overlay) this.elements.overlay.classList.add('hidden');
        },
        showInfoCard: function () {
            if (!this.elements.infoCard) this.cacheElements();
            if (this.elements.infoCard) this.elements.infoCard.classList.add('visible');
        },
        updateInfoCard: function (data) {
            if (!this.elements.infoCard) this.cacheElements();
            if (!this.elements.infoCard) return;

            const deviceName = data.device_name || "Shared Device";
            this.elements.title.textContent = `Location: ${deviceName}`;
            this.elements.infoTitle.textContent = deviceName;
            this.elements.infoIcon.textContent = 'devices'; // Or derive from data if possible

            let relativeTime = "Unknown time";
            if (data.timestamp) { try { relativeTime = SharePage.formatTimeRelative(new Date(data.timestamp)); } catch (e) { } }
            this.elements.infoTime.textContent = relativeTime;

            let batteryText = "Unknown"; let batteryIcon = 'battery_unknown';
            if (data.battery_level !== null) {
                batteryText = `${data.battery_level.toFixed(0)}%`; const level = data.battery_level;
                if (level > 95) batteryIcon = 'battery_full'; else if (level > 80) batteryIcon = 'battery_6_bar'; else if (level > 60) batteryIcon = 'battery_5_bar'; else if (level > 40) batteryIcon = 'battery_4_bar'; else if (level > 25) batteryIcon = 'battery_3_bar'; else if (level >= 15) batteryIcon = 'battery_alert'; else batteryIcon = 'battery_0_bar';
            } else if (data.battery_status && data.battery_status !== 'Unknown') { batteryText = data.battery_status; if (data.battery_status === 'Low' || data.battery_status === 'Very Low') batteryIcon = 'battery_alert'; }
            this.elements.infoBattery.textContent = batteryText;
            this.elements.infoBatteryIcon.textContent = batteryIcon;

            if (data.share_note && this.elements.infoNoteContainer && this.elements.infoNote) { this.elements.infoNote.textContent = `Note: ${data.share_note}`; this.elements.infoNoteContainer.style.display = 'block'; }
            else if (this.elements.infoNoteContainer) { this.elements.infoNoteContainer.style.display = 'none'; }
        },
        // Update Zoom Button Disabled State
        updateZoomButtons: function () {
            if (!SharePage.map || !this.elements.zoomInBtn || !this.elements.zoomOutBtn) return;
            this.elements.zoomInBtn.disabled = SharePage.map.getZoom() >= SharePage.map.getMaxZoom();
            this.elements.zoomOutBtn.disabled = SharePage.map.getZoom() <= SharePage.map.getMinZoom();
            this.elements.zoomInBtn.classList.toggle('disabled', this.elements.zoomInBtn.disabled);
            this.elements.zoomOutBtn.classList.toggle('disabled', this.elements.zoomOutBtn.disabled);
        }
    },

    // Helper to format relative time (copied from utils.js for isolation)
    formatTimeRelative: function (date) {
        // ... (keep the implementation from previous step) ...
        if (!date || !(date instanceof Date) || isNaN(date)) return "Unknown time";
        const now = new Date(); const deltaSeconds = Math.round((now.getTime() - date.getTime()) / 1000);
        if (deltaSeconds < 0) return "Just now"; if (deltaSeconds < 5) return "Just now"; if (deltaSeconds < 60) return `${deltaSeconds} sec ago`;
        const deltaMinutes = Math.round(deltaSeconds / 60); if (deltaMinutes < 60) return `${deltaMinutes} min ago`;
        const deltaHours = Math.round(deltaMinutes / 60); if (deltaHours < 24) return `${deltaHours} hr ago`;
        const deltaDays = Math.round(deltaHours / 24); if (deltaDays === 1) return "Yesterday"; if (deltaDays < 7) return `${deltaDays} days ago`;
        try { return new Intl.DateTimeFormat(navigator.language || 'en-US', { dateStyle: 'short', timeStyle: 'short' }).format(date); }
        catch (e) { return date.toLocaleDateString(); }
    },


    // --- START: Add escapeHtml and generateDeviceIconSVG helpers ---
    // Basic HTML escaping
    escapeHtml: function (unsafe) {
        if (typeof unsafe !== 'string') return unsafe;
        return unsafe.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, '"').replace(/'/g, "'");
    },

    // Generate SVG (copied and adapted from main app's utils.js)
    generateDeviceIconSVG: function (label, color, size = 36) {
        const sanitizedLabel = (label || '?'); let displayLabel = '?';
        try { const graphemes = [...sanitizedLabel]; displayLabel = graphemes.slice(0, 2).join("").toUpperCase(); }
        catch (e) {
            if (sanitizedLabel.length > 0) { if (sanitizedLabel.length >= 2 && 0xD800 <= sanitizedLabel.charCodeAt(0) && sanitizedLabel.charCodeAt(0) <= 0xDBFF) { displayLabel = sanitizedLabel.substring(0, 2).toUpperCase(); } else { displayLabel = sanitizedLabel.substring(0, 1).toUpperCase(); } }
        }
        // Basic color validation or use default grey
        const sanitizedColor = color && /^#[0-9a-fA-F]{6}$/.test(color) ? color : '#70757a';
        const border_width = Math.max(1, Math.round(size * 0.1));
        const inner_radius = Math.max(1, Math.round(size / 2) - border_width);
        const text_size = size * (displayLabel.length === 1 ? 0.50 : 0.40);
        let text_color = '#FFFFFF';
        try { const r = parseInt(sanitizedColor.substring(1, 3), 16); const g = parseInt(sanitizedColor.substring(3, 5), 16); const b = parseInt(sanitizedColor.substring(5, 7), 16); const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255; if (lum > 0.55) { text_color = '#333333'; } }
        catch (e) { }
        const label_safe = this.escapeHtml(displayLabel);
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" fill="${sanitizedColor}" /><circle cx="${size / 2}" cy="${size / 2}" r="${inner_radius}" fill="#FFFFFF" /><text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-family="sans-serif" font-size="${text_size}px" font-weight="bold" fill="${text_color}">${label_safe}</text></svg>`;
    },
    // --- END: Add escapeHtml and generateDeviceIconSVG helpers ---


    // --- Modified createDeviceIcon ---
    createDeviceIcon: function (label, color) {
        const size = 36; // Match main app marker size
        // Generate the SVG using the helper
        const svgHtml = this.generateDeviceIconSVG(label, color, size);
        return L.divIcon({
            className: 'custom-marker-share', // Add specific class if needed
            html: svgHtml, // Use generated SVG
            iconSize: [size, size],
            iconAnchor: [size / 2, size], // Anchor bottom-center
            popupAnchor: [0, -size] // Popup above marker
        });
    },
    // --- End Modified createDeviceIcon ---





    // Fetch and update location data
    // Fetch and update location data
    fetchAndUpdateLocation: async function () {
        if (!this.shareId) return;
        console.log(`[SharePage] Fetching location for share: ${this.shareId}`);
        if (!this.isInitialLoad) { this.UI.displayMessage("Updating location...", false, true); }

        try {
            // --- CHANGE API URL Here ---
            const apiUrl = `/public/api/shared/${this.shareId}`;
            // --- -------------------- ---
            const response = await fetch(apiUrl);
            if (!response.ok) {
                let errorMsg = `Error ${response.status}`;
                let errorIcon = 'cloud_off'; // Default error icon
                try {
                    const errorData = await response.json();
                    errorMsg = errorData.description || errorData.error || `${errorMsg}: ${response.statusText}`;
                    if (response.status === 404 || response.status === 410) errorIcon = 'link_off'; // Specific icon for invalid link
                } catch (e) { errorMsg = `${errorMsg}: ${response.statusText}`; }
                // Throw error with icon info if possible
                const error = new Error(errorMsg);
                error.icon = errorIcon; // Attach icon name to error
                error.status = response.status; // Attach status code
                throw error;
            }

            const data = await response.json();
            console.log("[SharePage] Received data:", data);

            if (!this.isInitialLoad && data.last_updated && this.lastTimestamp && data.last_updated <= this.lastTimestamp) { console.log("[SharePage] Data timestamp not newer."); this.UI.hideOverlay(); return; }
            this.lastTimestamp = data.last_updated;

            if (data.lat === null || data.lng === null) { this.UI.displayMessage("Device location is currently unavailable.", true, false, 'location_off'); if (this.UI.elements.infoCard) this.UI.elements.infoCard.classList.remove('visible'); return; }

            this.UI.updateInfoCard(data); this.UI.showInfoCard();

            const latLng = L.latLng(data.lat, data.lng);
            const deviceName = data.device_name || "Shared Device";
            const deviceLabel = data.device_label || "?";
            const deviceColor = data.device_color || "#70757a";

            // --- Updated Popup Content ---
            let popupContent = `<b><span class="marker-icon-popup">${this.generateDeviceIconSVG(deviceLabel, deviceColor, 20)}</span>${this.escapeHtml(deviceName)}</b><br>`;
            let timestampRelative = "Unknown time";
            if (data.timestamp) { try { timestampRelative = this.formatTimeRelative(new Date(data.timestamp)); popupContent += `<div><span class="material-symbols-outlined">schedule</span> ${timestampRelative}</div>`; } catch (e) { popupContent += `<div><span class="material-symbols-outlined">schedule</span> Invalid Time</div>`; } }
            // Add battery info
            if (data.battery_level !== null) { popupContent += `<div><span class="material-symbols-outlined">battery_std</span> ${data.battery_level.toFixed(0)}%${data.battery_status && data.battery_status !== 'Unknown' ? ` (${data.battery_status})` : ''}</div>`; }
            else if (data.battery_status && data.battery_status !== 'Unknown') { popupContent += `<div><span class="material-symbols-outlined">battery_unknown</span> ${data.battery_status}</div>`; }
            // Add coordinates and Google Maps link
            popupContent += `<div><span class="material-symbols-outlined">pin_drop</span> ${data.lat.toFixed(5)}°, ${data.lng.toFixed(5)}</div>`;
            popupContent += `<div><span class="material-symbols-outlined">map</span> <a href="https://www.google.com/maps?q=${data.lat},${data.lng}" target="_blank" rel="noopener noreferrer">View on Google Maps</a></div>`;
            // Add note
            if (data.share_note) { popupContent += `<hr><small><i>Note: ${this.escapeHtml(data.share_note)}</i></small>`; }
            // --- End Updated Popup Content ---


            const newIcon = this.createDeviceIcon(deviceLabel, deviceColor);

            if (!this.marker) {
                this.marker = L.marker(latLng, { icon: newIcon }).addTo(this.map);
                this.marker.bindPopup(popupContent);
                this.map.setView(latLng, 16);
                console.log("[SharePage] Marker created and map centered.");
            } else {
                this.marker.setLatLng(latLng); this.marker.setIcon(newIcon); this.marker.setPopupContent(popupContent);
                if (this.isInitialLoad) { this.map.setView(latLng, 16); console.log("[SharePage] Marker updated and map centered (initial)."); }
                else if (!this.map.getBounds().contains(latLng)) { this.map.panTo(latLng); console.log("[SharePage] Marker updated and map panned."); }
                else { console.log("[SharePage] Marker updated (no pan needed)."); }
            }

            this.UI.hideOverlay(); this.isInitialLoad = false;

        } catch (error) {
            console.error("[SharePage] Error fetching shared location:", error);
            let displayError = `Could not load location: ${error.message}`;
            let errorIcon = error.icon || 'cloud_off'; // Get icon from error or use default
            if (error.status === 404 || error.status === 410) { displayError = "Link invalid, expired, or revoked."; this.stopPolling(); errorIcon = 'link_off'; }
            else if (error.status === 503) { displayError = "Location data temporarily unavailable."; errorIcon = 'sync_problem'; }
            else if (error.status === 500) { displayError = "Server error retrieving location."; errorIcon = 'dns'; } // Generic server error

            this.UI.displayMessage(displayError, true, false, errorIcon); // Show error, no spinner, pass icon
            if (this.UI.elements.infoCard) this.UI.elements.infoCard.classList.remove('visible');
        }
    },

    // Start polling for updates
    startPolling: function () {
        // ... (keep existing startPolling logic) ...
        if (this.fetchInterval) { console.log("[SharePage] Polling already active."); return; }
        if (!this.shareId) { console.error("[SharePage] Cannot start polling without shareId."); return; }
        console.log(`[SharePage] Starting polling every ${this.pollIntervalMs / 1000} seconds.`);
        this.fetchAndUpdateLocation(); // Fetch immediately first time
        this.fetchInterval = setInterval(() => { this.fetchAndUpdateLocation(); }, this.pollIntervalMs);
    },

    // Stop polling
    stopPolling: function () {
        // ... (keep existing stopPolling logic) ...
        if (this.fetchInterval) { console.log("[SharePage] Stopping polling."); clearInterval(this.fetchInterval); this.fetchInterval = null; }
    },

    // Initialize the map and start fetching
    initialize: function (shareId) {
        console.log("[SharePage] Initializing...");
        this.shareId = shareId;
        this.UI.cacheElements();

        if (!this.shareId) { this.UI.displayMessage("Invalid share link provided.", true, false, 'error'); return; }

        this.UI.displayMessage("Loading shared location...", false, true);

        try {
            this.map = L.map('share-map', {
                zoomControl: false, // Disable default
                attributionControl: true
            }).setView([0, 0], 3);

            // Add App-Style Zoom Controls Listeners
            const zoomInButton = document.getElementById('zoom-in');
            const zoomOutButton = document.getElementById('zoom-out');
            if (zoomInButton) zoomInButton.addEventListener('click', () => { this.map?.zoomIn(); });
            if (zoomOutButton) zoomOutButton.addEventListener('click', () => { this.map?.zoomOut(); });
            this.map.on('zoomend', () => this.UI.updateZoomButtons()); // Update state on zoom change

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OSM</a>', maxZoom: 19,
            }).addTo(this.map);

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                const tilePane = this.map.getPane('tilePane');
                if (tilePane) { tilePane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)'; }
            }

            this.startPolling();
            this.UI.updateZoomButtons(); // Set initial button state

        } catch (error) {
            console.error("[SharePage] Map initialization error:", error);
            this.UI.displayMessage(`Map initialization failed: ${error.message}`, true, false, 'map');
        }
    }
};
// --------------------
// app\static\js\state.js
// app/static/js/state.js

// Simple state management object attached to window for now
window.AppState = {
        map: null,
        locationMarker: null,
        deviceMarkers: {},
        deviceHistoryLayers: {},
        geofenceLayerGroup: null,
        savedPlaceMarkers: [],
        searchMarker: null,
        placePickerDialog: { map: null, marker: null },
        geofenceDialog: { map: null, marker: null, circle: null },
        lastDeviceUpdateTime: null,
        currentDeviceData: [],
        globalGeofenceData: [],
        locationHistoryEnabled: true,
        locationHistory: [],
        savedPlaces: [],
        currentTheme: 'system',
        userColor: '#6750A4', // Default color
        currentViewedDeviceId: null,
        isShowingAllDevices: false,
        showDeviceHistory: false,
        historyTimeFilterHours: 24 * 7,
        deviceVisibility: {},
        swRegistration: null,
        currentPushSubscription: null,
        importData: null,
        mapReady: false,
    
        // --- START: New Share State ---
        userActiveShares: [], // Array to hold fetched shares for the settings page
        // --- END: New Share State ---

        
        
    // --- Initialization ---
    loadInitialState: function () {
        // this.currentTheme = localStorage.getItem('theme') || 'system';
        // this.userColor = localStorage.getItem('userColor') || (window.AppTheme ? AppTheme.DEFAULT_SOURCE_COLOR : '#6750A4');
        this.mapReady = false; // <<< Reset on load
        this.isShowingAllDevices = localStorage.getItem('isShowingAllDevices') === 'true';
        this.showDeviceHistory = localStorage.getItem('showDeviceHistory') === 'true';
        this.historyTimeFilterHours = parseInt(localStorage.getItem('historyTimeFilterHours') || '168', 10);
        if (isNaN(this.historyTimeFilterHours) || this.historyTimeFilterHours <= 0 || this.historyTimeFilterHours > 168) {
            this.historyTimeFilterHours = 168;
        }
        this.deviceVisibility = JSON.parse(localStorage.getItem('deviceVisibility')) || {};
        this.locationHistoryEnabled = localStorage.getItem('locationHistoryEnabled') !== 'false';
        this.locationHistory = this.locationHistoryEnabled ? (JSON.parse(localStorage.getItem('locationHistory')) || []) : [];
        this.savedPlaces = JSON.parse(localStorage.getItem('savedPlaces')) || [];
        console.log("Initial state loaded from localStorage (excluding theme).");
        // Log statements for theme will happen after API fetch in app.js
    },

    // NEW function to set preferences fetched from API
    setCurrentUserPreferences: function (prefs) {
        this.currentTheme = prefs?.theme_mode || 'system';
        this.userColor = prefs?.theme_color || (window.AppTheme ? AppTheme.DEFAULT_SOURCE_COLOR : '#6750A4');
        console.log(`Preferences set from API: Mode=${this.currentTheme}, Color=${this.userColor}`);
    },



    // --- Getters / Setters ---
    getMap: function () { return this.map; },
    setMap: function (mapInstance) { this.map = mapInstance; },

    getCurrentDeviceData: function () { return this.currentDeviceData; },
    setCurrentDeviceData: function (data) {
        if (Array.isArray(data)) {
            // Ensure 'reports' key exists and is an array for each device
            this.currentDeviceData = data.map(device => ({
                ...device,
                reports: Array.isArray(device.reports) ? device.reports : []
            }));
            this.lastDeviceUpdateTime = new Date(); // Update timestamp when data is set
        } else {
            console.error("Invalid device data format:", data);
        }
    },

    getGlobalGeofences: function () { return this.globalGeofenceData; },
    setGlobalGeofences: function (data) {
        if (Array.isArray(data)) {
            this.globalGeofenceData = data;
        } else {
            console.error("Invalid geofence data format:", data);
        }
    },

    getDeviceVisibility: function (deviceId) {
        // Make sure to check the stored state after loading initial state
        const storedVisibility = this.deviceVisibility[deviceId];
        return storedVisibility !== false; // Default to true if undefined or explicitly true
    },
    setDeviceVisibility: function (deviceId, isVisible) {
        this.deviceVisibility[deviceId] = !!isVisible;
        // Debounced save moved to ui.js
    },

    getDeviceDisplayInfo: function (deviceId) {
        const deviceApiData = this.currentDeviceData.find(d => d.id === deviceId);
        const defaultColor = AppUtils.getDefaultColorForId(deviceId);

        // Ensure visibility state is initialized if missing
        if (!(deviceId in this.deviceVisibility)) {
            this.deviceVisibility[deviceId] = true; // Default to visible
        }
        const isVisible = this.getDeviceVisibility(deviceId);

        if (!deviceApiData) {
            console.warn(`Device data for ${deviceId} not found in current API data.`);
            // Generate fallback SVG here if data is missing
            const fallbackSvg = AppUtils.generateDeviceIconSVG('❓', defaultColor);
            return {
                id: deviceId, name: deviceId, label: '❓', color: defaultColor,
                svg_icon: fallbackSvg, // Use generated fallback
                geofences: [], isVisible: isVisible, lat: null, lng: null,
                rawLocation: null,
                reports: [], // Ensure reports exists
                model: 'Unknown', status: 'Unknown',
                batteryLevel: null, batteryStatus: 'Unknown', locationTimestamp: null, address: 'Unknown'
            };
        }

        const color = deviceApiData.color || defaultColor;
        // Use svg_icon from API data, generate fallback if missing
        const svg_icon = deviceApiData.svg_icon || AppUtils.generateDeviceIconSVG(deviceApiData.label || '❓', color);

        return {
            id: deviceId,
            name: deviceApiData.name || deviceId,
            label: deviceApiData.label || '❓',
            color: color,
            svg_icon: svg_icon,
            geofences: Array.isArray(deviceApiData.geofences) ? deviceApiData.geofences : [], // Ensure geofences is an array
            isVisible: isVisible,
            lat: deviceApiData.lat,
            lng: deviceApiData.lng,
            rawLocation: deviceApiData.rawLocation,
            reports: Array.isArray(deviceApiData.reports) ? deviceApiData.reports : [], // Ensure reports is an array
            status: deviceApiData.status || 'Unknown',
            model: deviceApiData.model || 'Unknown',
            batteryLevel: deviceApiData.batteryLevel,
            batteryStatus: deviceApiData.batteryStatus || 'Unknown',
            locationTimestamp: deviceApiData.locationTimestamp,
            address: deviceApiData.address || 'Unknown'
        };
    },

    // --- START: New Share Methods ---
    /**
     * Sets the user's active shares in the state.
     * @param {Array<object>} shares - Array of share objects from the API.
     */
    setUserActiveShares: function(shares) {
        if (Array.isArray(shares)) {
            this.userActiveShares = shares;
            console.log(`[State] Set ${shares.length} active shares.`);
        } else {
            console.error("[State] Invalid data provided to setUserActiveShares, expected array.");
            this.userActiveShares = [];
        }
    },

    /**
     * Gets the currently stored active shares.
     * @returns {Array<object>}
     */
    getUserActiveShares: function() {
        return this.userActiveShares;
    },


    // --- Persistence Helpers ---
    _saveToLocalStorage: function (key, data) {
        try {
            localStorage.setItem(key, JSON.stringify(data));
        } catch (e) {
            console.error(`Failed to save '${key}' to localStorage:`, e);
            // Optionally show an error to the user if storage is full
            // AppUI.showErrorDialog("Storage Error", `Could not save ${key}. Local storage might be full.`);
        }
    },

    saveDeviceVisibilityState: function () {
        this._saveToLocalStorage('deviceVisibility', this.deviceVisibility);
    },

    saveLocationHistory: function () {
        this._saveToLocalStorage('locationHistory', this.locationHistory);
    },
    saveSavedPlaces: function () {
        this._saveToLocalStorage('savedPlaces', this.savedPlaces);
    },
    saveTheme: function () {
        localStorage.setItem('theme', this.currentTheme);
    },
    saveMapToggles: function () {
        localStorage.setItem('isShowingAllDevices', this.isShowingAllDevices);
        localStorage.setItem('showDeviceHistory', this.showDeviceHistory);
        localStorage.setItem('historyTimeFilterHours', this.historyTimeFilterHours);
    },
    saveLocationHistoryEnabled: function () {
        localStorage.setItem('locationHistoryEnabled', this.locationHistoryEnabled);
    },

    // --- History Management ---
    addToLocationHistory: function (locationItem) {
        if (!this.locationHistoryEnabled) return;
        console.log("Adding to history:", locationItem.location);

        if (this.locationHistory.length > 0) {
            const last = this.locationHistory[0];
            const similar = last.location === locationItem.location &&
                Math.abs((last.lat || 0) - (locationItem.lat || 1)) < 0.0005 &&
                Math.abs((last.lng || 0) - (locationItem.lng || 1)) < 0.0005;
            if (similar) {
                console.log("Skipping similar history entry.");
                return;
            }
        }

        this.locationHistory.unshift(locationItem);
        // Use config constant
        if (this.locationHistory.length > AppConfig.MAX_HISTORY_POINTS) {
            this.locationHistory.pop();
        }
        this.saveLocationHistory(); // Persist change
    },
    clearLocationHistory: function () {
        this.locationHistory = [];
        this.saveLocationHistory();
        console.log("Location history cleared.");
    },

    // --- Import/Export State ---
    setImportData: function (data) {
        console.log("Setting import data:", data);
        this.importData = data;
    },
    getImportData: function () {
        return this.importData;
    },
    clearImportData: function () {
        console.log("Clearing import data.");
        this.importData = null;
    },
};
// --------------------
// app\static\js\ui.js
// app/static/js/ui.js

window.AppUI = {
    // --- Dialog Management ---
    openDialog: function (dialogId) {
        console.log("[UI] Opening dialog:", dialogId);
        const overlay = document.getElementById(dialogId + '-overlay');
        const dialog = document.getElementById(dialogId);
        if (!overlay || !dialog) { console.error("[UI] Dialog or overlay not found:", dialogId); return; }

        if (dialogId === 'share-location-dialog') {
            const triggerButton = document.activeElement;
            const isMainShare = triggerButton && triggerButton.id === 'share-button';
            if (isMainShare) {
                console.log("[UI] Populating share dialog with current user location.");
                const address = document.getElementById('location-address-text')?.textContent || 'Address Unknown';
                const coords = document.getElementById('location-coordinates-text')?.textContent || 'Coordinates Unknown';
                const updated = document.getElementById('last-updated-text')?.textContent || 'Timestamp Unknown';
                const latMatch = coords.match(/^(-?\d+\.\d+)/); const lngMatch = coords.match(/(-?\d+\.\d+)(?!.*\d)/);
                const lat = latMatch ? latMatch[1] : null; const lng = lngMatch ? lngMatch[1] : null;
                let text = `My Location:\n${address}\n${coords}\n${updated}`;
                if (lat && lng) { text += `\nMap: https://www.openstreetmap.org/?mlat=${lat}&mlon=${lng}#map=16/${lat}/${lng}\nGoogle Maps: https://www.google.com/maps?q=${lat},${lng}`; }
                const ta = document.getElementById('share-location-textarea'); const p = document.getElementById('share-location-dialog-content')?.querySelector('p');
                if (ta) ta.value = text; if (p) p.textContent = `Copy text to share current location:`;
            }
        }

        overlay.classList.add('show');
        overlay.scrollTop = 0;
        this._trapFocus(dialog);

        if (dialogId === 'add-place-dialog') AppMap.initPlacePickerDialogMap();
        if (dialogId === 'geofence-dialog') {
            const editId = document.getElementById('geofence-edit-id').value;
            if (editId) {
                const gf = AppState.globalGeofenceData.find(g => g.id === editId);
                if (gf) AppMap.initGeofenceDialogMap([gf.lat, gf.lng], 16, gf.radius);
                else console.error("[UI] Cannot init geofence dialog map: editing non-existent geofence");
            } else {
                const center = AppState.locationMarker ? AppState.locationMarker.getLatLng() : L.latLng(20, 0);
                const zoom = AppState.locationMarker ? 15 : 2;
                AppMap.initGeofenceDialogMap(center, zoom, 100);
            }
        }
        // Call setupDialogSearch AFTER potential map init
        if (dialogId === 'add-place-dialog' || dialogId === 'geofence-dialog') {
            setTimeout(() => this.setupDialogSearch(dialogId), 50);
        }
        if (dialogId === 'config-import-dialog') { this.resetImportDialog(); }
    },

    closeDialog: function (dialogId) {
        console.log("[UI] Closing dialog:", dialogId);
        const overlay = document.getElementById(dialogId + '-overlay');
        const dialog = document.getElementById(dialogId);
        if (!overlay || !dialog) return;
        overlay.classList.remove('show');
        this._releaseFocus(dialog);
        if (dialogId === 'add-place-dialog') AppMap.destroyPlacePickerDialogMap();
        if (dialogId === 'geofence-dialog') AppMap.destroyGeofenceDialogMap();
        if (dialogId === 'add-place-dialog' || dialogId === 'geofence-dialog') { this.cleanupDialogSearch(dialogId); this.hideSearchResults('place-picker-search-results'); this.hideSearchResults('geofence-picker-search-results'); }
        if (dialogId === 'config-import-dialog') { this.resetImportDialog(); }
    },

    closeDialog: function (dialogId) {
        console.log("[UI] Closing dialog:", dialogId);
        const overlay = document.getElementById(dialogId + '-overlay');
        const dialog = document.getElementById(dialogId);
        if (!overlay || !dialog) return;

        overlay.classList.remove('show');
        this._releaseFocus(dialog);

        // Handle specific dialog cleanups
        if (dialogId === 'add-place-dialog') AppMap.destroyPlacePickerDialogMap();
        if (dialogId === 'geofence-dialog') AppMap.destroyGeofenceDialogMap();
        // Clean up search listeners
        if (dialogId === 'add-place-dialog' || dialogId === 'geofence-dialog') {
            this.cleanupDialogSearch(dialogId);
            this.hideSearchResults('place-picker-search-results');
            this.hideSearchResults('geofence-picker-search-results');
        }
        // Clear temporary import data when closing the import dialog
        if (dialogId === 'config-import-dialog') {
            this.resetImportDialog(); // Reset UI and clear state
        }
    },

    _trapFocus: function (dialogElement) {
        const focusableElementsString = 'button, [href], input:not([type="hidden"]):not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])';
        const focusableElements = Array.from(dialogElement.querySelectorAll(focusableElementsString)).filter(el => el.offsetParent !== null);
        if (focusableElements.length === 0) return;
        const firstElement = focusableElements[0]; const lastElement = focusableElements[focusableElements.length - 1];
        dialogElement._originalFocusedElement = document.activeElement; // Store previously focused element
        setTimeout(() => { try { firstElement.focus(); } catch (e) { } }, 100);
        const handleKeyDown = (event) => {
            if (event.key !== 'Tab') return;
            const currentlyFocusedIndex = focusableElements.indexOf(document.activeElement);
            if (event.shiftKey) {
                if (currentlyFocusedIndex === 0 || currentlyFocusedIndex === -1) { lastElement.focus(); event.preventDefault(); }
            } else {
                if (currentlyFocusedIndex === focusableElements.length - 1 || currentlyFocusedIndex === -1) { firstElement.focus(); event.preventDefault(); }
            }
        };
        dialogElement.addEventListener('keydown', handleKeyDown);
        dialogElement._focusTrapHandler = handleKeyDown;
    },

    _releaseFocus: function (dialogElement) {
        if (dialogElement._focusTrapHandler) { dialogElement.removeEventListener('keydown', dialogElement._focusTrapHandler); delete dialogElement._focusTrapHandler; }
        if (dialogElement._originalFocusedElement && typeof dialogElement._originalFocusedElement.focus === 'function') {
            try { dialogElement._originalFocusedElement.focus(); } catch (e) { }
        }
        delete dialogElement._originalFocusedElement;
    },

    showErrorDialog: function (title, message) {
        document.getElementById('error-dialog-title').textContent = title;
        document.getElementById('error-dialog-content').innerHTML = message; // Use innerHTML to render breaks
        this.openDialog('error-dialog');
    },

    showConfirmationDialog: function (title, message, onConfirm = null, onCancel = null) {
        document.getElementById('confirmation-dialog-title').textContent = title;
        document.getElementById('confirmation-dialog-content').innerHTML = message; // Use innerHTML
        const actions = document.getElementById('confirmation-dialog-actions');
        actions.innerHTML = ''; // Clear previous buttons

        if (onConfirm && typeof onConfirm === 'function') {
            // Confirmation mode
            const cancelButton = document.createElement('button'); cancelButton.className = 'text-button'; cancelButton.textContent = 'Cancel';
            cancelButton.onclick = () => {
                if (onCancel && typeof onCancel === 'function') onCancel();
                this.closeDialog('confirmation-dialog');
            };

            const confirmButton = document.createElement('button'); confirmButton.className = 'button'; confirmButton.textContent = 'Confirm';
            confirmButton.onclick = () => {
                onConfirm();
                this.closeDialog('confirmation-dialog');
            };
            actions.appendChild(cancelButton);
            actions.appendChild(confirmButton);
        } else {
            // Simple OK mode
            const okButton = document.createElement('button'); okButton.className = 'button'; okButton.textContent = 'OK';
            okButton.onclick = () => this.closeDialog('confirmation-dialog');
            actions.appendChild(okButton);
        }
        this.openDialog('confirmation-dialog');
    },


    confirmRemoveItem: function (itemType, identifier, name, callback) {
        document.getElementById('remove-confirmation-dialog-title').textContent = `Remove ${itemType}?`;
        document.getElementById('remove-confirmation-dialog-content').textContent = `Are you sure you want to remove "${name}"? This cannot be undone.`;
        const confirmButton = document.getElementById('remove-confirm-button');
        const newConfirmButton = confirmButton.cloneNode(true); // Clone to remove old listeners
        newConfirmButton.onclick = () => { callback(identifier); this.closeDialog('remove-confirmation-dialog'); };
        confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
        this.openDialog('remove-confirmation-dialog');
    },

    openDeviceMenu: function (deviceIndex, anchorElement) {
        const device = AppState.getCurrentDeviceData()[deviceIndex]; if (!device) return;
        const displayInfo = AppState.getDeviceDisplayInfo(device.id); const menuItems = [];
        const latestLocationAvailable = displayInfo.lat != null && displayInfo.lng != null;

        if (latestLocationAvailable) { menuItems.push({ label: "View on Map", icon: "map", action: () => AppMap.viewDeviceOnMap(device.id) }); }
        else { menuItems.push({ label: "View on Map", icon: "map", action: () => { }, disabled: true }); }

        menuItems.push({ label: "Share Device", icon: "share", action: () => this.openShareDeviceDialog(device.id, displayInfo.name) });
        menuItems.push({ label: "Edit Display", icon: "edit", action: () => this.openEditDeviceDialog(device.id) });
        menuItems.push({ label: "Manage Geofences", icon: "radar", action: () => this.navigateToGeofenceDeviceCard(device.id) });

        // --- START: Ensure Test Buttons are Present ---
        menuItems.push({ type: 'divider' }); // Optional divider before tests
        menuItems.push({ label: "Test Geofence Entry", icon: "notifications_active", action: () => this.triggerTestNotification(device.id, 'geofence_entry') });
        menuItems.push({ label: "Test Geofence Exit", icon: "notifications", action: () => this.triggerTestNotification(device.id, 'geofence_exit') });
        menuItems.push({ label: "Test Low Battery", icon: "battery_alert", action: () => this.triggerTestNotification(device.id, 'battery_low') });
        // --- END: Ensure Test Buttons are Present ---

        menuItems.push({ type: 'divider' }); // Optional divider before remove
        menuItems.push({
            label: "Remove Device",
            icon: "delete_outline",
            action: () => this.confirmRemoveItem('device', device.id, displayInfo.name, AppActions.handleRemoveDevice),
            isDestructive: true
        });

        const dialogContent = document.getElementById('device-menu-dialog-content'); dialogContent.innerHTML = '';
        document.getElementById('device-menu-dialog-title').textContent = displayInfo.name || "Device Options";
        menuItems.forEach(item => {
            if (item.type === 'divider') {
                const divider = document.createElement('hr');
                divider.style.margin = '8px 0';
                divider.style.borderColor = 'var(--m3-sys-color-outline-variant)';
                dialogContent.appendChild(divider);
                return;
            }
            const menuItem = document.createElement('div'); menuItem.classList.add('drawer-item'); menuItem.setAttribute('tabindex', item.disabled ? '-1' : '0'); menuItem.setAttribute('role', 'menuitem');
            if (item.disabled) { menuItem.style.opacity = '0.5'; menuItem.style.cursor = 'not-allowed'; }
            if (item.isDestructive) { menuItem.style.color = 'var(--m3-sys-color-error)'; }

            menuItem.innerHTML = `${item.icon ? `<span class="material-icons drawer-item-icon" ${item.isDestructive ? 'style="color: inherit;"' : ''}>${item.icon}</span>` : ''}<span class="drawer-item-text">${item.label} ${item.disabled ? '(N/A)' : ''}</span>`;

            if (!item.disabled) { const actionHandler = () => { item.action(); this.closeDialog('device-menu-dialog'); }; menuItem.onclick = actionHandler; menuItem.onkeypress = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); actionHandler(); } }; }
            dialogContent.appendChild(menuItem);
        });
        this.openDialog('device-menu-dialog');
    },




    // --- START: New Share Dialog Functions ---
    openShareDeviceDialog: function (deviceId, deviceName) {
        document.getElementById('share-device-id').value = deviceId;
        document.getElementById('share-device-dialog-title').textContent = `Share "${deviceName}"`;
        document.getElementById('share-duration-select').value = '24h'; // Default duration
        document.getElementById('share-note-input').value = ''; // Clear note
        document.getElementById('share-create-error').style.display = 'none';
        document.getElementById('share-create-error').textContent = '';

        // Clear previous listener and add new one
        const createButton = document.getElementById('create-share-link-button');
        const newCreateButton = createButton.cloneNode(true); // Clone to remove old listeners
        newCreateButton.onclick = () => this.handleShareDeviceSubmit(); // Attach new listener
        createButton.parentNode.replaceChild(newCreateButton, createButton);

        this.openDialog('share-device-dialog');
    },

    handleShareDeviceSubmit: async function () {
        const deviceId = document.getElementById('share-device-id').value;
        const duration = document.getElementById('share-duration-select').value;
        const note = document.getElementById('share-note-input').value;
        const errorElement = document.getElementById('share-create-error');
        const createButton = document.getElementById('create-share-link-button');

        if (!deviceId || !duration) {
            errorElement.textContent = "Missing device ID or duration.";
            errorElement.style.display = 'block';
            return;
        }

        errorElement.style.display = 'none';
        createButton.disabled = true;
        createButton.innerHTML = `<div class="spinner" style="width:18px;height:18px;border-width:2px;margin:0 auto;"></div> Creating...`;

        try {
            const shareResult = await AppApi.createDeviceShare(deviceId, duration, note);
            console.log("Share created:", shareResult);

            this.closeDialog('share-device-dialog');

            // Populate and open the link dialog
            document.getElementById('share-link-textarea').value = shareResult.share_url || 'Error: URL not returned';
            const expiryInfo = document.getElementById('share-link-expiry-info');
            if (shareResult.expires_at) {
                try {
                    const expiryDate = new Date(shareResult.expires_at);
                    expiryInfo.textContent = `Link expires: ${AppUtils.formatTimeRelative(expiryDate)} (${AppUtils.formatTime(expiryDate)})`;
                } catch (e) {
                    expiryInfo.textContent = `Link expires: ${shareResult.expires_at}`;
                }
            } else {
                expiryInfo.textContent = "Link does not expire automatically.";
            }
            // Setup copy button listener
            const copyButton = document.getElementById('copy-share-link-button');
            const newCopyButton = copyButton.cloneNode(true);
            newCopyButton.onclick = () => this.copyShareLink();
            copyButton.parentNode.replaceChild(newCopyButton, copyButton);

            this.openDialog('share-link-dialog');

            // Refresh lists in the background
            this.renderActiveSharesList(); // Update settings page list
            AppActions.refreshDevices(); // Update main device list for icon

        } catch (error) {
            console.error("Error creating share link:", error);
            errorElement.textContent = `Failed to create link: ${error.message}`;
            errorElement.style.display = 'block';
            this.showErrorDialog("Share Failed", `Could not create share link: ${error.message}`);
        } finally {
            createButton.disabled = false;
            createButton.innerHTML = 'Create Share Link';
        }
    },

    copyShareLink: async function () {
        const textarea = document.getElementById('share-link-textarea');
        const copyButton = document.getElementById('copy-share-link-button');
        if (!textarea || !copyButton) return;

        textarea.select();
        textarea.setSelectionRange(0, 99999); // For mobile

        const originalButtonHtml = copyButton.innerHTML;
        copyButton.innerHTML = 'Copying...';
        copyButton.disabled = true;

        try {
            await navigator.clipboard.writeText(textarea.value);
            copyButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">check</span> Copied!`;
            setTimeout(() => {
                copyButton.innerHTML = originalButtonHtml; // Reset after a delay
                copyButton.disabled = false;
            }, 1500);
        } catch (err) {
            console.error('Failed to copy share link: ', err);
            copyButton.innerHTML = 'Failed!';
            this.showErrorDialog("Copy Failed", "Could not copy link automatically. Please copy manually.");
            setTimeout(() => {
                copyButton.innerHTML = originalButtonHtml;
                copyButton.disabled = false;
            }, 2000);
        }
    },

    renderActiveSharesList: async function () {
        const listContainer = document.getElementById('active-shares-list');
        const loadingIndicator = document.getElementById('active-shares-loading');
        const noItemsMessage = document.getElementById('no-active-shares-message');
        if (!listContainer || !loadingIndicator || !noItemsMessage) return;

        loadingIndicator.style.display = 'block'; listContainer.style.display = 'none'; noItemsMessage.style.display = 'none'; listContainer.innerHTML = '';

        try {
            const shares = await AppApi.fetchUserShares(); AppState.setUserActiveShares(shares);

            if (shares.length === 0) { noItemsMessage.style.display = 'block'; }
            else {
                listContainer.style.display = 'block';
                shares.forEach(share => {
                    const item = document.createElement('div');
                    item.className = 'settings-item share-item';
                    item.dataset.shareId = share.share_id;
                    // Add active/inactive state class for styling
                    item.classList.toggle('share-inactive', !share.active);
                    item.classList.toggle('share-expired', !!share.is_expired); // Use flag from UDS

                    const createdDate = share.created_at ? AppUtils.formatTimeRelative(new Date(share.created_at)) : 'Unknown';
                    let expiryText = share.active ? "Never" : "Inactive"; // Default for active/inactive indefinite
                    let expiryClass = share.active ? "" : "inactive";
                    if (share.expires_at) {
                        try {
                            const expiryDate = new Date(share.expires_at.replace("Z", "+00:00"));
                            const isExpired = expiryDate < new Date();
                            expiryText = `${isExpired ? 'Expired' : 'Expires'} ${AppUtils.formatTimeRelative(expiryDate)}`;
                            if (isExpired) expiryClass = "expired";
                            else if (!share.active) expiryClass = "inactive"; // Still inactive even if not expired
                        } catch (e) { expiryText = "Invalid expiry"; expiryClass = "error"; }
                    } else if (!share.active) {
                        expiryText = "Inactive"; // Indefinite but inactive
                        expiryClass = "inactive";
                    }

                    const noteHtml = share.note ? `<div class="settings-item-description share-note">Note: ${AppUtils.escapeHtml(share.note)}</div>` : '';

                    // Determine Suspend/Resume button state
                    const toggleButtonIcon = share.active ? 'pause_circle' : 'play_circle';
                    const toggleButtonTitle = share.active ? 'Suspend Share (Deactivate Link)' : 'Resume Share (Activate Link)';
                    const toggleButtonClass = share.active ? 'suspend-share-button' : 'resume-share-button';

                    item.innerHTML = `
                        <span class="material-icons drawer-item-icon share-status-icon ${expiryClass}">${share.active ? (share.is_expired ? 'history_toggle_off' : 'share') : 'pause_circle'}</span>
                        <div class="settings-item-text">
                            <div class="settings-item-title">${AppUtils.escapeHtml(share.device_name || 'Unknown Device')}</div>
                            <div class="settings-item-description share-details">
                                Created: ${createdDate} | <span class="share-expiry ${expiryClass}">${expiryText}</span>
                            </div>
                            <div class="settings-item-description share-link-display">
                                <a href="${share.share_url}" target="_blank" title="Open share link">${share.share_url.replace(/^https:\/\/|^http:\/\//, '')}</a>
                                <button class="text-button copy-share-button-list" title="Copy Link" data-url="${share.share_url}">
                                    <span class="material-icons" style="font-size: 16px;">content_copy</span>
                                </button>
                            </div>
                            ${noteHtml}
                        </div>
                        <div class="share-item-actions">
                            <button class="text-button toggle-share-button ${toggleButtonClass}" title="${toggleButtonTitle}" data-share-id="${share.share_id}" data-active="${share.active}">
                                <span class="material-icons" style="font-size: 22px;">${toggleButtonIcon}</span>
                            </button>
                            <button class="text-button edit-share-button" title="Edit Duration/Note" data-share-id="${share.share_id}">
                                <span class="material-icons" style="font-size: 20px;">edit_calendar</span>
                            </button>
                            <button class="text-button revoke-share-button" title="Delete Share Link Permanently" data-share-id="${share.share_id}" style="color: var(--m3-sys-color-error);">
                                <span class="material-icons" style="font-size: 20px;">delete_forever</span>
                            </button>
                        </div>
                    `;
                    // Add listeners using event delegation or directly
                    item.querySelector('.revoke-share-button').addEventListener('click', (e) => { e.stopPropagation(); this.handleDeleteShare(share.share_id, share.device_name); });
                    item.querySelector('.toggle-share-button').addEventListener('click', (e) => { e.stopPropagation(); this.handleToggleShareStatus(share.share_id, share.active); });
                    item.querySelector('.edit-share-button').addEventListener('click', (e) => { e.stopPropagation(); this.openEditShareDialog(share); });
                    item.querySelector('.copy-share-button-list').addEventListener('click', (e) => { e.stopPropagation(); this.copyTextToClipboard(share.share_url, e.currentTarget); });

                    listContainer.appendChild(item);
                });
            }
        } catch (error) {
            console.error("Error loading active shares:", error); noItemsMessage.textContent = `Error loading shares: ${error.message}`; noItemsMessage.style.display = 'block';
        } finally {
            loadingIndicator.style.display = 'none';
        }
    },

    // Rename revoke handler to DELETE handler
    handleDeleteShare: function (shareId, deviceName) {
        this.showConfirmationDialog(
            "Delete Share Permanently?",
            `Are you sure you want to <strong>permanently delete</strong> the share link for "${AppUtils.escapeHtml(deviceName || 'this device')}"? This cannot be undone.`,
            async () => {
                console.log(`[UI] Deleting share ${shareId} permanently.`);
                try {
                    // This calls DELETE /api/shares/<share_id>
                    const result = await AppApi.revokeShare(shareId); // <<< KEEP THIS NAME, it maps to the DELETE route
                    this.showConfirmationDialog("Share Deleted", result.message || "Share link permanently deleted."); // Use result message
                    this.renderActiveSharesList(); // Refresh the list
                    AppActions.refreshDevices(); // Refresh device list status
                } catch (error) {
                    console.error("Error deleting share:", error);
                    this.showErrorDialog("Deletion Failed", `Could not delete share: ${error.message}`);
                }
            },
            null,
            true
        );
    },




    // --- START: New Share Management Handlers ---
    handleToggleShareStatus: async function (shareId, currentIsActive) {
        const newStatus = !currentIsActive;
        const action = newStatus ? "resume" : "suspend";
        console.log(`[UI] Toggling share ${shareId} status to ${newStatus}`);
        // Optionally show visual feedback on the button
        const button = document.querySelector(`.toggle-share-button[data-share-id="${shareId}"]`);
        if (button) button.disabled = true;

        try {
            await AppApi.toggleShareStatus(shareId, newStatus);
            // Refresh lists to reflect the change
            this.renderActiveSharesList();
            AppActions.refreshDevices(); // Refresh device list to update share icon
            this.showConfirmationDialog("Share Updated", `Share link has been ${action}d.`);
        } catch (error) {
            console.error(`Error ${action}ing share:`, error);
            this.showErrorDialog("Update Failed", `Could not ${action} share link: ${error.message}`);
            if (button) button.disabled = false; // Re-enable button on error
        }
    },

    // Helper to copy text - used by share link dialog and list item copy button
    copyTextToClipboard: async function (textToCopy, buttonElement = null) {
        if (!textToCopy) return;

        let originalButtonContent = null;
        if (buttonElement) {
            originalButtonContent = buttonElement.innerHTML;
            buttonElement.innerHTML = '<span class="material-icons" style="font-size: 16px;">pending</span>'; // Show pending/spinner
            buttonElement.disabled = true;
        }

        try {
            await navigator.clipboard.writeText(textToCopy);
            console.log('[UI] Text copied to clipboard:', textToCopy.substring(0, 50) + '...');
            if (buttonElement) {
                buttonElement.innerHTML = '<span class="material-icons" style="font-size: 16px; color: var(--m3-sys-color-primary);">check</span>'; // Show success
                setTimeout(() => {
                    if (originalButtonContent) buttonElement.innerHTML = originalButtonContent;
                    buttonElement.disabled = false;
                }, 1500);
            } else {
                // If no button, maybe show general confirmation
                this.showConfirmationDialog("Copied!", "Link copied to clipboard.");
            }
        } catch (err) {
            console.error('[UI] Failed to copy text: ', err);
            if (buttonElement) {
                buttonElement.innerHTML = '<span class="material-icons" style="font-size: 16px; color: var(--m3-sys-color-error);">close</span>'; // Show failure
                setTimeout(() => {
                    if (originalButtonContent) buttonElement.innerHTML = originalButtonContent;
                    buttonElement.disabled = false;
                }, 2000);
            }
            this.showErrorDialog("Copy Failed", "Could not copy text automatically. Please copy manually.");
        }
    },


    _approximateDurationStringFromExpiry: function (expiresAtISO) {
        if (!expiresAtISO) return "indefinite";
        try {
            const expiryDate = new Date(expiresAtISO.replace("Z", "+00:00"));
            const now = new Date();
            if (expiryDate < now) return "expired"; // Indicate if already expired

            const diffHours = (expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60);

            if (diffHours < 1.5) return "1h";
            if (diffHours < 7) return "6h";
            if (diffHours < 25) return "24h";
            if (diffHours < (8 * 24)) return "7d";
            if (diffHours < (31 * 24)) return "30d";
            return "indefinite"; // If very far in future, treat as indefinite for dropdown
        } catch {
            return "24h"; // Default fallback
        }
    },


    openEditShareDialog: function (share) {
        // --- Updated with Null Checks ---
        if (!share) return;
        const shareIdInput = document.getElementById('edit-share-id');
        const deviceNameEl = document.getElementById('edit-share-device-name');
        const expiryEl = document.getElementById('edit-share-current-expiry');
        const durationSelect = document.getElementById('edit-share-duration-select');
        const noteInput = document.getElementById('edit-share-note-input');
        const errorEl = document.getElementById('edit-share-error');
        const saveButton = document.getElementById('save-share-edit-button');
        if (!shareIdInput || !deviceNameEl || !expiryEl || !durationSelect || !noteInput || !errorEl || !saveButton) { console.error("[UI Error] Elements missing in edit-share-dialog."); this.showErrorDialog("UI Error", "Could not load dialog elements."); return; }

        shareIdInput.value = share.share_id;
        deviceNameEl.textContent = share.device_name || 'this device';
        if (share.expires_at) { try { expiryEl.textContent = AppUtils.formatTime(new Date(share.expires_at.replace("Z", "+00:00"))); } catch { expiryEl.textContent = "Invalid Date"; } }
        else { expiryEl.textContent = "Never"; }
        const approxDuration = this._approximateDurationStringFromExpiry(share.expires_at);
        durationSelect.value = approxDuration;
        noteInput.value = share.note || '';
        errorEl.style.display = 'none';
        const newSaveButton = saveButton.cloneNode(true);
        newSaveButton.onclick = () => this.handleEditShareSubmit();
        saveButton.parentNode.replaceChild(newSaveButton, saveButton);
        this.openDialog('edit-share-dialog');
        // --- End Updated with Null Checks ---
    },

    handleEditShareSubmit: async function () {
        const shareId = document.getElementById('edit-share-id').value;
        const duration = document.getElementById('edit-share-duration-select').value;
        const note = document.getElementById('edit-share-note-input').value;
        const errorElement = document.getElementById('edit-share-error');
        const saveButton = document.getElementById('save-share-edit-button');

        if (!shareId || !duration) { errorElement.textContent = "Missing share ID or duration."; errorElement.style.display = 'block'; return; }

        errorElement.style.display = 'none';
        saveButton.disabled = true;
        saveButton.innerHTML = `<div class="spinner" style="width:18px;height:18px;border-width:2px;margin:0 auto;"></div> Saving...`;

        try {
            await AppApi.updateShareDuration(shareId, duration, note);
            this.closeDialog('edit-share-dialog');
            this.showConfirmationDialog("Share Updated", "Share duration and note have been updated.");
            this.renderActiveSharesList(); // Refresh list
        } catch (error) {
            console.error("Error updating share:", error);
            errorElement.textContent = `Failed to update share: ${error.message}`;
            errorElement.style.display = 'block';
            this.showErrorDialog("Update Failed", `Could not update share: ${error.message}`);
        } finally {
            saveButton.disabled = false;
            saveButton.innerHTML = 'Save Changes';
        }
    },










    // --- END: New Share Dialog Functions ---




    // --- NEW: Trigger Test Notification ---
    triggerTestNotification: async function (deviceId, type) {
        console.log(`[UI] Triggering test notification for ${deviceId}, type: ${type}`);
        try {
            this.showConfirmationDialog("Sending...", `Sending test '${type}' notification...`, null, null);
            const result = await AppApi.testDeviceNotification(deviceId, type);
            this.closeDialog('confirmation-dialog'); // Close sending dialog
            this.showConfirmationDialog("Test Sent", result.message || "Test notification sent.");
        } catch (error) {
            console.error("Failed to send test notification:", error);
            this.closeDialog('confirmation-dialog'); // Close sending dialog
            this.showErrorDialog("Test Failed", `Could not send test notification: ${error.message}`);
        }
    },

    // --- NEW: Notification History Rendering ---
    renderNotificationHistory: async function () {
        const listContainer = document.getElementById('notifications-history-list');
        const loadingIndicator = document.getElementById('notifications-history-loading');
        const noItemsMessage = document.getElementById('no-notifications-history-message');
        const markAllReadButton = document.getElementById('mark-all-read-button');
        const clearAllButton = document.getElementById('clear-all-history-button');

        if (!listContainer || !loadingIndicator || !noItemsMessage || !markAllReadButton || !clearAllButton) {
            console.error("Notification history UI elements missing.");
            return;
        }

        loadingIndicator.style.display = 'block';
        listContainer.style.display = 'none';
        noItemsMessage.style.display = 'none';
        listContainer.innerHTML = ''; // Clear previous items
        markAllReadButton.onclick = null; // Clear previous listener
        clearAllButton.onclick = null; // Clear previous listener

        try {
            const history = await AppApi.fetchNotificationHistory();

            if (history.length === 0) {
                noItemsMessage.style.display = 'block';
                markAllReadButton.disabled = true;
                clearAllButton.disabled = true;
            } else {
                listContainer.style.display = 'block';
                let hasUnread = false;
                history.forEach(item => {
                    const itemElement = document.createElement('div');
                    itemElement.classList.add('notification-item');
                    itemElement.dataset.id = item.id;
                    itemElement.dataset.type = item.data?.type || 'unknown';
                    if (!item.is_read) {
                        itemElement.classList.add('unread');
                        hasUnread = true;
                    }

                    let icon = 'notifications'; // Default icon
                    switch (item.data?.type) {
                        case 'geofence': icon = 'radar'; break;
                        case 'battery': icon = 'battery_alert'; break;
                        case 'welcome': icon = 'celebration'; break;
                        case 'test': icon = 'science'; break;
                    }

                    const timestamp = item.timestamp ? AppUtils.formatTimeRelative(new Date(item.timestamp)) : 'Unknown time';

                    itemElement.innerHTML = `
                        <div class="notification-icon">
                            <span class="material-icons">${icon}</span>
                        </div>
                        <div class="notification-content">
                            <div class="notification-title">${item.title || 'Notification'}</div>
                            <div class="notification-body">${item.body || '(No body)'}</div>
                            <div class="notification-timestamp">${timestamp}</div>
                        </div>
                        <div class="notification-actions">
                            <button class="mark-read-unread-button" title="${item.is_read ? 'Mark as Unread' : 'Mark as Read'}" data-id="${item.id}" data-current-status="${item.is_read}">
                                <span class="material-icons">${item.is_read ? 'mark_chat_unread' : 'mark_chat_read'}</span>
                            </button>
                            <button class="delete-notification-button" title="Delete Notification" data-id="${item.id}">
                                <span class="material-icons">delete_outline</span>
                            </button>
                        </div>
                    `;

                    // Add event listeners for actions
                    itemElement.querySelector('.mark-read-unread-button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.handleMarkNotificationReadUnread(item.id, !item.is_read);
                    });
                    itemElement.querySelector('.delete-notification-button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.handleDeleteNotification(item.id, item.title);
                    });

                    listContainer.appendChild(itemElement);
                });

                // Enable/disable global buttons
                markAllReadButton.disabled = !hasUnread;
                clearAllButton.disabled = false;

                // Add listeners for global buttons
                markAllReadButton.onclick = () => this.handleMarkAllRead();
                clearAllButton.onclick = () => this.handleClearAllHistory();
            }

        } catch (error) {
            console.error("Error loading notification history:", error);
            noItemsMessage.textContent = `Error loading history: ${error.message}`;
            noItemsMessage.style.display = 'block';
            markAllReadButton.disabled = true;
            clearAllButton.disabled = true;
        } finally {
            loadingIndicator.style.display = 'none';
        }
    },

    handleMarkNotificationReadUnread: async function (notificationId, markAsRead) {
        console.log(`[UI] Marking notification ${notificationId} as ${markAsRead ? 'read' : 'unread'}`);
        const itemElement = document.querySelector(`.notification-item[data-id="${notificationId}"]`);
        const button = itemElement?.querySelector('.mark-read-unread-button');
        if (button) button.disabled = true; // Disable button during API call

        try {
            if (markAsRead) {
                await AppApi.markNotificationRead(notificationId);
            } else {
                await AppApi.markNotificationUnread(notificationId);
            }
            // Visually update the item without full refresh
            if (itemElement) {
                itemElement.classList.toggle('unread', !markAsRead);
                const iconEl = button.querySelector('.material-icons');
                const titleEl = itemElement.querySelector('.notification-title');
                if (iconEl) iconEl.textContent = markAsRead ? 'mark_chat_unread' : 'mark_chat_read';
                if (button) button.title = markAsRead ? 'Mark as Unread' : 'Mark as Read';
                if (button) button.dataset.currentStatus = markAsRead;
                if (titleEl) titleEl.style.fontWeight = markAsRead ? 'normal' : 'var(--title-medium-weight)';
            }
            // Check if Mark All Read button needs updating
            const hasAnyUnread = document.querySelector('#notifications-history-list .notification-item.unread');
            const markAllBtn = document.getElementById('mark-all-read-button');
            if (markAllBtn) markAllBtn.disabled = !hasAnyUnread;

        } catch (error) {
            console.error("Error updating notification read status:", error);
            this.showErrorDialog("Update Failed", `Could not update notification status: ${error.message}`);
        } finally {
            if (button) button.disabled = false;
        }
    },

    handleDeleteNotification: function (notificationId, title) {
        this.showConfirmationDialog(
            "Delete Notification?",
            `Are you sure you want to delete the notification "${title || notificationId}"?`,
            async () => {
                console.log(`[UI] Deleting notification ${notificationId}`);
                try {
                    await AppApi.deleteNotification(notificationId);
                    const itemElement = document.querySelector(`.notification-item[data-id="${notificationId}"]`);
                    if (itemElement) {
                        itemElement.style.transition = 'opacity 0.3s ease-out, height 0.3s ease-out';
                        itemElement.style.opacity = '0';
                        itemElement.style.height = '0';
                        itemElement.style.padding = '0';
                        itemElement.style.margin = '0';
                        setTimeout(() => {
                            itemElement.remove();
                            // Check if list is now empty
                            const listContainer = document.getElementById('notifications-history-list');
                            const noItemsMessage = document.getElementById('no-notifications-history-message');
                            if (listContainer && noItemsMessage && listContainer.children.length === 0) {
                                noItemsMessage.style.display = 'block';
                                listContainer.style.display = 'none';
                                document.getElementById('clear-all-history-button').disabled = true;
                                document.getElementById('mark-all-read-button').disabled = true;
                            }
                        }, 300);
                    }
                } catch (error) {
                    console.error("Error deleting notification:", error);
                    this.showErrorDialog("Delete Failed", `Could not delete notification: ${error.message}`);
                }
            }
        );
    },

    handleMarkAllRead: async function () {
        console.log("[UI] Marking all notifications as read...");
        const unreadItems = document.querySelectorAll('#notifications-history-list .notification-item.unread');
        if (unreadItems.length === 0) return;

        const markAllBtn = document.getElementById('mark-all-read-button');
        markAllBtn.disabled = true;

        let success = true;
        // Mark all visually first for responsiveness
        unreadItems.forEach(itemElement => {
            itemElement.classList.remove('unread');
            const button = itemElement.querySelector('.mark-read-unread-button');
            const iconEl = button?.querySelector('.material-icons');
            const titleEl = itemElement.querySelector('.notification-title');
            if (iconEl) iconEl.textContent = 'mark_chat_unread';
            if (button) button.title = 'Mark as Unread';
            if (button) button.dataset.currentStatus = 'true';
            if (titleEl) titleEl.style.fontWeight = 'normal';
        });

        // Then send API requests (can be done concurrently)
        const promises = Array.from(unreadItems).map(item => AppApi.markNotificationRead(item.dataset.id));

        try {
            await Promise.all(promises);
            console.log("[UI] Mark all read API calls completed.");
        } catch (error) {
            console.error("Error marking all notifications read:", error);
            this.showErrorDialog("Update Failed", `Could not mark all notifications read: ${error.message}`);
            success = false;
            // Re-render might be needed here to correct visual state on error
            this.renderNotificationHistory();
        } finally {
            if (success) markAllBtn.disabled = true; // Should be no unread left
            else markAllBtn.disabled = false; // Re-enable if errors occurred
        }
    },

    handleClearAllHistory: function () {
        this.showConfirmationDialog(
            "Clear All History?",
            "Are you sure you want to delete ALL notification history? This cannot be undone.",
            async () => {
                console.log("[UI] Clearing all notification history...");
                try {
                    await AppApi.deleteAllNotifications();
                    this.renderNotificationHistory(); // Re-render the empty list
                    this.showConfirmationDialog("History Cleared", "Notification history has been deleted.");
                } catch (error) {
                    console.error("Error clearing notification history:", error);
                    this.showErrorDialog("Clear Failed", `Could not clear history: ${error.message}`);
                }
            }
        );
    },

    openPlaceMenu: function (placeIndex, anchorElement) {
        const place = AppState.savedPlaces[placeIndex]; if (!place) return; const menuItems = [];
        if (place.lat && place.lng) { menuItems.push({ label: "View on Map", icon: "map", action: () => AppMap.viewPlaceOnMap(placeIndex) }); }
        menuItems.push({ label: "Share", icon: "share", action: () => this.sharePlace(placeIndex) });
        menuItems.push({ label: "Remove", icon: "delete_outline", action: () => this.confirmRemoveItem('place', placeIndex, place.name, this.removePlace.bind(this)) });
        const dialogContent = document.getElementById('device-menu-dialog-content'); dialogContent.innerHTML = '';
        document.getElementById('device-menu-dialog-title').textContent = place.name || "Place Options";
        menuItems.forEach(item => {
            const menuItem = document.createElement('div'); menuItem.classList.add('drawer-item'); menuItem.setAttribute('tabindex', '0'); menuItem.setAttribute('role', 'menuitem');
            menuItem.innerHTML = `${item.icon ? `<span class="material-icons drawer-item-icon">${item.icon}</span>` : ''}<span class="drawer-item-text">${item.label}</span>`;
            const actionHandler = () => { item.action(); this.closeDialog('device-menu-dialog'); }; menuItem.onclick = actionHandler; menuItem.onkeypress = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); actionHandler(); } };
            dialogContent.appendChild(menuItem);
        });
        this.openDialog('device-menu-dialog');
    },

    openMoreMenu: function () {
        const menu = document.getElementById('more-menu-dialog'); const overlay = document.getElementById('more-menu-dialog-overlay'); const button = document.getElementById('more-button');
        if (!menu || !overlay || !button) return;
        const rect = button.getBoundingClientRect();
        const items = [
            { label: "Refresh Devices", icon: "refresh", action: () => { AppActions.refreshDevices(); } },
            { label: "Add Saved Place", icon: "add_location", action: this.openAddPlaceDialog.bind(this) },
            { label: "Settings", icon: "settings", action: () => this.changePage('settings') },
            { label: "Import/Export", icon: "import_export", action: () => this.changePage('settings', 'settings-import-export') },
            { label: "Help & Feedback", icon: "help_outline", action: () => this.openDialog('help-dialog') }
        ];
        const content = menu.querySelector('.dialog-content'); content.innerHTML = '';
        items.forEach(item => {
            const menuItem = document.createElement('div'); menuItem.classList.add('drawer-item'); menuItem.setAttribute('tabindex', '0'); menuItem.setAttribute('role', 'menuitem');
            menuItem.innerHTML = `<span class="material-icons drawer-item-icon">${item.icon}</span><span class="drawer-item-text">${item.label}</span>`;
            menuItem.onclick = () => { item.action(); this.closeMoreMenu(); }; menuItem.onkeypress = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); item.action(); this.closeMoreMenu(); } }; content.appendChild(menuItem);
        });
        menu.style.top = `${rect.bottom + 8}px`; menu.style.right = `${window.innerWidth - rect.right}px`; menu.style.left = 'auto';
        overlay.classList.add('show'); this._trapFocus(menu);
    },

    closeMoreMenu: function () {
        const overlay = document.getElementById('more-menu-dialog-overlay'); const menu = document.getElementById('more-menu-dialog');
        if (overlay) overlay.classList.remove('show');
        if (menu) this._releaseFocus(menu);
    },

    // --- Drawer ---
    openDrawer: function () {
        const drawer = document.getElementById('drawer');
        const overlay = document.getElementById('drawer-overlay');
        if (drawer) drawer.classList.add('open');
        if (overlay) overlay.classList.add('show');
        if (drawer) this._trapFocus(drawer);
    },
    closeDrawer: function () {
        const drawer = document.getElementById('drawer');
        const overlay = document.getElementById('drawer-overlay');
        if (drawer) drawer.classList.remove('open');
        if (overlay) overlay.classList.remove('show');
        if (drawer) this._releaseFocus(drawer);
        document.getElementById('menu-button')?.focus();
    },

    // --- Page Navigation ---
    changePage: function (pageId, sectionId = null) { // MODIFIED BELOW
        console.log("[UI] Changing page to:", pageId, "Section:", sectionId);
        const pages = ['index', 'shared', 'places', 'history', 'geofences', 'settings', 'notifications-history'];
        const fab = document.getElementById('add-place-button');
        const mainContent = document.getElementById('main-content');

        pages.forEach(id => { const pageElement = document.getElementById(id + '-page'); if (pageElement) pageElement.style.display = 'none'; });
        document.querySelectorAll('.nav-link').forEach(l => { l.classList.remove('active'); if (l.getAttribute('data-page') === pageId) { l.classList.add('active'); } });

        const targetPage = document.getElementById(pageId + '-page');
        if (targetPage) {
            targetPage.style.display = 'block';
            if (mainContent) mainContent.scrollTop = 0;

            // Handle page-specific actions AFTER display is set
            if (pageId === 'index') {
                // --- MODIFIED Map Handling ---
                if (AppState.getMap()) {
                    // If map exists, just invalidate size
                    AppMap.invalidateMapSize();
                    AppMap.updateMapView(); // Ensure correct markers/focus
                } else {
                    // If map doesn't exist, initMap (which shows placeholder)
                    AppMap.initMap();
                }
            }
            else if (pageId === 'shared') { this.renderDevicesList(AppState.getCurrentDeviceData()); AppActions.refreshDevices(); }
            else if (pageId === 'places') { this.renderSavedPlacesList(); }
            else if (pageId === 'history') { this.renderLocationHistory(); }
            else if (pageId === 'settings') {
                this.setupSettingsPage();
                // --- START: Call renderActiveSharesList ---
                this.renderActiveSharesList(); // Load shares when settings page is shown
                // --- END: Call renderActiveSharesList ---
                if (sectionId) { setTimeout(() => this.scrollToSection(sectionId), 100); }
            }
            else if (pageId === 'geofences') { this.renderGlobalGeofences(); this.renderDeviceGeofenceLinks(); AppActions.refreshGeofencesAndDevices(); }
            else if (pageId === 'notifications-history') { this.renderNotificationHistory(); }
        } else {
            console.error("[UI] Target page not found:", pageId + '-page');
            this.changePage('index');
            return;
        }

        if (fab) { fab.style.display = (pageId === 'places') ? 'flex' : 'none'; }
    },

    scrollToSection: function (sectionId) {
        const sectionElement = document.getElementById(sectionId);
        if (sectionElement) {
            console.log(`[UI] Scrolling to section: #${sectionId}`);
            sectionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            sectionElement.style.outline = '2px solid var(--primary-color)';
            setTimeout(() => { sectionElement.style.outline = 'none'; }, 2500);
        } else { console.warn(`[UI] Section element not found: #${sectionId}`); }
    },

    navigateToGeofenceDeviceCard: function (deviceId) {
        this.changePage('geofences');
        setTimeout(() => {
            const card = document.getElementById(`device-link-card-${deviceId}`);
            if (card) {
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                card.style.outline = '2px solid var(--primary-color)';
                setTimeout(() => { card.style.outline = 'none'; }, 2000);
            } else { console.warn(`[UI] Device card device-link-card-${deviceId} not found after page change.`); }
        }, 300);
    },

    // --- List Rendering ---
    renderDevicesList: function (devices) {
        const listElement = document.getElementById('shared-devices-list');
        const loadingIndicator = document.getElementById('devices-loading-indicator');
        const noDevicesMessage = document.getElementById('no-devices-message');
        const errorMessageElement = document.getElementById('devices-error-message');
        if (!listElement || !loadingIndicator || !noDevicesMessage || !errorMessageElement) return;

        loadingIndicator.style.display = 'none'; errorMessageElement.style.display = 'none'; listElement.innerHTML = '';
        if (!devices || devices.length === 0) { noDevicesMessage.innerHTML = `...`; noDevicesMessage.style.display = 'block'; listElement.style.display = 'none'; return; }
        noDevicesMessage.style.display = 'none'; listElement.style.display = 'block';


        devices.forEach((device, index) => {
            const displayInfo = AppState.getDeviceDisplayInfo(device.id);
            const deviceElement = document.createElement('div');
            deviceElement.classList.add('shared-device'); deviceElement.setAttribute('tabindex', '0'); deviceElement.setAttribute('role', 'button');
            const locationStatusText = (displayInfo.lat != null && displayInfo.lng != null) ? displayInfo.status : "Location Unknown"; deviceElement.setAttribute('aria-label', `Device: ${displayInfo.name}, Status: ${locationStatusText}`); deviceElement.dataset.deviceId = device.id;

            let batteryIcon = 'battery_unknown';
            let batteryClass = ''; // For error styling
            let batteryTooltip = '';
            if (displayInfo.batteryLevel != null) {
                const level = displayInfo.batteryLevel;
                batteryTooltip = `${level.toFixed(0)}%`;
                // Use Material Symbols names
                if (level > 95) batteryIcon = 'battery_full';
                else if (level > 80) batteryIcon = 'battery_6_bar';
                else if (level > 60) batteryIcon = 'battery_5_bar';
                else if (level > 40) batteryIcon = 'battery_4_bar';
                else if (level > 25) batteryIcon = 'battery_3_bar';
                // Use LOW_BATTERY_THRESHOLD from AppConfig
                else if (level >= AppConfig.LOW_BATTERY_THRESHOLD) batteryIcon = 'battery_alert'; // Low but not critical yet? Or use 1/2 bar? Let's use alert for now.
                else { batteryIcon = 'battery_0_bar'; batteryClass = 'error'; } // Very Low/Critical
            } else if (displayInfo.batteryStatus !== 'Unknown') {
                batteryTooltip = displayInfo.batteryStatus;
                if (displayInfo.batteryStatus === 'Low' || displayInfo.batteryStatus === 'Very Low') {
                    batteryIcon = 'battery_alert'; batteryClass = 'error';
                }
            }

            // --- START: Fix Battery Indicator ---
            // Use material-symbols-outlined class
            const batteryIndicator = batteryTooltip
                ? `<span class="material-symbols-outlined ${batteryClass}" style="font-size: 18px; vertical-align: middle; font-variation-settings: 'FILL' 1;" title="${batteryTooltip}">${batteryIcon}</span>`
                : '';
            // --- END: Fix Battery Indicator ---

            const iconHtml = displayInfo.svg_icon || `<div class="device-icon-fallback">?</div>`;
            const isCurrentlyVisible = displayInfo.isVisible;
            const visibilityToggleHtml = `<label class="toggle-switch device-visibility-toggle" style="margin-left: 16px;" title="Show/Hide on Map"><input type="checkbox" data-device-id="${device.id}" ${isCurrentlyVisible ? 'checked' : ''}><span class="toggle-slider"></span></label>`;
            let displayStatus = displayInfo.status || 'Unknown Status';
            if (displayInfo.lat == null && displayInfo.lng == null && displayInfo.status === 'Location Unknown') { displayStatus = 'Awaiting first location...'; }
            else { displayStatus = displayStatus.replace(/ - Batt:.*$/, ''); } // Remove battery part if present

            const shareIndicatorHtml = device.is_shared
                ? `<span class="material-icons share-indicator" title="Shared" style="font-size: 16px; vertical-align: middle; margin-left: 4px; opacity: 0.7; color: var(--m3-sys-color-secondary);">share</span>`
                : '';

            deviceElement.innerHTML = `
               <div class="device-icon">${iconHtml}</div>
               <div class="device-info">
                   <div class="device-name">${displayInfo.name}</div>
                   <div class="device-status" title="${displayInfo.address || displayInfo.locationTimestamp || ''}">
                       ${displayStatus} ${batteryIndicator} ${shareIndicatorHtml}
                   </div>
                   <div class="device-status" style="font-size: var(--body-small-size); opacity: 0.7;">${displayInfo.model || 'Accessory/Tag'}</div>
               </div>
               ${visibilityToggleHtml}
               <span class="material-icons device-menu" data-device-index="${index}" tabindex="0" role="button" aria-label="Device options for ${displayInfo.name}">more_vert</span>`;
            listElement.appendChild(deviceElement);
        });
    },

    renderSavedPlacesList: function () {
        const listElement = document.getElementById('saved-places-list'); const noPlacesMessage = document.getElementById('no-places-message');
        if (!listElement || !noPlacesMessage) return; listElement.innerHTML = ''; const savedPlaces = AppState.savedPlaces;
        if (savedPlaces.length === 0) { noPlacesMessage.style.display = 'block'; listElement.appendChild(noPlacesMessage); return; }
        noPlacesMessage.style.display = 'none';
        savedPlaces.forEach((place, index) => {
            const placeElement = document.createElement('div'); placeElement.classList.add('shared-device'); placeElement.setAttribute('tabindex', '0'); placeElement.setAttribute('role', 'button'); placeElement.dataset.placeIndex = index;
            placeElement.innerHTML = `<div class="device-icon" style="background-color: var(--primary-color-light); border-radius: 50%;"><span class="material-icons" style="color: var(--primary-color);">star</span></div><div class="device-info"><div class="device-name">${place.name}</div><div class="device-status">${place.description || 'Saved Location'}</div><div class="device-status" style="font-size: var(--body-small-size); opacity: 0.7;">${place.lat ? place.lat.toFixed(4) + '°, ' + place.lng.toFixed(4) + '°' : 'Coordinates N/A'}</div></div><span class="material-icons device-menu" data-place-index="${index}" tabindex="0" role="button" aria-label="Options for ${place.name}">more_vert</span>`;
            listElement.appendChild(placeElement);
        });
    },

    renderGlobalGeofences: function () {
        const listContainer = document.getElementById('global-geofences-list'); const loadingIndicator = document.getElementById('global-geofences-loading'); const noItemsMessage = document.getElementById('no-global-geofences-message');
        if (!listContainer || !loadingIndicator || !noItemsMessage) return; const geofences = AppState.getGlobalGeofences();
        loadingIndicator.style.display = 'none'; listContainer.innerHTML = '';
        if (geofences.length === 0) { noItemsMessage.style.display = 'block'; listContainer.style.display = 'none'; return; }
        noItemsMessage.style.display = 'none'; listContainer.style.display = 'block';
        geofences.forEach(gf => {
            const item = document.createElement('div'); item.className = 'settings-item geofence-list-item'; item.setAttribute('tabindex', '0'); item.setAttribute('role', 'button'); item.setAttribute('aria-label', `Geofence: ${gf.name}, click to edit`); item.dataset.geofenceId = gf.id;
            item.innerHTML = `<span class="material-icons drawer-item-icon" style="margin-right: 16px;">radar</span> <div class="settings-item-text"> <div class="settings-item-title">${gf.name}</div> <div class="settings-item-description"> Radius: ${gf.radius}m | Center: ${gf.lat.toFixed(4)}°, ${gf.lng.toFixed(4)}° </div> </div> <span class="material-icons geofence-edit" title="Edit Geofence" data-geofence-id="${gf.id}" style="margin-left: auto; cursor: pointer; opacity: 0.6;" tabindex="0" role="button" aria-label="Edit ${gf.name}">edit</span> <span class="material-icons geofence-remove" title="Remove Geofence" data-geofence-id="${gf.id}" style="margin-left: 8px; cursor: pointer; opacity: 0.6; color: var(--error-color);" tabindex="0" role="button" aria-label="Remove ${gf.name}">delete_outline</span>`;
            listContainer.appendChild(item);
        });
    },

    renderDeviceGeofenceLinks: function () {
        const container = document.getElementById('device-geofence-links-list'); const loadingIndicator = document.getElementById('device-links-loading'); const noDevicesMsg = document.getElementById('links-no-devices-message');
        if (!container || !loadingIndicator || !noDevicesMsg) return; const devices = AppState.getCurrentDeviceData(); const globalGeofences = AppState.getGlobalGeofences();
        loadingIndicator.style.display = 'none'; container.innerHTML = '';
        if (devices.length === 0) { noDevicesMsg.style.display = 'block'; return; } noDevicesMsg.style.display = 'none';
        devices.forEach(device => {
            const displayInfo = AppState.getDeviceDisplayInfo(device.id); const iconHtml = displayInfo.svg_icon || `<div class="device-icon-fallback">?</div>`;
            const deviceCard = document.createElement('div'); deviceCard.className = 'card device-geofence-card'; deviceCard.id = `device-link-card-${device.id}`;
            const linkedItemsHtml = (displayInfo.geofences || []).map(linkedGf => `<div class="geofence-link-item" data-geofence-id="${linkedGf.id}"><div class="geofence-link-info"><div class="geofence-link-name">${linkedGf.name}</div><div class="geofence-link-details">Radius: ${linkedGf.radius}m</div></div><div class="geofence-link-toggles"><label class="geofence-link-toggle-label" title="Notify on Entry"><input type="checkbox" data-notify-type="entry" ${linkedGf.notify_on_entry ? 'checked' : ''}> Entry</label><label class="geofence-link-toggle-label" title="Notify on Exit"><input type="checkbox" data-notify-type="exit" ${linkedGf.notify_on_exit ? 'checked' : ''}> Exit</label><span class="material-icons geofence-remove" title="Unlink Geofence" data-geofence-id="${linkedGf.id}" style="margin-left: 8px; cursor: pointer; opacity: 0.6; color: var(--error-color);" tabindex="0" role="button" aria-label="Unlink ${linkedGf.name}">link_off</span></div></div>`).join('');
            const linkedIds = new Set((displayInfo.geofences || []).map(gf => gf.id)); const availableGeofences = globalGeofences.filter(gf => !linkedIds.has(gf.id));
            const addOptionsHtml = availableGeofences.length > 0 ? availableGeofences.map(gf => `<option value="${gf.id}">${gf.name}</option>`).join('') : '<option value="" disabled>No other geofences available</option>';
            const addSectionHtml = `<div style="display: flex; align-items: center; gap: 8px; margin-top: 16px; padding-top: 16px; border-top: 1px dashed var(--outline-variant-color);"><select class="add-geofence-select" style="flex-grow: 1; padding: 8px; border-radius: 8px; border: 1px solid var(--outline-color); background-color: var(--surface-color); color: var(--on-surface-color);"><option value="" disabled selected>-- Link a Geofence --</option>${addOptionsHtml}</select><button class="button link-geofence-button" style="padding: 8px 16px;" ${availableGeofences.length === 0 ? 'disabled' : ''}><span class="material-icons" style="font-size: 18px; vertical-align: bottom;">link</span></button></div><p id="link-error-${device.id}" style="color: var(--error-color); font-size: var(--body-small-size); margin-top: 4px; display: none;"></p>`;
            deviceCard.innerHTML = `<div class="card-title" style="display: flex; align-items: center;"><div class="device-icon" style="width: 36px; height: 36px; margin-right: 12px;">${iconHtml}</div><span style="flex-grow: 1;">${displayInfo.name}</span><button class="button save-links-button" data-device-id="${device.id}" style="margin-left: auto; padding: 8px 12px; display: none;"><span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Save Changes</button></div><div class="linked-geofences-list">${linkedItemsHtml || '<p class="no-geofences-message" style="padding: 8px 0; font-style: italic; opacity: 0.7;">No geofences linked yet.</p>'}</div>${addSectionHtml}`;
            container.appendChild(deviceCard);
        });
    },

    renderAddGeofenceDropdown: function (deviceCardElement, deviceId) {
        const selectElement = deviceCardElement.querySelector('.add-geofence-select'); const linkButton = deviceCardElement.querySelector('.link-geofence-button');
        if (!selectElement || !linkButton) return; const currentLinkedItems = deviceCardElement.querySelectorAll('.geofence-link-item');
        const linkedIds = new Set(Array.from(currentLinkedItems).map(item => item.dataset.geofenceId)); const globalGeofences = AppState.getGlobalGeofences();
        const availableGeofences = globalGeofences.filter(gf => !linkedIds.has(gf.id));
        const addOptionsHtml = availableGeofences.length > 0 ? availableGeofences.map(gf => `<option value="${gf.id}">${gf.name}</option>`).join('') : '<option value="" disabled>No other geofences available</option>';
        selectElement.innerHTML = `<option value="" disabled selected>-- Link a Geofence --</option> ${addOptionsHtml}`; linkButton.disabled = availableGeofences.length === 0;
    },

    renderLocationHistory: function () {
        const c = document.getElementById('location-history-container'); const l = document.getElementById('history-loading-indicator'); const t = document.getElementById('location-timeline');
        const n = document.getElementById('no-history-message'); const d = document.getElementById('history-disabled-message'); if (!c || !l || !t || !n || !d) return;
        l.style.display = 'none'; t.innerHTML = ''; n.style.display = 'none'; d.style.display = 'none'; t.style.display = 'block';
        if (!AppState.locationHistoryEnabled) { d.style.display = 'block'; t.style.display = 'none'; return; }
        if (AppState.locationHistory.length === 0) { n.style.display = 'block'; t.appendChild(n); return; }
        AppState.locationHistory.forEach(item => {
            const li = document.createElement('div'); li.classList.add('timeline-item');
            li.innerHTML = `<div class="timeline-dot"></div><div class="timeline-time">${item.time}</div><div class="timeline-content"><div class="timeline-location">${item.location}</div><p>${item.address || 'N/A'}</p>${item.lat ? `<p style="font-size:var(--body-small-size);opacity:0.7;">${item.lat.toFixed(4)}°, ${item.lng.toFixed(4)}°</p>` : ''}</div>`;
            t.appendChild(li);
        });
    },

    // --- UI State Updates ---
    setTheme: function (themeName) {
        console.log("[UI] Setting theme:", themeName); AppState.currentTheme = themeName; AppState.saveTheme();
        const body = document.body; const metaThemeColor = document.getElementById('meta-theme-color'); body.classList.remove('dark-theme', 'light-theme');
        let isDark = false;
        if (themeName === 'dark') { body.classList.add('dark-theme'); isDark = true; }
        else if (themeName === 'light') { body.classList.add('light-theme'); }
        else { if (window.matchMedia?.('(prefers-color-scheme: dark)').matches) { body.classList.add('dark-theme'); isDark = true; } else { body.classList.add('light-theme'); } }
        if (metaThemeColor) metaThemeColor.setAttribute('content', isDark ? '#1E1B22' : '#FDFCFE'); // Match CSS background
        AppMap.updateMapThemeStyle(isDark); document.querySelectorAll('input[name="theme"]').forEach(r => r.checked = (r.value === AppState.currentTheme));
        document.querySelectorAll('input[name="theme-dialog"]').forEach(r => r.checked = (r.value === AppState.currentTheme));
        AppMap.redrawGeofenceLayer();
    },

    updateShowAllButtonState: function () {
        const button = document.getElementById('show-all-button'); const icon = document.getElementById('show-all-icon'); if (!button || !icon) return;
        const isActive = AppState.isShowingAllDevices; button.classList.toggle('active', isActive); button.setAttribute('aria-pressed', isActive.toString());
        button.setAttribute('aria-label', isActive ? 'Hide all devices and places' : 'Show all devices and places'); icon.textContent = isActive ? 'layers_clear' : 'layers';
    },

    updateShowHistoryButtonState: function () {
        const button = document.getElementById('show-history-button');
        const sliderContainer = document.querySelector('.history-slider-container'); // Use querySelector
        if (!button || !sliderContainer) return;
        const isActive = AppState.showDeviceHistory;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-pressed', isActive.toString());

        // --- Simplified Visibility Toggle ---
        sliderContainer.classList.toggle('visible', isActive);
        // --- End Simplification ---

        // console.log(`[UI Update] Show History Button Active: ${isActive}, Slider Visible: ${isActive}`); // Debug log
    },

    updateHistorySliderLabel: function () {
        const label = document.getElementById('history-slider-label');
        const slider = document.getElementById("history-slider"); // Get slider element
        const hours = AppState.historyTimeFilterHours;

        // *** ADD THIS LINE: Update slider visual position ***
        if (slider) slider.value = parseInt(hours, 10);
        // *** END ADDED LINE ***

        if (label) {
            if (hours < 24) { label.textContent = `Last ${hours}h`; }
            else if (hours === 24) { label.textContent = `Last 24h`; }
            else { label.textContent = `Last ${(hours / 24).toFixed(0)}d`; }
        }
    },

    setTheme: function (themePreference) {
        // DELEGATE all theme application logic to AppTheme
        console.log("[UI] Setting theme preference via AppTheme:", themePreference);
        AppState.currentTheme = themePreference; // Update state
        localStorage.setItem('theme', themePreference); // Save preference
        AppTheme.applyTheme(AppState.userColor, themePreference); // Apply with current color

        // Update UI elements (radio buttons) if needed - AppTheme.initialize might cover this
        document.querySelectorAll('input[name="theme"]').forEach(radio => {
            radio.checked = (radio.value === AppState.currentTheme);
        });
    },

    setupSettingsPage: function () {
        const versionElement = document.getElementById('app-version');
        if (versionElement) versionElement.textContent = `Version ${AppConfig.APP_VERSION}`;

        // Theme controls (Ensure AppTheme is initialized before this runs in app.js)
        const colorPicker = document.getElementById('theme-color-picker');
        if (colorPicker) colorPicker.value = AppState.userColor;
        document.querySelectorAll('input[name="theme"]').forEach(radio => {
            radio.checked = (radio.value === AppState.currentTheme);
        });

        // Setting Toggles
        const historyToggle = document.getElementById('location-history-toggle');
        if (historyToggle) historyToggle.checked = AppState.locationHistoryEnabled;
        const showAllToggle = document.getElementById('show-all-default-toggle');
        if (showAllToggle) showAllToggle.checked = AppState.isShowingAllDevices;
        const showHistoryToggle = document.getElementById('show-history-default-toggle');
        if (showHistoryToggle) showHistoryToggle.checked = AppState.showDeviceHistory;

        // Notification Controls
        AppNotifications.updateNotificationButtonState(); // Update button states based on current permissions/subscription

        // --- Setup device file upload listeners ---
        const deviceFileInput = document.getElementById('device-file-input');
        // Remove the initial button reference from here:
        // const deviceUploadButton = document.getElementById('upload-file-button');
        const deviceFileListDisplay = document.getElementById('selected-files-list');
        const uploadButtonInitialRef = document.getElementById('upload-file-button'); // Get initial ref for replacement logic

        // Clear any existing file selections on setup
        if (deviceFileInput) deviceFileInput.value = '';
        if (deviceFileListDisplay) deviceFileListDisplay.innerHTML = '';
        if (uploadButtonInitialRef) uploadButtonInitialRef.disabled = true; // Disable initially

        // Listener for the *hidden* device file input change
        deviceFileInput?.addEventListener('change', () => {
            console.log("[UI] Device file input changed.");
            // Get CURRENT references inside the listener
            const currentUploadButton = document.getElementById('upload-file-button');
            const currentFileListDisplay = document.getElementById('selected-files-list'); // Also get fresh ref here just in case

            if (!currentFileListDisplay || !currentUploadButton) {
                console.error("Upload button or file list display not found in DOM inside change listener!");
                return;
            }

            currentFileListDisplay.innerHTML = ''; // Clear previous list

            if (deviceFileInput.files.length > 0) {
                const list = document.createElement('ul');
                Array.from(deviceFileInput.files).forEach(file => {
                    const item = document.createElement('li');
                    item.textContent = file.name;
                    list.appendChild(item);
                });
                currentFileListDisplay.appendChild(list);
                currentUploadButton.disabled = false; // <<< Enable the *current* button
                console.log("[UI] Upload button enabled.");
            } else {
                currentUploadButton.disabled = true; // <<< Disable the *current* button
                console.log("[UI] Upload button disabled (no files).");
            }
        });

        // Listener for the *visible* device upload button click
        // Clone and replace to ensure previous listeners are removed
        if (uploadButtonInitialRef) {
            const newUploadButton = uploadButtonInitialRef.cloneNode(true);
            newUploadButton.addEventListener('click', async () => {
                console.log("[UI] Device upload button clicked.");
                if (!deviceFileInput?.files || deviceFileInput.files.length === 0) return;
                const formData = new FormData();
                Array.from(deviceFileInput.files).forEach(file => formData.append('device_file', file));

                newUploadButton.disabled = true;
                newUploadButton.innerHTML = `<div class="spinner" style="width:18px;height:18px;border-width:2px;margin:0 auto;"></div> Uploading...`;
                const statusEl = document.getElementById('upload-status');
                if (statusEl) { statusEl.textContent = 'Uploading...'; statusEl.style.color = 'inherit'; }

                try {
                    // Use AppApi._fetch directly as it handles FormData and CSRF
                    const result = await AppApi._fetch('/api/files/upload', {
                        method: 'POST',
                        body: formData
                        // No Content-Type header needed for FormData
                    });

                    console.log("[UI] Device upload API result:", result);
                    if (statusEl) {
                        statusEl.textContent = result.message || 'Upload complete.';
                        const hasErrors = result.details?.errors?.length > 0;
                        const hasSuccess = result.details?.success?.length > 0;
                        if (hasErrors && !hasSuccess) statusEl.style.color = 'var(--m3-sys-color-error)';
                        else if (hasErrors && hasSuccess) statusEl.style.color = 'var(--m3-sys-color-secondary)';
                        else statusEl.style.color = 'var(--m3-sys-color-primary)';
                    }

                    // Trigger refresh AFTER successful upload or partial success
                    if (result.details?.success?.length > 0) {
                        AppUI.showConfirmationDialog("Upload Complete", result.message || "Files processed.", async () => {
                            // Refresh only after user clicks OK on confirmation
                            await AppActions.refreshDevices();
                        });
                    } else if (result.details?.errors?.length > 0) {
                        // If only errors, show error dialog instead
                        AppUI.showErrorDialog("Upload Failed", result.message || "Some files failed to upload.");
                        await AppActions.refreshDevices(); // Still refresh to show unchanged state
                    }


                    if (deviceFileInput) deviceFileInput.value = ''; // Clear file input after upload attempt
                    if (deviceFileListDisplay) deviceFileListDisplay.innerHTML = ''; // Clear list display
                    // Keep button disabled after upload attempt until new files are selected
                    newUploadButton.disabled = true;
                    newUploadButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">upload_file</span> Upload Selected Files`;

                } catch (error) {
                    console.error('[UI] Device upload failed:', error);
                    if (statusEl) { statusEl.textContent = `Upload failed: ${error.message}`; statusEl.style.color = 'var(--m3-sys-color-error)'; }
                    AppUI.showErrorDialog("Upload Failed", `Could not upload files.<br>Details: ${error.message}`);
                    newUploadButton.disabled = false; // Re-enable on failure to allow retry with same files? Or keep disabled? User preference. Let's keep disabled until new selection.
                    newUploadButton.disabled = true;
                    newUploadButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">upload_file</span> Upload Selected Files`;
                }
            });
            uploadButtonInitialRef.parentNode.replaceChild(newUploadButton, uploadButtonInitialRef);
        }
        // --- End device file upload setup ---

        // --- Setup config import listeners ---
        const importFileInput = document.getElementById('import-config-file-input');
        const importSelectButtonLabel = document.getElementById('select-import-file-button-label');

        // Listener for the *hidden* config import file input change
        // Clone and replace to avoid duplicate listeners if setupSettingsPage is called multiple times
        if (importFileInput) {
            const newImportFileInput = importFileInput.cloneNode(true);
            newImportFileInput.addEventListener('change', (e) => {
                console.log("[UI] Config import file input changed - Calling AppActions.");
                const file = e.target.files[0];
                if (file) {
                    AppActions.handleImportFileSelected(file); // Call ACTION function
                } else {
                    AppUI.resetImportDialog();
                }
            });
            importFileInput.parentNode.replaceChild(newImportFileInput, importFileInput);
        }

        // Listener for the confirm button (also clone/replace)
        const confirmImportButton = document.getElementById('confirm-import-button');
        if (confirmImportButton) {
            const newConfirmButton = confirmImportButton.cloneNode(true);
            newConfirmButton.addEventListener('click', AppActions.handleImportConfirm);
            confirmImportButton.parentNode.replaceChild(newConfirmButton, confirmImportButton);
        }
        // --- End config import setup ---

        // Ensure Test Notification button listener is updated
        const testButton = document.getElementById('test-notification-button');
        if (testButton) {
            const newTestButton = testButton.cloneNode(true);
            // Ensure it calls the handler correctly, passing the type
            newTestButton.addEventListener('click', () => AppNotifications.handleTestNotification('test'));
            testButton.parentNode.replaceChild(newTestButton, testButton);
        }
    },


    // --- Action Handlers ---
    handleDeviceVisibilityToggle: function (checkbox) {
        const id = checkbox.dataset.deviceId; const isVisible = checkbox.checked; console.log(`[UI] Visibility toggle changed for ${id}: ${isVisible}`);
        AppState.setDeviceVisibility(id, isVisible); this.saveDeviceVisibilityWithDebounce();
        if (document.getElementById('index-page').style.display !== 'none') { AppMap.updateMapView(); }
        const editDialogToggle = document.getElementById('edit-device-visibility');
        const editDialogOverlay = document.getElementById('edit-device-dialog-overlay');
        if (editDialogOverlay?.classList.contains('show') && document.getElementById('edit-device-id')?.value === id) {
            if (editDialogToggle) editDialogToggle.checked = isVisible;
        }
    },

    _saveVisibilityDebounced: null,
    saveDeviceVisibilityWithDebounce: function () {
        if (!this._saveVisibilityDebounced) { this._saveVisibilityDebounced = AppUtils.debounce(() => { AppState.saveDeviceVisibilityState(); console.log("[UI] Debounced: Saved device visibility state."); }, AppConfig.SAVE_VISIBILITY_DEBOUNCE); }
        this._saveVisibilityDebounced();
    },

    openAddPlaceDialog: function () {
        document.getElementById('new-place-name').value = ''; document.getElementById('new-place-description').value = ''; document.getElementById('new-place-lat').value = ''; document.getElementById('new-place-lng').value = '';
        document.getElementById('place-picker-search-input').value = ''; document.getElementById('place-picker-search-error').style.display = 'none';
        this.openDialog('add-place-dialog'); // Map init handled in openDialog
    },

    handleAddPlaceSubmit: function () {
        const name = document.getElementById('new-place-name').value.trim(); const desc = document.getElementById('new-place-description').value.trim();
        const lat = parseFloat(document.getElementById('new-place-lat').value); const lng = parseFloat(document.getElementById('new-place-lng').value);
        if (!name) { this.showErrorDialog("Input Required", "Please enter a name for the place."); return; }
        if (isNaN(lat) || isNaN(lng)) { this.showErrorDialog("Location Required", "Please select a location on the map."); return; }
        const newPlace = { name, description: desc, lat, lng, id: `place_${Date.now()}` }; AppState.savedPlaces.push(newPlace); AppState.saveSavedPlaces();
        console.log("[UI] Added place:", newPlace);
        if (document.getElementById('places-page').style.display !== 'none') { this.renderSavedPlacesList(); }
        AppMap.renderSavedPlaceMarkers(); if (document.getElementById('index-page').style.display !== 'none') { AppMap.updateMapView(); }
        this.showConfirmationDialog("Place Saved", `"${name}" has been saved.`); this.closeDialog('add-place-dialog');
    },

    removePlace: function (placeIndex) {
        if (placeIndex >= 0 && placeIndex < AppState.savedPlaces.length) {
            const removed = AppState.savedPlaces.splice(placeIndex, 1)[0]; console.log("[UI] Removed place:", removed.name); AppState.saveSavedPlaces();
            this.renderSavedPlacesList(); AppMap.renderSavedPlaceMarkers(); if (document.getElementById('index-page').style.display !== 'none') { AppMap.updateMapView(); }
        }
    },

    sharePlace: function (placeIndex) {
        const place = AppState.savedPlaces[placeIndex];
        if (!place) return;
        const lat = place.lat;
        const lng = place.lng;
        const name = place.name;
        const desc = place.description || '';

        // --- Construct the text for the specific place ---
        let text = `Saved Place: ${name}`;
        if (desc) {
            text += `\nDescription: ${desc}`;
        }
        if (lat != null && lng != null) {
            text += `\nLocation: ${lat.toFixed(5)}, ${lng.toFixed(5)}`;
            text += `\nMap: https://www.openstreetmap.org/?mlat=${lat}&mlon=${lng}#map=16/${lat}/${lng}`;
            text += `\nGoogle Maps: https://www.google.com/maps?q=${lat},${lng}`;
        } else {
            text += `\n(Location not available)`;
        }

        // --- Populate the dialog textarea ---
        const ta = document.getElementById('share-location-textarea');
        const p = document.getElementById('share-location-dialog-content')?.querySelector('p');
        if (ta) {
            ta.value = text;
            console.log("[UI] Populated share dialog with place details:", name);
        }
        if (p) {
            p.textContent = `Copy text to share "${name}":`;
        }

        // --- Open the dialog ---
        this.openDialog('share-location-dialog');

        // --- Select text after dialog is likely visible ---
        setTimeout(() => {
            if (ta) {
                ta.select();
                ta.setSelectionRange(0, 99999); // For mobile
            }
        }, 100); // Small delay
    },

    // --- Search Results ---
    _createSearchResultItem: function (item) {
        const element = document.createElement('div'); element.classList.add('search-result-item'); element.setAttribute('tabindex', '0'); element.setAttribute('role', 'option');
        element.dataset.type = item.type; if (item.id) element.dataset.id = item.id; if (item.target) element.dataset.target = item.target;
        if (item.query) element.dataset.query = item.query; if (item.lat) element.dataset.lat = item.lat; if (item.lng) element.dataset.lng = item.lng;
        if (item.placeIndex !== undefined) element.dataset.placeIndex = item.placeIndex; if (item.section) element.dataset.section = item.section;
        let iconHtml = `<span class="material-icons search-result-icon">${item.icon || 'search'}</span>`;
        if (item.type === 'device' && item.svg_icon) { iconHtml = `<span class="search-result-icon" style="display:flex; align-items:center; justify-content:center; width:24px; height:24px;">${item.svg_icon.replace(/width="\d+"/, 'width="24"').replace(/height="\d+"/, 'height="24"')}</span>`; }
        element.innerHTML = `${iconHtml}<div class="search-result-text"><div class="search-result-title">${item.name || 'Unknown'}</div><div class="search-result-description">${item.description || ''}</div></div>`;
        element.addEventListener('click', this.handleSearchResultClick.bind(this)); element.addEventListener('keypress', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.handleSearchResultClick(e); } });
        return element;
    },

    renderSearchResults: function (results, containerId) {
        const container = document.getElementById(containerId); if (!container) return; container.innerHTML = '';
        if (!results || results.length === 0) { container.innerHTML = '<div class="search-result-item no-results">No results found</div>'; return; }

        let filteredResults = results;
        const isDialogSearch = containerId !== 'search-results-container';
        if (isDialogSearch) { filteredResults = results.filter(item => item.type === 'location'); }
        if (filteredResults.length === 0 && isDialogSearch) { container.innerHTML = '<div class="search-result-item no-results">No locations found</div>'; return; }
        if (filteredResults.length === 0 && !isDialogSearch) { container.innerHTML = '<div class="search-result-item no-results">No results found</div>'; return; }

        if (!isDialogSearch) {
            const groupedResults = filteredResults.reduce((acc, item) => { const category = item.type || 'other'; if (!acc[category]) acc[category] = []; acc[category].push(item); return acc; }, {});
            const categoryOrder = ['location', 'device', 'place', 'geofence', 'action']; const categoryNames = { location: 'Locations', device: 'Devices', place: 'Saved Places', geofence: 'Geofences', action: 'App Actions' };
            categoryOrder.forEach(category => {
                if (groupedResults[category]) {
                    const categoryHeader = document.createElement('div'); categoryHeader.className = 'search-result-category'; categoryHeader.textContent = categoryNames[category] || category.charAt(0).toUpperCase() + category.slice(1); container.appendChild(categoryHeader);
                    groupedResults[category].forEach(item => { container.appendChild(this._createSearchResultItem(item)); });
                }
            });
            Object.keys(groupedResults).forEach(category => { if (!categoryOrder.includes(category)) { groupedResults[category].forEach(item => container.appendChild(this._createSearchResultItem(item))); } });
        } else {
            filteredResults.forEach(item => { container.appendChild(this._createSearchResultItem(item)); });
        }
    },

    showSearchResults: function (containerId = 'search-results-container') {
        const container = document.getElementById(containerId); if (container) container.classList.add('show');
    },

    hideSearchResults: function (containerId = 'search-results-container') {
        const container = document.getElementById(containerId); if (container) container.classList.remove('show');
    },

    handleSearchResultClick: function (event) {
        const itemElement = event.currentTarget; const type = itemElement.dataset.type; const id = itemElement.dataset.id; const target = itemElement.dataset.target;
        const query = itemElement.dataset.query; const lat = parseFloat(itemElement.dataset.lat); const lng = parseFloat(itemElement.dataset.lng);
        const placeIndex = parseInt(itemElement.dataset.placeIndex, 10); const section = itemElement.dataset.section;
        const sourceDialogId = itemElement.closest('.dialog')?.id;

        console.log(`[UI] Search result clicked: Type=${type}, ID=${id}, Target=${target}, Query=${query}, Section=${section}, SourceDialog=${sourceDialogId}`);
        const resultsContainerId = itemElement.closest('.search-results-container')?.id; if (resultsContainerId) { this.hideSearchResults(resultsContainerId); }
        const searchInputId = sourceDialogId ? (sourceDialogId === 'add-place-dialog' ? 'place-picker-search-input' : 'geofence-picker-search-input') : 'location-search-input';
        const searchInput = document.getElementById(searchInputId); if (searchInput) searchInput.value = '';

        try {
            switch (type) {
                case 'location':
                    if (sourceDialogId === 'add-place-dialog' && !isNaN(lat) && !isNaN(lng)) {
                        const mapState = AppState.placePickerDialog;
                        if (mapState.map) mapState.map.setView([lat, lng], 15);
                        if (mapState.marker) mapState.marker.setLatLng([lat, lng]);
                        document.getElementById('new-place-lat').value = lat.toFixed(5);
                        document.getElementById('new-place-lng').value = lng.toFixed(5);
                        if (searchInput) searchInput.value = itemElement.querySelector('.search-result-description')?.textContent || query || '';
                    } else if (sourceDialogId === 'geofence-dialog' && !isNaN(lat) && !isNaN(lng)) {
                        const mapState = AppState.geofenceDialog;
                        if (mapState.map) mapState.map.setView([lat, lng], 15);
                        if (mapState.marker) mapState.marker.setLatLng([lat, lng]);
                        if (mapState.circle) mapState.circle.setLatLng([lat, lng]);
                        document.getElementById('geofence-lat').value = lat.toFixed(5);
                        document.getElementById('geofence-lng').value = lng.toFixed(5);
                        if (searchInput) searchInput.value = itemElement.querySelector('.search-result-description')?.textContent || query || '';
                    } else if (!sourceDialogId && query) { AppMap.geocodeAddress(query, true); }
                    else if (!sourceDialogId && !isNaN(lat) && !isNaN(lng)) { this.changePage('index'); setTimeout(() => { AppMap.addSearchMarker(lat, lng, itemElement.querySelector('.search-result-description')?.textContent || 'Selected Location'); AppMap.updateMapView(); }, 50); }
                    else { console.warn("[UI] Unhandled location click scenario:", sourceDialogId, query, lat, lng); }
                    break;
                case 'device': AppMap.viewDeviceOnMap(id); break;
                case 'place': if (!isNaN(placeIndex)) { AppMap.viewPlaceOnMap(placeIndex); } else { console.warn("[UI] Place index missing"); } break;
                case 'geofence': AppMap.viewGeofenceOnMap(id); break;
                case 'action':
                    if (target === 'manage_apple_creds') { window.location.href = '/manage_apple_creds'; }
                    else if (target.startsWith('dialog:')) { this.openDialog(target.substring(7)); }
                    else { this.changePage(target, section); }
                    break;
                default: console.warn("[UI] Unknown search result type:", type);
            }
        } catch (error) { console.error("[UI] Error handling search result action:", error); this.showErrorDialog("Action Failed", `Could not perform action. Error: ${error.message}`); }
        if (searchInput) searchInput.blur();
    },

    copyShareLocationText: async function () { // Keep the improved version from previous step
        const ta = document.getElementById('share-location-textarea');
        const copyButton = document.getElementById('copy-share-button');
        if (!ta || !copyButton) return;

        ta.select();
        ta.setSelectionRange(0, 99999);

        const originalButtonText = copyButton.textContent;
        copyButton.textContent = 'Copying...';
        copyButton.disabled = true;

        let success = false;
        let errorMessage = "Could not copy automatically.";

        if (navigator.clipboard && window.isSecureContext) {
            console.log('[UI] Attempting copy via Clipboard API...');
            try {
                await navigator.clipboard.writeText(ta.value);
                console.log('[UI] Copied via Clipboard API');
                success = true;
            } catch (err) {
                console.error('[UI] Clipboard API failed:', err);
                errorMessage = `Clipboard API Error: ${err.message}. Please copy manually.`;
            }
        } else {
            if (!window.isSecureContext) { console.warn('[UI] Clipboard API skipped: Page is not secure (HTTPS).'); errorMessage = "Copy failed: Page is not secure (HTTPS). Please copy manually."; }
            else { console.warn('[UI] Clipboard API not available.'); errorMessage = "Clipboard API unavailable. Trying fallback..."; }
        }

        if (!success) {
            console.log('[UI] Attempting copy via document.execCommand...');
            try {
                ta.focus();
                if (document.execCommand('copy')) {
                    console.log('[UI] Copied via execCommand fallback');
                    success = true;
                } else {
                    console.warn('[UI] execCommand returned false.');
                    errorMessage = "Fallback copy command failed. Please copy manually.";
                }
            } catch (execErr) {
                console.error('[UI] Fallback execCommand failed:', execErr);
                errorMessage = `Fallback copy error: ${execErr.message}. Please copy manually.`;
            }
            ta.blur();
        }

        copyButton.disabled = false;
        if (success) {
            copyButton.textContent = 'Copied!';
            this.showConfirmationDialog("Copied!", "Location text copied to clipboard.");
            setTimeout(() => {
                this.closeDialog('share-location-dialog');
                copyButton.textContent = originalButtonText;
            }, 1000);
        } else {
            copyButton.textContent = 'Failed!';
            this.showErrorDialog("Copy Failed", errorMessage);
            setTimeout(() => {
                copyButton.textContent = originalButtonText;
            }, 2000);
        }
    },

    openEditDeviceDialog: function (deviceId) {
        const device = AppState.getDeviceDisplayInfo(deviceId); if (!device) { this.showErrorDialog("Error", "Device data not found."); return; }
        document.getElementById('edit-device-id').value = deviceId; document.getElementById('edit-device-name').value = device.name === deviceId ? '' : device.name;
        document.getElementById('edit-device-name').placeholder = device.name; document.getElementById('edit-device-label').value = device.label === '❓' ? '' : device.label;
        document.getElementById('edit-device-color').value = device.color || AppUtils.getDefaultColorForId(deviceId); document.getElementById('edit-device-dialog-title').textContent = `Edit "${device.name}"`;
        const visibilityToggle = document.getElementById('edit-device-visibility'); const newVisibilityToggle = visibilityToggle.cloneNode(true); newVisibilityToggle.checked = device.isVisible;
        newVisibilityToggle.addEventListener('change', (e) => { const currentId = document.getElementById('edit-device-id').value; AppState.setDeviceVisibility(currentId, e.target.checked); this.saveDeviceVisibilityWithDebounce(); if (document.getElementById('index-page').style.display !== 'none') { AppMap.updateMapView(); } const listToggle = document.querySelector(`.device-visibility-toggle input[data-device-id="${currentId}"]`); if (listToggle) listToggle.checked = e.target.checked; });
        visibilityToggle.parentNode.replaceChild(newVisibilityToggle, visibilityToggle);
        const saveButton = document.getElementById('save-device-edit-button'); const newSaveButton = saveButton.cloneNode(true); newSaveButton.addEventListener('click', AppActions.handleEditDeviceSubmit); saveButton.parentNode.replaceChild(newSaveButton, saveButton);
        this.openDialog('edit-device-dialog');
    },

    openAddGlobalGeofenceDialog: function () {
        document.getElementById('geofence-dialog-title').textContent = 'Add Global Geofence'; document.getElementById('geofence-edit-id').value = ''; document.getElementById('geofence-name').value = ''; document.getElementById('geofence-radius').value = '100'; document.getElementById('geofence-lat').value = ''; document.getElementById('geofence-lng').value = ''; document.getElementById('geofence-picker-search-input').value = ''; document.getElementById('geofence-picker-search-error').style.display = 'none'; document.getElementById('geofence-picker-search-results').innerHTML = ''; document.getElementById('geofence-picker-search-results').classList.remove('show');
        const saveButton = document.getElementById('geofence-dialog-save-button'); const newSaveButton = saveButton.cloneNode(true); newSaveButton.addEventListener('click', AppActions.handleGeofenceDialogSubmit); saveButton.parentNode.replaceChild(newSaveButton, saveButton);
        this.openDialog('geofence-dialog');
    },

    openEditGlobalGeofenceDialog: function (geofenceId) {
        const geofence = AppState.globalGeofenceData.find(gf => gf.id === geofenceId); if (!geofence) { this.showErrorDialog("Error", "Geofence not found."); return; }
        document.getElementById('geofence-dialog-title').textContent = `Edit Geofence "${geofence.name}"`; document.getElementById('geofence-edit-id').value = geofence.id; document.getElementById('geofence-name').value = geofence.name; document.getElementById('geofence-radius').value = geofence.radius; document.getElementById('geofence-lat').value = geofence.lat.toFixed(5); document.getElementById('geofence-lng').value = geofence.lng.toFixed(5); document.getElementById('geofence-picker-search-input').value = ''; document.getElementById('geofence-picker-search-error').style.display = 'none'; document.getElementById('geofence-picker-search-results').innerHTML = ''; document.getElementById('geofence-picker-search-results').classList.remove('show');
        const saveButton = document.getElementById('geofence-dialog-save-button'); const newSaveButton = saveButton.cloneNode(true); newSaveButton.addEventListener('click', AppActions.handleGeofenceDialogSubmit); saveButton.parentNode.replaceChild(newSaveButton, saveButton);
        this.openDialog('geofence-dialog');
    },

    // --- Map View Toggles ---
    toggleShowAllDevices: function () {
        AppState.isShowingAllDevices = !AppState.isShowingAllDevices; console.log("[UI] Toggled Show All:", AppState.isShowingAllDevices);
        if (AppState.isShowingAllDevices) { AppState.currentViewedDeviceId = null; AppMap.clearSearchMarker(); const searchInput = document.getElementById('location-search-input'); if (searchInput) searchInput.value = ''; }
        this.updateShowAllButtonState(); AppMap.updateMapView(); AppState.saveMapToggles();
    },

    toggleShowHistory: function () {
        AppState.showDeviceHistory = !AppState.showDeviceHistory; console.log("[UI] Toggled Show History:", AppState.showDeviceHistory);
        this.updateShowHistoryButtonState(); AppMap.updateHistoryLayersVisibility(); AppState.saveMapToggles();
    },

    // --- Dialog Search Setup ---
    setupDialogSearch: function (dialogId) {
        let searchInputId, resultsContainerId;
        if (dialogId === 'add-place-dialog') {
            searchInputId = 'place-picker-search-input';
            resultsContainerId = 'place-picker-search-results';
        } else if (dialogId === 'geofence-dialog') {
            searchInputId = 'geofence-picker-search-input';
            resultsContainerId = 'geofence-picker-search-results';
        } else {
            console.error(`[UI] Cannot setup dialog search for unknown dialog ID: ${dialogId}`); return;
        }
        console.log(`[UI] Setting up dialog search for ${dialogId}: Input='${searchInputId}', Results='${resultsContainerId}'`);
        const searchInput = document.getElementById(searchInputId); const resultsContainer = document.getElementById(resultsContainerId);
        if (!searchInput) { console.error(`[UI] Search input #${searchInputId} not found for dialog ${dialogId}`); return; }
        if (!resultsContainer) { console.error(`[UI] Search results container #${resultsContainerId} not found for dialog ${dialogId}`); return; }
        if (!searchInput._debouncedSearchHandler) { searchInput._debouncedSearchHandler = AppUtils.debounce((query, containerId) => this.performDialogSearch(query, containerId), 350); }
        searchInput._handleInput = (event) => this.handleDialogSearchInput(event, resultsContainerId);
        searchInput._handleFocus = (event) => this.handleDialogSearchInput(event, resultsContainerId); // Also search on focus if input has value
        searchInput._handleBlur = (event) => this.handleDialogSearchBlur(event, resultsContainerId);
        searchInput._handleKeypress = (event) => this.handleDialogSearchKeypress(event, resultsContainerId);
        searchInput.addEventListener('input', searchInput._handleInput);
        searchInput.addEventListener('focus', searchInput._handleFocus);
        searchInput.addEventListener('blur', searchInput._handleBlur);
        searchInput.addEventListener('keypress', searchInput._handleKeypress); // Add keypress for Enter
        console.log(`[UI] Dialog search listeners setup for ${searchInputId}`);
    },

    cleanupDialogSearch: function (dialogId) {
        let searchInputId;
        if (dialogId === 'add-place-dialog') { searchInputId = 'place-picker-search-input'; }
        else if (dialogId === 'geofence-dialog') { searchInputId = 'geofence-picker-search-input'; }
        else { console.warn(`[UI] Cannot cleanup dialog search for unknown dialog ID: ${dialogId}`); return; }
        const searchInput = document.getElementById(searchInputId); if (!searchInput) return;
        console.log(`[UI] Cleaning up dialog search listeners for ${searchInputId}`); // Added log
        if (searchInput._handleInput) searchInput.removeEventListener('input', searchInput._handleInput);
        if (searchInput._handleFocus) searchInput.removeEventListener('focus', searchInput._handleFocus);
        if (searchInput._handleBlur) searchInput.removeEventListener('blur', searchInput._handleBlur);
        if (searchInput._handleKeypress) searchInput.removeEventListener('keypress', searchInput._handleKeypress);
        delete searchInput._handleInput; delete searchInput._handleFocus; delete searchInput._handleBlur; delete searchInput._handleKeypress; delete searchInput._debouncedSearchHandler;
    },

    handleDialogSearchInput: function (event, resultsContainerId) {
        const query = event.target.value.trim();
        if (query.length < 2) { AppUI.hideSearchResults(resultsContainerId); }
        else { if (event.target._debouncedSearchHandler) { event.target._debouncedSearchHandler(query, resultsContainerId); } }
    },

    handleDialogSearchKeypress: function (event, resultsContainerId) {
        if (event.key === 'Enter') {
            event.preventDefault(); // Prevent form submission if any
            const resultsContainer = document.getElementById(resultsContainerId);
            const firstResult = resultsContainer?.querySelector('.search-result-item:not(.no-results)');
            if (firstResult) { firstResult.click(); } // Simulate click on the first result
        }
    },

    handleDialogSearchBlur: function (event, resultsContainerId) {
        setTimeout(() => {
            const focusedElement = document.activeElement; const searchInput = event.target; const resultsContainer = document.getElementById(resultsContainerId); const dialog = searchInput.closest('.dialog');
            if (!dialog || !dialog.contains(focusedElement) || !focusedElement?.closest('.dialog-search-results, .dialog-search-bar')) { AppUI.hideSearchResults(resultsContainerId); }
        }, 200);
    },

    performDialogSearch: async function (query, resultsContainerId) {
        const resultsContainer = document.getElementById(resultsContainerId);
        if (!resultsContainer || query.length < 2) { this.hideSearchResults(resultsContainerId); return; }
        console.log(`[UI] Dialog search for '${query}' in ${resultsContainerId}`);
        resultsContainer.innerHTML = '<div class="search-result-item"><div class="spinner" style="width:18px; height:18px; border-width:2px; margin-right:8px;"></div>Searching...</div>';
        this.showSearchResults(resultsContainerId);
        try {
            const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(query)}&limit=5`;
            const response = await fetch(url, { headers: { 'User-Agent': `FindMyWebApp/${AppConfig.APP_VERSION}` } });
            if (!response.ok) { throw new Error(`Nominatim search failed: ${response.status}`); }
            const nominatimData = await response.json();
            const results = nominatimData.map(loc => ({ type: 'location', query: loc.display_name, name: loc.display_name.split(',')[0], description: loc.display_name, icon: 'travel_explore', lat: parseFloat(loc.lat), lng: parseFloat(loc.lon) }));
            this.renderSearchResults(results, resultsContainerId);
        } catch (error) { console.error(`[UI] Dialog search error for '${query}':`, error); resultsContainer.innerHTML = `<div class="search-result-item no-results">Search failed: ${error.message}</div>`; }
    },

    // --- Import/Export UI Handlers (Modified) ---
    // This function now *only* updates the UI with the file name.
    // The processing logic is moved to AppActions.handleImportFileSelected.
    handleImportFileSelection: function (event) {
        console.log("[UI] Handling import file selection change (UI update only).");
        const fileInput = event.target;
        const selectedFileList = document.getElementById('selected-import-file-list');
        const confirmButton = document.getElementById('confirm-import-button');
        const partsSelection = document.getElementById('import-parts-selection');
        const statusMessage = document.getElementById('import-status-message');

        // Reset UI elements first
        if (selectedFileList) selectedFileList.textContent = '';
        if (partsSelection) partsSelection.style.display = 'none';
        if (confirmButton) confirmButton.style.display = 'none';
        if (statusMessage) statusMessage.textContent = '';

        if (fileInput.files && fileInput.files.length > 0) {
            const file = fileInput.files[0];
            if (selectedFileList) selectedFileList.textContent = `Selected: ${file.name}`;
            // --- The actual processing is now triggered by the event listener in setupSettingsPage ---
            // --- which calls AppActions.handleImportFileSelected(file) ---
        } else {
            console.log("[UI] No file selected, resetting import dialog UI.");
            this.resetImportDialog(); // Reset fully if selection is cleared
        }
    },


    resetImportDialog: function () {
        console.log("[UI] Resetting import dialog.");
        const fileInput = document.getElementById('import-config-file-input');
        const selectedFileList = document.getElementById('selected-import-file-list');
        const confirmButton = document.getElementById('confirm-import-button');
        const partsSelection = document.getElementById('import-parts-selection');
        const statusMessage = document.getElementById('import-status-message');

        AppState.clearImportData(); // Clear stored data

        if (fileInput) fileInput.value = ''; // Clear file input
        if (selectedFileList) selectedFileList.textContent = '';
        if (statusMessage) statusMessage.textContent = '';
        if (partsSelection) {
            partsSelection.innerHTML = '<h4 class="settings-section-title">Select Parts to Import</h4>'; // Reset content
            partsSelection.style.display = 'none';
        }
        if (confirmButton) {
            confirmButton.disabled = true;
            confirmButton.style.display = 'none'; // Hide confirm button initially
            confirmButton.innerHTML = `<span class="material-icons" style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Import Selected`; // Reset text
        }
    }
};
// --------------------
// app\static\js\utils.js
// app/static/js/utils.js

window.AppUtils = {

    /**
     * Basic HTML escaping function.
     * Replaces characters that have special meaning in HTML.
     * @param {string} unsafe String potentially containing HTML.
     * @returns {string} Escaped string.
     */
    escapeHtml: function (unsafe) {
        if (typeof unsafe !== 'string') {
            return unsafe; // Return non-strings as is
        }
        return unsafe
            .replace(/&/g, "&")
            .replace(/</g, "<")
            .replace(/>/g, ">")
            .replace(/"/g, '"')
            .replace(/'/g, "'");
    },


    /**
     * Generates a default hex color based on a string ID.
     * @param {string} id_str The input string ID.
     * @returns {string} A hex color string (e.g., "#aabbcc").
     */
    getDefaultColorForId: function (id_str) {
        if (!id_str || id_str.length === 0) return '#70757a';
        let hash = 0;
        for (let i = 0; i < id_str.length; i++) {
            hash = id_str.charCodeAt(i) + ((hash << 5) - hash);
            hash &= hash; // Convert to 32bit integer
        }
        hash = Math.abs(hash);
        const r = (hash & 0xFF0000) >> 16;
        const g = (hash & 0x00FF00) >> 8;
        const b = hash & 0x0000FF;
        const avg = (r + g + b) / 3;
        const factor = 0.6; // Brightness adjustment factor
        const nr = Math.min(255, Math.max(0, r + (128 - avg) * factor));
        const ng = Math.min(255, Math.max(0, g + (128 - avg) * factor));
        const nb = Math.min(255, Math.max(0, b + (128 - avg) * factor));
        return `#${Math.round(nr).toString(16).padStart(2, '0')}${Math.round(ng).toString(16).padStart(2, '0')}${Math.round(nb).toString(16).padStart(2, '0')}`;
    },

    /**
     * Formats a Date object into a localized string.
     * @param {Date} date The Date object.
     * @returns {string} Formatted date/time string or "Invalid date".
     */
    formatTime: function (date) {
        if (!date || !(date instanceof Date) || isNaN(date)) return "Invalid date";
        try {
            return new Intl.DateTimeFormat(navigator.language || 'en-US', {
                dateStyle: 'medium',
                timeStyle: 'short'
            }).format(date);
        } catch (e) { // Fallback for very old browsers
            const h = date.getHours(); const m = date.getMinutes(); const ampm = h >= 12 ? 'PM' : 'AM';
            const fh = h % 12 || 12; const mo = date.getMonth() + 1; const d = date.getDate(); const y = date.getFullYear();
            return `${mo}/${d}/${y}, ${fh}:${m < 10 ? '0' + m : m} ${ampm}`;
        }
    },

    /**
     * Formats a Date object into a relative time string (e.g., "5 min ago").
     * @param {Date} date The Date object.
     * @returns {string} Relative time string or absolute time if older than a week.
     */
    formatTimeRelative: function (date) {
        if (!date || !(date instanceof Date) || isNaN(date)) return "Never";
        const now = new Date();
        const deltaSeconds = Math.round((now.getTime() - date.getTime()) / 1000);
        if (deltaSeconds < 0) return "In the future"; // Handle clock skew
        if (deltaSeconds < 5) return "Just now";
        if (deltaSeconds < 60) return `${deltaSeconds} sec ago`;

        const deltaMinutes = Math.round(deltaSeconds / 60);
        if (deltaMinutes < 60) return `${deltaMinutes} min ago`;

        const deltaHours = Math.round(deltaMinutes / 60);
        if (deltaHours < 24) return `${deltaHours} hr ago`;

        const deltaDays = Math.round(deltaHours / 24);
        if (deltaDays === 1) return "Yesterday";
        if (deltaDays < 7) return `${deltaDays} days ago`;

        // If older than a week, return absolute time
        return this.formatTime(date);
    },

    /**
    * Converts a URL-safe base64 string to a Uint8Array.
    * @param {string} base64String The URL-safe base64 string.
    * @returns {Uint8Array} The corresponding Uint8Array.
    */
    urlBase64ToUint8Array: function (base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    },

    /**
     * Basic debouncer function.
     * @param {Function} func The function to debounce.
     * @param {number} wait Delay in milliseconds.
     * @returns {Function} The debounced function.
     */
    debounce: function (func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func.apply(this, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    /**
     * Generates an SVG icon string (similar to backend).
     * Circle with colored border, white inner, dark text.
     * @param {string} label The label (max 2 chars/graphemes).
     * @param {string} color Hex color string for border.
     * @param {number} size Icon size in pixels.
     * @returns {string} SVG string.
     */
    generateDeviceIconSVG: function (label, color, size = 36) {
        const sanitizedLabel = (label || '?'); // Start with label or '?'
        let displayLabel = '?';
        // Attempt grapheme extraction if possible (basic JS doesn't have easy regex for this)
        // Simple approach: handle surrogate pairs for 2-char emojis, else take 1 char
        if (sanitizedLabel.length > 0) {
            if (sanitizedLabel.length >= 2 && 0xD800 <= sanitizedLabel.charCodeAt(0) && sanitizedLabel.charCodeAt(0) <= 0xDBFF) {
                displayLabel = sanitizedLabel.substring(0, 2).toUpperCase();
            } else {
                displayLabel = sanitizedLabel.substring(0, 1).toUpperCase(); // Default to first char
            }
        }

        const sanitizedColor = color && /^#[0-9a-fA-F]{6}$/.test(color) ? color : this.getDefaultColorForId(displayLabel); // Use default color if invalid

        const border_width = Math.max(1, Math.round(size * 0.1));
        const inner_radius = Math.max(1, Math.round(size / 2) - border_width);
        const text_size = size * (displayLabel.length === 1 ? 0.50 : 0.40); // Adjust based on actual displayed label length
        const text_y_adjust = size * 0.04; // Nudge text down slightly

        // Text color is always dark against the white inner circle
        const text_color = '#333333';

        // Basic SVG escaping
        const label_safe = displayLabel.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');

        return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" fill="${sanitizedColor}" />
                    <circle cx="${size / 2}" cy="${size / 2}" r="${inner_radius}" fill="#FFFFFF" />
                    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
                          font-family="sans-serif" font-size="${text_size}px" font-weight="bold" fill="${text_color}">
                        ${label_safe}
                    </text>
                </svg>`;
    },

    /**
     * Parses battery level and status from raw report data.
     * Mirrors the logic in Python's _parse_battery_info.
     * @param {*} batteryLevelRaw Raw battery value (number or string).
     * @param {*} rawStatusCode Raw status code.
     * @param {number} lowBatteryThreshold The threshold for 'Very Low'.
     * @returns {Array} [number|null, string] - Parsed level and status string.
     */
    _parseBatteryInfo: function (batteryLevelRaw, rawStatusCode, lowBatteryThreshold) {
        let mappedBatteryLevel = null;
        let batteryStatusStr = "Unknown";

        // Try status code first
        if (rawStatusCode !== null && rawStatusCode !== undefined) {
            const statusInt = parseInt(rawStatusCode);
            if (!isNaN(statusInt)) {
                switch (statusInt) {
                    case 0: mappedBatteryLevel = 100.0; batteryStatusStr = "Full"; break;
                    case 32: mappedBatteryLevel = 90.0; batteryStatusStr = "High"; break;
                    case 64: mappedBatteryLevel = 50.0; batteryStatusStr = "Medium"; break;
                    case 128: mappedBatteryLevel = 30.0; batteryStatusStr = "Low"; break;
                    case 192: mappedBatteryLevel = 10.0; batteryStatusStr = "Very Low"; break;
                }
            }
        }

        // If status code didn't give level, check battery field
        if (mappedBatteryLevel === null) {
            if (typeof batteryLevelRaw === 'number') {
                mappedBatteryLevel = batteryLevelRaw;
                // Status string determined later based on level
            } else if (typeof batteryLevelRaw === 'string') {
                const levelLower = batteryLevelRaw.toLowerCase();
                if (levelLower === "very low") { mappedBatteryLevel = 10.0; batteryStatusStr = "Very Low"; }
                else if (levelLower === "low") { mappedBatteryLevel = 25.0; batteryStatusStr = "Low"; }
                else if (levelLower === "medium") { mappedBatteryLevel = 50.0; batteryStatusStr = "Medium"; }
                else if (levelLower === "high") { mappedBatteryLevel = 85.0; batteryStatusStr = "High"; }
                else if (levelLower === "full") { mappedBatteryLevel = 100.0; batteryStatusStr = "Full"; }
                else {
                    batteryStatusStr = batteryLevelRaw.charAt(0).toUpperCase() + batteryLevelRaw.slice(1);
                }
            }
        }

        // Final check: Determine status string based on level
        if (mappedBatteryLevel !== null) {
            if (mappedBatteryLevel < lowBatteryThreshold) batteryStatusStr = "Very Low";
            else if (mappedBatteryLevel < 30) batteryStatusStr = "Low";
            else if (mappedBatteryLevel < 70) batteryStatusStr = "Medium";
            else if (mappedBatteryLevel < 95) batteryStatusStr = "High";
            else batteryStatusStr = "Full";
        }

        return [mappedBatteryLevel, batteryStatusStr];
    }
};
// --------------------
// app\templates\index.html
<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find My Location</title>
    <meta name="csrf-token" content="{{ csrf_token() }}"> {# Flask-WTF CSRF Token #}
    <link rel="stylesheet" id="leaflet-css" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" id="material-icons-css" href="https://fonts.googleapis.com/icon?family=Material+Icons"
        media="print" onload="this.media='all'" />
    <link rel="stylesheet" id="material-symbols-css"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
        media="print" onload="this.media='all'" />
    <noscript>
        <link rel="stylesheet" href="{{ url_for('static', filename='styles/material-icons/material-icons.css') }}">
        <link rel="stylesheet"
            href="{{ url_for('static', filename='styles/material-symbols/material-symbols-outlined.css') }}">
    </noscript>
    <style>
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: var(--m3-sys-color-surface-container-high);
            color: var(--m3-sys-color-on-surface);
            box-shadow: 0 1px 4px rgba(var(--m3-sys-color-shadow), 0.15);
            border-radius: 8px;
        }
    </style>
    <!-- <link rel="manifest" href="{{ url_for('public.manifest') }}">  -->
    <link rel="manifest" href="/public/manifest.json">
    <meta name="theme-color" content="#FFFFFF" id="meta-theme-color"> {# Default light surface #}
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='icons/apple-touch-icon.png') }}">
    <link rel="icon" href="{{ url_for('public.favicon') }}" sizes="any">
    <link rel="icon" href="{{ url_for('static', filename='icons/favicon.svg') }}" type="image/svg+xml">
    <script>
        // Pass Backend Config to Frontend
        window.VAPID_PUBLIC_KEY = '{{ VAPID_PUBLIC_KEY }}' || null;
        window.LOW_BATTERY_THRESHOLD = parseInt('{{ LOW_BATTERY_THRESHOLD }}') || 15;
        window.APP_VERSION = "{{ APP_VERSION }}";
        // Inject notification icon/badge paths
        window.DEFAULT_NOTIFICATION_ICON_URL = "{{ DEFAULT_NOTIFICATION_ICON_URL or '/static/icons/favicon.svg' }}";
        window.WELCOME_NOTIFICATION_ICON_URL = "{{ WELCOME_NOTIFICATION_ICON_URL or '/static/icons/favicon.svg' }}";
        window.GEOFENCE_BADGE_URL = "{{ GEOFENCE_BADGE_URL or '/static/icons/badge-icon.png' }}";
        window.BATTERY_BADGE_URL = "{{ BATTERY_BADGE_URL or '/static/icons/badge-icon.png' }}";
        window.TEST_ICON_BADGE_URL = "{{ TEST_ICON_BADGE_URL or '/static/icons/favicon.svg' }}";
        window.DEFAULT_BADGE_URL = "{{ DEFAULT_BADGE_URL or '/static/icons/badge-icon.png' }}";
    </script>
</head>

<body>
    <!-- Drawer Overlay & Menu -->
    <div class="drawer-overlay" id="drawer-overlay"></div>
    <aside class="drawer" id="drawer">
        <div class="drawer-header"> <span class="material-icons menu-icon" id="drawer-close-button" tabindex="0"
                role="button" aria-label="Close navigation drawer">arrow_back</span>
            <h2 class="drawer-title">Find My Location</h2>
        </div>
        <div class="drawer-content">
            <div class="drawer-item" tabindex="0" data-page="index"> <span
                    class="material-icons drawer-item-icon">map</span> <span class="drawer-item-text">Map</span> </div>
            <div class="drawer-item" tabindex="0" data-page="shared"> <span
                    class="material-icons drawer-item-icon">devices</span> <span class="drawer-item-text">My
                    Devices</span> </div>
            <div class="drawer-item" tabindex="0" data-page="geofences"> <span
                    class="material-icons drawer-item-icon">radar</span> <span class="drawer-item-text">Geofences</span>
            </div>
            <div class="drawer-item" tabindex="0" data-page="places"> <span
                    class="material-icons drawer-item-icon">star_outline</span> <span class="drawer-item-text">Saved
                    Places</span> </div>
            <div class="drawer-item" tabindex="0" data-page="history"> <span
                    class="material-icons drawer-item-icon">history</span> <span class="drawer-item-text">Location
                    History</span> </div>
            <div class="drawer-divider"></div>
            <a href="#" data-page="settings" style="text-decoration: none; color: inherit;">
                <div class="drawer-item" tabindex="0"> <span class="material-icons drawer-item-icon">settings</span>
                    <span class="drawer-item-text">Settings</span>
                </div>
            </a>
            <a href="{{ url_for('main.manage_apple_creds_route') }}" data-target="manage_apple_creds"
                style="text-decoration: none; color: inherit;">
                <div class="drawer-item" tabindex="0"> <span class="material-icons drawer-item-icon">security</span>
                    <span class="drawer-item-text">Apple Credentials</span>
                </div>
            </a>
            <div class="drawer-item" tabindex="0" data-dialog="help-dialog"> <span
                    class="material-icons drawer-item-icon">help_outline</span> <span class="drawer-item-text">Help &
                    Feedback</span> </div>
            <div class="drawer-item" tabindex="0" data-page="notifications-history"> <span
                    class="material-icons drawer-item-icon">history_toggle_off</span> <span
                    class="drawer-item-text">Notification History</span> </div>
            <div class="drawer-divider"></div>
            <a href="{{ url_for('auth.logout_route') }}" style="text-decoration: none; color: inherit;">
                <div class="drawer-item" tabindex="0"> <span class="material-icons drawer-item-icon">logout</span> <span
                        class="drawer-item-text">Logout</span> </div>
            </a>
        </div>
    </aside>

    <!-- More Menu Dialog -->
    <div class="dialog-overlay" id="more-menu-dialog-overlay">
        <div class="dialog" id="more-menu-dialog">
            <div class="dialog-content"></div>
        </div>
    </div>
    <!-- Help Dialog -->
    <div class="dialog-overlay" id="help-dialog-overlay">
        <div class="dialog" id="help-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title">Help & Feedback</h3>
            </div>
            <div class="dialog-content">
                <p>Locate accessories via <code>data/{{ username }}</code>.</p>
                <p><strong>Geofences:</strong> Create global boundaries, link to devices, set notifications.</p>
                <p><strong>Battery Alerts:</strong> Below {{ config.LOW_BATTERY_THRESHOLD }}% once per discharge.</p>
                <p><strong>Notifications:</strong> Grant permission. Test/manage in Settings.</p>
                <p><strong>Important:</strong> Secure Apple ID creds. Use App-Specific Passwords.</p>
                <p>Backend fetches periodically. Refresh on Devices page for immediate update.</p>
                <p>Feedback: Project repo/developer.</p>
            </div>
            <div class="dialog-actions"> <button class="button" data-close-dialog="help-dialog">OK</button> </div>
        </div>
    </div>
    <!-- Add Place Dialog -->
    <div class="dialog-overlay" id="add-place-dialog-overlay">
        <div class="dialog" id="add-place-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title">Add Place</h3>
            </div>
            <div class="dialog-content">
                <div class="dialog-search-bar"> <span class="material-icons dialog-search-icon">search</span> <input
                        type="text" class="dialog-search-input" id="place-picker-search-input"
                        placeholder="Search address..." enterkeyhint="search" autocomplete="off"> </div>
                <div id="place-picker-search-results" class="search-results-container dialog-search-results"
                    role="listbox" aria-label="Place Search Results"></div>
                <div id="place-picker-search-error" class="dialog-search-error"></div>
                <div id="place-picker-map" style="position: relative;">
                    <div class="map-dialog-controls">
                        <div class="map-control-button" id="place-picker-my-location" title="Center on my location"
                            tabindex="0" role="button" aria-label="Center map on my current location"><span
                                class="material-icons">my_location</span></div>
                    </div>
                </div>
                <div class="settings-section">
                    <h4 class="settings-section-title">Place Information</h4>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Place Name</div>
                            <div class="settings-item-description">Name (required)</div>
                        </div> <input type="text" id="new-place-name" placeholder="e.g., Home, Work">
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Description</div>
                            <div class="settings-item-description">Optional</div>
                        </div> <textarea id="new-place-description" placeholder="e.g., My apartment"></textarea>
                    </div>
                    <h4 class="settings-section-title" style="margin-top: 16px;">Location (Search/tap/drag)</h4>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Latitude</div>
                        </div> <input type="number" id="new-place-lat" placeholder="Latitude" readonly>
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Longitude</div>
                        </div> <input type="number" id="new-place-lng" placeholder="Longitude" readonly>
                    </div>
                </div>
            </div>
            <div class="dialog-actions"> <button class="text-button"
                    data-close-dialog="add-place-dialog">Cancel</button> <button class="button"
                    id="add-place-dialog-button">Save Place</button> </div>
        </div>
    </div>
    <!-- Edit Device Dialog -->
    <div class="dialog-overlay" id="edit-device-dialog-overlay">
        <div class="dialog" id="edit-device-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title" id="edit-device-dialog-title">Edit Device</h3>
            </div>
            <div class="dialog-content"> <input type="hidden" id="edit-device-id">
                <div class="settings-section">
                    <h4 class="settings-section-title">Display Information</h4>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Device Name</div>
                            <div class="settings-item-description">Custom name</div>
                        </div> <input type="text" id="edit-device-name" placeholder="Custom Name">
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Label (Emoji)</div>
                            <div class="settings-item-description">Map icon label</div>
                        </div> <input type="text" id="edit-device-label" placeholder="Emoji" maxlength="2">
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Color</div>
                            <div class="settings-item-description">Icon color</div>
                        </div> <input type="color" id="edit-device-color" value="#000000">
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Show on Map</div>
                            <div class="settings-item-description">Toggle visibility</div>
                        </div> <label class="toggle-switch"> <input type="checkbox" id="edit-device-visibility"> <span
                                class="toggle-slider"></span> </label>
                    </div>
                </div>
                <div class="settings-section">
                    <h4 class="settings-section-title">Geofences</h4>
                    <p style="font-size: var(--body-small-size); opacity: 0.7;">Manage links/notifications on main
                        'Geofences' page.</p>
                </div>
            </div>
            <div class="dialog-actions"> <button class="text-button"
                    data-close-dialog="edit-device-dialog">Cancel</button> <button class="button"
                    id="save-device-edit-button">Save Display Info</button> </div>
        </div>
    </div>
    <!-- Remove Confirmation Dialog -->
    <div class="dialog-overlay" id="remove-confirmation-dialog-overlay">
        <div class="dialog" id="remove-confirmation-dialog">
            <div class="dialog-header"> <span class="material-icons"
                    style="color: var(--m3-sys-color-error); font-size: 28px; margin-right: 16px;">delete_outline</span>
                <h3 class="dialog-title" id="remove-confirmation-dialog-title">Remove Item?</h3>
            </div>
            <div class="dialog-content" id="remove-confirmation-dialog-content"></div>
            <div class="dialog-actions" id="remove-confirmation-dialog-actions"> <button class="text-button"
                    data-close-dialog="remove-confirmation-dialog">Cancel</button> <button class="button"
                    id="remove-confirm-button"
                    style="background-color: var(--m3-sys-color-error); color: var(--m3-sys-color-on-error);">Remove</button>
            </div>
        </div>
    </div>
    <!-- Device Menu Dialog -->
    <div class="dialog-overlay" id="device-menu-dialog-overlay">
        <div class="dialog" id="device-menu-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title" id="device-menu-dialog-title">Device Options</h3>
            </div>
            <div class="dialog-content" id="device-menu-dialog-content"></div>
            <div class="dialog-actions"> <button class="text-button"
                    data-close-dialog="device-menu-dialog">Cancel</button> </div>
        </div>
    </div>
    <!-- Add/Edit Geofence Dialog -->
    <div class="dialog-overlay" id="geofence-dialog-overlay">
        <div class="dialog" id="geofence-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title" id="geofence-dialog-title">Add Geofence</h3>
            </div>
            <div class="dialog-content"> <input type="hidden" id="geofence-edit-id">
                <div class="dialog-search-bar"> <span class="material-icons dialog-search-icon">search</span> <input
                        type="text" class="dialog-search-input" id="geofence-picker-search-input"
                        placeholder="Search address for center..." enterkeyhint="search" autocomplete="off"> </div>
                <div id="geofence-picker-search-results" class="search-results-container dialog-search-results"
                    role="listbox" aria-label="Geofence Center Search Results"></div>
                <div id="geofence-picker-search-error" class="dialog-search-error"></div>
                <div id="geofence-picker-map" style="position: relative;">
                    <div class="map-dialog-controls">
                        <div class="map-control-button" id="geofence-picker-my-location"
                            title="Center map on my location" tabindex="0" role="button"
                            aria-label="Center map on my current location"><span
                                class="material-icons">my_location</span></div>
                    </div>
                </div>
                <div class="settings-section">
                    <h4 class="settings-section-title">Geofence Definition</h4>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Geofence Name</div>
                            <div class="settings-item-description">Unique name (required)</div>
                        </div> <input type="text" id="geofence-name" placeholder="e.g., Home, Office">
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Center Location</div>
                            <div class="settings-item-description">Search/tap/drag marker</div>
                        </div>
                        <div style="display: flex; gap: 8px; width: 100%; margin-top: 4px;"> <input type="number"
                                id="geofence-lat" placeholder="Latitude" readonly style="flex: 1;"> <input type="number"
                                id="geofence-lng" placeholder="Longitude" readonly style="flex: 1;"> </div>
                    </div>
                    <div class="settings-item">
                        <div class="settings-item-text">
                            <div class="settings-item-title">Radius (meters)</div>
                            <div class="settings-item-description">Boundary size</div>
                        </div> <input type="number" id="geofence-radius" placeholder="e.g., 100" min="10" step="10"
                            value="100">
                    </div>
                    <h4 class="settings-section-title" style="margin-top: 16px;">Notifications</h4>
                    <p style="font-size: var(--body-small-size); opacity: 0.7;">Enable entry/exit notifications when
                        linking on main Geofences page.</p>
                </div>
            </div>
            <div class="dialog-actions"> <button class="text-button" data-close-dialog="geofence-dialog">Cancel</button>
                <button class="button" id="geofence-dialog-save-button">Save Geofence</button>
            </div>
        </div>
    </div>
    <!-- Generic Error Dialog -->
    <div class="dialog-overlay" id="error-dialog-overlay">
        <div class="dialog" id="error-dialog">
            <div class="dialog-header"> <span class="material-icons"
                    style="color: var(--m3-sys-color-error); font-size: 28px; margin-right: 16px;">error_outline</span>
                <h3 class="dialog-title" id="error-dialog-title">Error</h3>
            </div>
            <div class="dialog-content" id="error-dialog-content"></div>
            <div class="dialog-actions"> <button class="button" data-close-dialog="error-dialog">OK</button> </div>
        </div>
    </div>
    <!-- Generic Confirmation Dialog -->
    <div class="dialog-overlay" id="confirmation-dialog-overlay">
        <div class="dialog" id="confirmation-dialog">
            <div class="dialog-header"> <span class="material-icons"
                    style="color: var(--m3-sys-color-primary); font-size: 28px; margin-right: 16px;">check_circle_outline</span>
                <h3 class="dialog-title" id="confirmation-dialog-title">Confirmation</h3>
            </div>
            <div class="dialog-content" id="confirmation-dialog-content"></div>
            <div class="dialog-actions" id="confirmation-dialog-actions"></div>
        </div>
    </div>

    <!-- START: New Edit Share Dialog -->
    <div class="dialog-overlay" id="edit-share-dialog-overlay">
        <div class="dialog" id="edit-share-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title" id="edit-share-dialog-title">Edit Share</h3>
            </div>
            <div class="dialog-content">
                <input type="hidden" id="edit-share-id">
                <p>Update the duration or note for the share link for <strong id="edit-share-device-name"></strong>.</p>
                <p style="font-size: var(--body-small-size); opacity: 0.7;">Current expiry: <span id="edit-share-current-expiry">Loading...</span></p>

                <div class="settings-section" style="margin-top: 16px;">
                    <h4 class="settings-section-title">New Duration</h4>
                    <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                         <select id="edit-share-duration-select" class="dialog-search-input" style="width: 100%; margin-bottom: 12px;">
                            <option value="1h">1 Hour (from now)</option>
                            <option value="6h">6 Hours (from now)</option>
                            <option value="24h" selected>24 Hours (from now)</option>
                            <option value="7d">7 Days (from now)</option>
                            <option value="30d">30 Days (from now)</option>
                            <option value="indefinite">Indefinite (Until Revoked)</option>
                        </select>
                         <p style="font-size: var(--body-small-size); opacity: 0.7;">Choosing a duration resets the timer from now.</p>
                    </div>

                    <h4 class="settings-section-title">Optional Note</h4>
                    <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                         <input type="text" id="edit-share-note-input" placeholder="e.g., Tracking my bike trip" maxlength="100" class="dialog-search-input" style="width: 100%;">
                         <p class="form-field-error" style="font-size: 11px; opacity: 0.7; margin-top: 4px;">Max 100 characters. Visible on share page.</p>
                    </div>
                </div>
                 <p id="edit-share-error" class="form-field-error" style="display: none;"></p>
            </div>
            <div class="dialog-actions">
                <button class="text-button" data-close-dialog="edit-share-dialog">Cancel</button>
                <button class="button" id="save-share-edit-button">Save Changes</button>
            </div>
        </div>
    </div>
    <!-- END: New Edit Share Dialog -->

    <!-- START: New Share Device Dialog -->
    <div class="dialog-overlay" id="share-device-dialog-overlay">
        <div class="dialog" id="share-device-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title" id="share-device-dialog-title">Share Device</h3>
            </div>
            <div class="dialog-content">
                <input type="hidden" id="share-device-id">
                <p>Create a temporary or indefinite link to share the live location of this device.</p>

                <div class="settings-section">
                    <h4 class="settings-section-title">Share Duration</h4>
                    <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                        <select id="share-duration-select" class="dialog-search-input"
                            style="width: 100%; margin-bottom: 12px;">
                            <option value="1h">1 Hour</option>
                            <option value="6h">6 Hours</option>
                            <option value="24h" selected>24 Hours (1 Day)</option>
                            <option value="7d">7 Days</option>
                            <option value="30d">30 Days</option>
                            <option value="indefinite">Indefinite (Until Revoked)</option>
                        </select>
                    </div>

                    <h4 class="settings-section-title">Optional Note</h4>
                    <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                        <input type="text" id="share-note-input" placeholder="e.g., Tracking my bike trip"
                            maxlength="100" class="dialog-search-input" style="width: 100%;">
                        <p class="form-field-error" style="font-size: 11px; opacity: 0.7; margin-top: 4px;">Max 100
                            characters. Visible on share page.</p>
                    </div>
                </div>
                <p id="share-create-error" class="form-field-error" style="display: none;"></p>
            </div>
            <div class="dialog-actions">
                <button class="text-button" data-close-dialog="share-device-dialog">Cancel</button>
                <button class="button" id="create-share-link-button">Create Share Link</button>
            </div>
        </div>
    </div>
    <!-- END: New Share Device Dialog -->

    <!-- START: New Show Share Link Dialog -->
    <div class="dialog-overlay" id="share-link-dialog-overlay">
        <div class="dialog" id="share-link-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title">Share Link Created</h3>
            </div>
            <div class="dialog-content">
                <p>Share this unique link. Anyone with the link can view the device's live location until it expires or
                    is revoked.</p>
                <textarea id="share-link-textarea" readonly
                    style="width:100%; min-height: 60px; margin-top: 16px; font-family: monospace; font-size: 14px; padding: 8px; box-sizing: border-box; border: 1px solid var(--m3-sys-color-outline-variant); border-radius: 8px; background-color: var(--m3-sys-color-surface-container); color: var(--m3-sys-color-on-surface); resize: none;"></textarea>
                <p id="share-link-expiry-info"
                    style="font-size: var(--body-small-size); opacity: 0.7; margin-top: 4px;"></p>
            </div>
            <div class="dialog-actions">
                <button class="text-button" data-close-dialog="share-link-dialog">Close</button>
                <button class="button" id="copy-share-link-button">
                    <span class="material-icons"
                        style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">content_copy</span> Copy
                    Link
                </button>
            </div>
        </div>
    </div>
    <!-- END: New Show Share Link Dialog -->











    <!-- Share Location Dialog -->
    <div class="dialog-overlay" id="share-location-dialog-overlay">
        <div class="dialog" id="share-location-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title">Share Location</h3>
            </div>
            <div class="dialog-content" id="share-location-dialog-content">
                <p>Copy text to share:</p> <textarea id="share-location-textarea" readonly
                    style="width:100%; min-height: 80px; margin-top: 16px; font-family: monospace; font-size: 14px; padding: 8px; box-sizing: border-box; border: 1px solid var(--m3-sys-color-outline-variant); border-radius: 8px; background-color: var(--m3-sys-color-surface-container); color: var(--m3-sys-color-on-surface); resize: none;"></textarea>
            </div>
            <div class="dialog-actions"> <button class="text-button"
                    data-close-dialog="share-location-dialog">Cancel</button> <button class="button"
                    id="copy-share-button">Copy</button> </div>
        </div>
    </div>
    <!-- Config Import Dialog -->
    <div class="dialog-overlay" id="config-import-dialog-overlay">
        <div class="dialog" id="config-import-dialog">
            <div class="dialog-header">
                <h3 class="dialog-title">Import Configuration</h3>
            </div>
            <div class="dialog-content">
                <p>Select a previously exported JSON configuration file. Importing will <strong>replace</strong>
                    existing data for the selected parts.</p> <input type="file" id="import-config-file-input"
                    accept=".json" class="hidden-file-input"> <label for="import-config-file-input" class="button"
                    id="select-import-file-button-label"
                    style="margin-top: 16px; display: inline-flex; align-items: center; cursor: pointer;"> <span
                        class="material-icons"
                        style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">attach_file</span> Select
                    File </label>
                <div id="selected-import-file-list" style="margin-top: 8px;"></div>
                <div id="import-parts-selection" style="display: none; margin-top: 16px;">
                    <h4 class="settings-section-title">Select Parts to Import</h4> <!-- Checkboxes added dynamically -->
                </div>
                <p id="import-status-message"
                    style="font-size: var(--body-small-size); margin-top: 8px; min-height: 1.2em;"></p>
            </div>
            <div class="dialog-actions"> <button class="text-button"
                    data-close-dialog="config-import-dialog">Cancel</button> <button class="button"
                    id="confirm-import-button" style="display: none;" disabled> <span class="material-icons"
                        style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Import Selected
                </button> </div>
        </div>
    </div>

    <!-- App Bar -->
    <header class="app-bar">
        <span class="material-icons menu-icon" id="menu-button" tabindex="0"
            aria-label="Open navigation drawer">menu</span>
        <!-- <a href="{{ url_for('auth.logout_route') }}" title="Logout" style="text-decoration: none;"> <span
                class="material-icons action-button" style="margin-left: 8px;">logout</span> </a> -->
        <div class="search-bar"> <span class="material-icons search-icon">search</span> <input type="text"
                class="search-input" placeholder="Search places, devices, actions..." id="location-search-input"
                enterkeyhint="search" autocomplete="off"> </div>
        {% if username %} <span
            style="margin-left: 16px; font-size: var(--body-medium-size); opacity: 0.8; max-width: 150px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">{{
            username }}</span> {% endif %}
        <span class="material-icons action-button" id="more-button" tabindex="0"
            aria-label="More options">more_vert</span>
        <div id="search-results-container" class="search-results-container" role="listbox" aria-label="Search Results">
        </div>
    </header>

    <!-- Main Content -->
    <main class="content" id="main-content">
        <!-- Map Screen (Default) -->
        <div id="index-page">
            <div class="map-container">
                <div id="map"></div>
                <div id="map-placeholder" class="map-placeholder" style="display: none;">
                    <div class="spinner"></div>
                    <p>Loading map...</p>
                </div>
                <div class="map-controls">
                    <div class="map-control-button" id="zoom-in" tabindex="0" aria-label="Zoom in"> <span
                            class="material-icons">add</span> </div>
                    <div class="map-control-button" id="zoom-out" tabindex="0" aria-label="Zoom out"> <span
                            class="material-icons">remove</span> </div>
                    <div class="map-control-button" id="show-all-button" tabindex="0"
                        aria-label="Show all devices and places" aria-pressed="false"> <span class="material-icons"
                            id="show-all-icon">layers</span> </div>
                    <div class="map-control-button" id="show-history-button" tabindex="0"
                        aria-label="Show location history trail" aria-pressed="false"> <span class="material-icons"
                            id="show-history-icon">timeline</span> </div>
                    <div class="map-control-button" id="my-location" tabindex="0" aria-label="My location"> <span
                            class="material-icons">my_location</span> </div>
                </div>
            </div>
            <div class="history-slider-container"> {# Removed inline style="display: none;" #}
                <label for="history-slider" id="history-slider-label">Last 7d</label>
                <input type="range" id="history-slider" min="1" max="168" value="{{ 24*7 }}" step="1">
            </div>
            <div class="card" id="my-location-card">
                <div class="card-title">My Current Location</div>
                <div class="location-info"> <span class="material-icons location-info-icon">location_on</span>
                    <div class="location-info-text">
                        <div class="location-address" id="location-address-text">Fetching address...</div>
                        <div class="location-coordinates" id="location-coordinates-text">Fetching coordinates...</div>
                    </div>
                </div>
                <div class="location-info"> <span class="material-icons location-info-icon">update</span>
                    <div class="location-info-text">
                        <div class="location-address" id="last-updated-text">Last updated: Never</div>
                    </div>
                </div>
                <div class="button-row"> <button class="text-button" id="share-button"
                        data-dialog="share-location-dialog">Share</button> <button class="button"
                        id="refresh-button">Update</button> </div>
            </div>
        </div>

        <!-- Devices Screen -->
        <div id="shared-page" style="display: none;">
            <div class="card">
                <div class="card-title">My Devices</div>
                <p>Locations of accessories via <code>data/{{ username }}</code>.</p>
                <div class="location-info" style="margin-top: 8px; margin-bottom: 0;"> <span
                        class="material-icons location-info-icon" style="margin-right: 16px;">update</span>
                    <div class="location-info-text">
                        <div class="location-coordinates" id="devices-last-updated">Last updated: Never</div>
                    </div>
                </div>
                <div class="button-row"> <button class="text-button" id="add-device-link-button"
                        onclick="AppUI.changePage('settings', 'settings-upload-section')"> <span class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">add</span> Add Device
                    </button> <button class="button" id="refresh-devices-button"> <span class="material-icons"
                            style="font-size: 18px; vertical-align: middle; margin-right: 4px;">refresh</span> Refresh
                        Now </button> </div>
            </div>
            <div id="shared-devices-list-container">
                <div class="loading-indicator" id="devices-loading-indicator"
                    style="padding: 24px; text-align: center;">
                    <div class="spinner"></div> Fetching devices...
                </div>
                <div id="shared-devices-list" style="display: none;"></div>
                <p class="no-devices-message" id="no-devices-message"
                    style="display: none; padding: 24px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                </p>
                <p class="error-message" id="devices-error-message"
                    style="display: none; padding: 24px; text-align: center; color: var(--m3-sys-color-error);"> Error
                    fetching devices. </p>
            </div>
        </div>

        <!-- Geofences Screen -->
        <div id="geofences-page" style="display: none;">
            <div class="card">
                <div class="card-title">Geofences</div>
                <p>Define global areas, then link to devices and set notifications.</p>
                <div class="button-row"> <button class="text-button" id="test-notification-button">Test
                        Notification</button> <button class="button" id="add-global-geofence-button"> <span
                            class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">add_location</span>
                        Create New Geofence </button> </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section-title">Global Geofence Definitions</h4>
                <div id="global-geofences-list-container">
                    <div class="loading-indicator" id="global-geofences-loading"
                        style="padding: 16px; text-align: center;">
                        <div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div> Loading...
                    </div>
                    <div id="global-geofences-list" style="display: none;"></div>
                    <p class="no-devices-message" id="no-global-geofences-message"
                        style="display: none; padding: 16px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                        No geofences defined. </p>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section-title">Device Geofence Links & Notifications</h4>
                <div id="device-geofence-links-container">
                    <div class="loading-indicator" id="device-links-loading" style="padding: 16px; text-align: center;">
                        <div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div> Loading
                        devices...
                    </div>
                    <div id="device-geofence-links-list"></div>
                    <p class="no-devices-message" id="links-no-devices-message"
                        style="display: none; padding: 16px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                        No devices found. </p>
                </div>
            </div>
        </div>

        <!-- Saved Places Screen -->
        <div id="places-page" style="display: none;">
            <div class="card">
                <div class="card-title">Saved Places</div>
                <p>Your saved locations.</p>
            </div>
            <div id="saved-places-list">
                <p class="no-devices-message" id="no-places-message"
                    style="display: block; padding: 16px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                    No places saved. Tap '+' to add.</p>
            </div>
        </div>

        <!-- History Screen -->
        <div id="history-page" style="display: none;">
            <div class="card">
                <div class="card-title">My Location History</div>
                <p>Recent location checks.</p>
                <div class="button-row"> <button class="text-button" id="clear-history-button">Clear History</button>
                </div>
            </div>
            <div id="location-history-container">
                <div class="loading-indicator" id="history-loading-indicator"
                    style="padding: 24px; text-align: center; display: none;">
                    <div class="spinner"></div> Loading history...
                </div>
                <div class="timeline" id="location-timeline" style="display: block;">
                    <p class="no-devices-message" id="no-history-message"
                        style="display: block; padding: 16px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                        No history recorded.</p>
                </div>
                <p class="no-devices-message" id="history-disabled-message"
                    style="display: none; padding: 24px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                    History disabled in settings. </p>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settings-page" style="display: none;">
            <div class="card">
                <div class="card-title">App Settings</div>
                <p>Customize your experience.</p>
            </div>
            <div class="settings-section" id="settings-upload-section">
                <h4 class="settings-section-title">Manage Device Files</h4>
                <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Upload Device File(s)</div>
                        <div class="settings-item-description">Upload <code>.plist</code> or <code>.keys</code> files.
                        </div>
                    </div> <input type="file" id="device-file-input" accept=".plist,.keys" class="hidden-file-input"
                        multiple> <button class="button" id="select-files-button"
                        style="margin-top: 12px; align-self: flex-start;"
                        onclick="document.getElementById('device-file-input').click()"> <span class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">attach_file</span>
                        Select File(s) </button>
                    <div id="selected-files-list"></div> <button class="button" id="upload-file-button"
                        style="margin-top: 12px; align-self: flex-start;" disabled> <span class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">upload_file</span>
                        Upload Selected Files </button>
                    <p id="upload-status"
                        style="font-size: var(--body-small-size); margin-top: 8px; min-height: 1.2em;"></p>
                </div>
            </div>
            <div class="settings-section" id="settings-import-export">
                <h4 class="settings-section-title">Import / Export</h4>
                <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                    <div class="settings-item-text" style="margin-bottom: 12px;">
                        <div class="settings-item-title">Export Configuration</div>
                        <div class="settings-item-description">Save settings to JSON (backup).</div>
                    </div>
                    <div id="export-parts-selection" style="margin-bottom: 12px;">
                        <h4 class="settings-section-title" style="margin-bottom: 8px;">Select Parts to Export</h4>
                        <label> <input type="checkbox" name="export_part" value="devices" checked> Device Configs
                            <span>(Server)</span> </label> <label> <input type="checkbox" name="export_part"
                                value="geofences" checked> Geofences <span>(Server)</span> </label> <label> <input
                                type="checkbox" name="export_part" value="clientSettings" checked> UI & Map Settings
                            <span>(Client)</span> </label> <label> <input type="checkbox" name="export_part"
                                value="savedPlaces" checked> Saved Places <span>(Client)</span> </label> <label> <input
                                type="checkbox" name="export_part" value="locationHistory" checked> Location History
                            <span>(Client)</span> </label> <label> <input type="checkbox" name="export_part"
                                value="deviceVisibility" checked> Device Visibility <span>(Client)</span> </label>
                    </div> <button class="button" id="export-config-button" style="align-self: flex-start;"> <span
                            class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">download</span> Export
                        Selected </button>
                </div>
                <div class="settings-item" style="flex-direction: column; align-items: stretch; margin-top: 16px;">
                    <div class="settings-item-text" style="margin-bottom: 12px;">
                        <div class="settings-item-title">Import Configuration</div>
                        <div class="settings-item-description">Load from exported JSON. <strong>Replaces</strong>
                            selected parts.</div>
                    </div> <input type="file" id="import-config-file-input" accept=".json" class="hidden-file-input">
                    <label for="import-config-file-input" class="button" id="select-import-file-button-label"
                        style="align-self: flex-start; display: inline-flex; align-items: center; cursor: pointer;">
                        <span class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">attach_file</span>
                        Select File </label>
                    <div id="selected-import-file-list" style="margin-top: 8px;"></div>
                    <div id="import-parts-selection" style="display: none; margin-top: 16px;">
                        <h4 class="settings-section-title">Select Parts to Import</h4>
                    </div> <button class="button" id="confirm-import-button"
                        style="margin-top: 12px; display: none; align-self: flex-start;"> <span class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">save</span> Import
                        Selected </button>
                    <p id="import-status-message"
                        style="font-size: var(--body-small-size); margin-top: 8px; min-height: 1.2em;"></p>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section-title">Appearance</h4>
                <div class="settings-item">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Theme Mode</div>
                        <div class="settings-item-description">App theme</div>
                    </div>
                    <div class="theme-selector"> <label><input type="radio" name="theme" value="system"> System</label>
                        <label><input type="radio" name="theme" value="light"> Light</label> <label><input type="radio"
                                name="theme" value="dark"> Dark</label>
                    </div>
                </div>
                <div class="settings-item">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Accent Color</div>
                        <div class="settings-item-description">Primary theme color</div>
                    </div>
                    <div class="color-picker-container"> <input type="color" id="theme-color-picker"
                            title="Select theme color"> <button class="text-button" id="reset-theme-color-button"
                            title="Reset to default color"> <span class="material-icons">restart_alt</span> </button>
                    </div>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section-title">Location</h4>
                <div class="settings-item">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Location History</div>
                        <div class="settings-item-description">Save history</div>
                    </div> <label class="toggle-switch"> <input type="checkbox" id="location-history-toggle" checked>
                        <span class="toggle-slider"></span> </label>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section-title">Map View Defaults</h4>
                <div class="settings-item">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Show All Devices on Load</div>
                        <div class="settings-item-description">Start with "Show All"</div>
                    </div> <label class="toggle-switch"> <input type="checkbox" id="show-all-default-toggle"> <span
                            class="toggle-slider"></span> </label>
                </div>
                <div class="settings-item">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Show History Trail on Load</div>
                        <div class="settings-item-description">Start with history visible</div>
                    </div> <label class="toggle-switch"> <input type="checkbox" id="show-history-default-toggle"> <span
                            class="toggle-slider"></span> </label>
                </div>
            </div>

             <!-- START: New Shares Section -->
             <div class="settings-section" id="settings-shares">
                <h4 class="settings-section-title">Active Shares</h4>
                <div id="active-shares-list-container">
                    <div class="loading-indicator" id="active-shares-loading" style="padding: 16px; text-align: center;">
                        <div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div> Loading shares...
                    </div>
                    <div id="active-shares-list" style="display: none;">
                        <!-- Active shares will be rendered here by JS -->
                    </div>
                    <p class="no-devices-message" id="no-active-shares-message" style="display: none; padding: 16px; text-align: center; color: var(--m3-sys-color-outline-variant);">
                        You haven't shared any devices yet. Use the menu (<span class="material-icons" style="font-size: 1em; vertical-align: middle;">more_vert</span>) on the Devices page to share one.
                    </p>
                </div>
            </div>
            <!-- END: New Shares Section -->

            <!-- NEW Fetch Interval Setting -->
            <!-- <div class="settings-section">
                <h4 class="settings-section-title">Background Fetching</h4>
                <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Background Scan Interval (minutes)</div>
                        <div class="settings-item-description">
                            How often the server checks for location updates (5-120).
                            Leave empty to use global default ({{ config.DEFAULT_FETCH_INTERVAL_MINUTES }} min).
                            Shorter intervals use more resources & battery.
                        </div>
                    </div>
                    <input type="number" id="user-fetch-interval"
                        placeholder="Default: {{ config.DEFAULT_FETCH_INTERVAL_MINUTES }}" min="5" max="120" step="1"
                        style="margin-top: 8px;">
                    <p id="interval-error" class="form-field-error" style="display: none;"></p>
                </div>
                <div class="settings-item"
                    style="background: none; box-shadow: none; padding-top: 0; justify-content: flex-end;">
                    <button class="button" id="save-fetching-prefs-button">Save Scan Interval</button>
                </div>
            </div> -->
            <!-- END NEW Fetch Interval Setting -->

            <div class="settings-section" id="settings-notifications">
                <h4 class="settings-section-title">Notifications</h4>
                <div class="settings-item">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Push Notifications</div>
                        <div class="settings-item-description">Get geofence/battery alerts</div>
                    </div> <button class="button" id="enable-notifications-button"
                        style="margin-left: auto; min-width: 180px;">Enable Notifications</button>
                </div>
                <div class="settings-item"
                    style="background: none; box-shadow: none; padding-top: 0; align-items: center;">
                    <div id="notification-status-container" style="width: 100%;"> <span id="notification-status"
                            style="margin-top: 0;">Checking...</span> <button class="text-button"
                            id="unsubscribe-button" style="display: none;">Unsubscribe</button> </div>
                </div>
                <div class="settings-item"
                    style="background: none; box-shadow: none; padding-top: 0; align-items: center;"> <button
                        class="text-button" id="test-notification-button" style="display: none; margin-left: auto;">Test
                        Notification</button> </div>
                <!-- NEW User Notification Preferences TODO: Link to backend -->
                <!-- 
                <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Low Battery Threshold (%)</div>
                        <div class="settings-item-description"> Notify below this level (5-50). Empty for global default
                            ({{ config.LOW_BATTERY_THRESHOLD }}%). </div>
                    </div>
                    <input type="number" id="user-low-battery-threshold"
                        placeholder="Default: {{ config.LOW_BATTERY_THRESHOLD }}" min="5" max="50" step="1"
                        style="margin-top: 8px;">
                    <p id="threshold-error" class="form-field-error" style="display: none;"></p>
                </div>
                <div class="settings-item" style="flex-direction: column; align-items: stretch; display: none;">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Notification Cooldown (seconds)</div>
                        <div class="settings-item-description"> Min time between alerts per device (>= 60). Empty for
                            global default ({{ config.NOTIFICATION_COOLDOWN_SECONDS }}s). </div>
                    </div>
                    <input type="number" id="user-notification-cooldown"
                        placeholder="Default: {{ config.NOTIFICATION_COOLDOWN_SECONDS }}" min="60" step="30"
                        style="margin-top: 8px;">
                    <p id="cooldown-error" class="form-field-error" style="display: none;"></p>
                </div>
                <div class="settings-item"
                    style="background: none; box-shadow: none; padding-top: 0; justify-content: flex-end; display: none;"> <button
                        class="button" id="save-notification-prefs-button">Save Notification Settings</button>
                </div> -->
                <!-- END NEW -->
            </div>
            <div class="settings-section" id="settings-account-management">
                <h4 class="settings-section-title" style="color: var(--m3-sys-color-error);">Danger Zone</h4>
                <div class="settings-item"
                    style="border-color: var(--m3-sys-color-error); background-color: color-mix(in srgb, var(--m3-sys-color-error-container) 50%, transparent);">
                    <div class="settings-item-text">
                        <div class="settings-item-title" style="color: var(--m3-sys-color-error);">Delete Account</div>
                        <div class="settings-item-description" style="color: var(--m3-sys-color-on-error-container);">
                            Permanently delete account and all data. Cannot be undone.</div>
                    </div> <button class="button" id="delete-account-button"
                        style="margin-left: auto; background-color: var(--m3-sys-color-error); color: var(--m3-sys-color-on-error);">
                        <span class="material-icons"
                            style="font-size: 18px; vertical-align: bottom; margin-right: 4px;">delete_forever</span>
                        Delete My Account </button>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section-title">About</h4>
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                    <div class="settings-item-text">
                        <div class="settings-item-title">Find My Location Web App</div>
                        <div class="settings-item-description" id="app-version">Version {{ APP_VERSION }}</div> <button
                            class="text-button" style="padding-left: 0; margin-top: 8px;"
                            onclick="AppUI.openDialog('help-dialog')">Help & Info</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- NEW Notification History Screen -->
        <div id="notifications-history-page" style="display: none;">
            <div class="card">
                <div class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>Notification History</span>
                    <div style="display: flex; gap: 8px;"> <button class="text-button" id="mark-all-read-button"
                            title="Mark all as read"> <span class="material-icons"
                                style="font-size: 18px;">mark_chat_read</span> </button> <button class="text-button"
                            id="clear-all-history-button" title="Clear all history"
                            style="color: var(--m3-sys-color-error);"> <span class="material-icons"
                                style="font-size: 18px;">delete_sweep</span> </button> </div>
                </div>
                <p>Recent backend notifications. Read status managed here.</p>
            </div>
            <div id="notifications-history-list-container">
                <div class="loading-indicator" id="notifications-history-loading"
                    style="padding: 24px; text-align: center;">
                    <div class="spinner"></div> Loading history...
                </div>
                <div id="notifications-history-list" style="display: none;"></div>
                <p class="no-devices-message" id="no-notifications-history-message"
                    style="display: none; padding: 24px; text-align: center; color: var(--m3-sys-color-outline);"> No
                    history found. </p>
            </div>
        </div>

    </main>

    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
        <a href="#" class="nav-item nav-link active" data-page="index"> <span class="material-icons nav-icon">map</span>
            <span class="nav-label">Map</span> </a>
        <a href="#" class="nav-item nav-link" data-page="shared"> <span class="material-icons nav-icon">devices</span>
            <span class="nav-label">Devices</span> </a>
        <a href="#" class="nav-item nav-link" data-page="geofences"> <span class="material-icons nav-icon">radar</span>
            <span class="nav-label">Geofences</span> </a>
        <a href="#" class="nav-item nav-link" data-page="places"> <span
                class="material-icons nav-icon">star_outline</span> <span class="nav-label">Places</span> </a>
        <a href="#" class="nav-item nav-link" data-page="settings"> <span
                class="material-icons nav-icon">settings</span> <span class="nav-label">Settings</span> </a>
    </nav>

    <!-- FAB Button -->
    <div class="fab" id="add-place-button" style="display: none;" aria-label="Add Place"> <span class="material-icons"
            style="color: white;">add_location</span> </div>

    <!-- Scripts -->
    <script id="leaflet-js" src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="{{ url_for('static', filename='js/config.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/state.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/utils.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/api.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/map.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/ui.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/notifications.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/app.js') }}" defer></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Use dynamic import for the module
            import("{{ url_for('static', filename='libs/material-color/material-color-utilities.esm.js') }}")
                .then((module) => {
                    window.M3ColorUtils = module; // Assign to global scope
                    console.log("Loaded Material Color Utilities locally.");
                    // Potentially re-initialize theme if needed here, or ensure app.js waits
                })
                .catch(err => {
                    console.error("Failed to load Material Color Utilities locally:", err);
                    // Handle the failure (e.g., use fallback CSS variables)
                });
        });
    </script>
</body>

</html>
// --------------------
// app\templates\login.html
<!-- templates/login.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title or 'Login' }} - Find My Location</title> {# Use title variable #}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .login-card {
            max-width: 400px;
            width: 90%;
            padding: 32px;
            text-align: center;
        }

        .login-card input[type="text"],
        .login-card input[type="password"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 16px;
            border: 1px solid var(--outline-variant-color);
            border-radius: 8px;
            font-size: var(--body-medium-size);
        }

        .login-card .button {
            width: 100%;
            margin-top: 16px;
        }

        .flash-messages {
            margin-bottom: 16px;
        }

        .flash-messages .error {
            color: var(--error-color);
        }

        .flash-messages .info {
            color: var(--primary-color);
        }

        .remember-me {
            display: block;
            margin-top: 16px;
            text-align: left;
            font-size: var(--body-small-size);
        }


        .form-field-error {
            color: var(--error-color);
            font-size: var(--body-small-size);
            margin-top: -12px;
            margin-bottom: 12px;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="card login-card">
        <h1 class="card-title">{{ title or 'Login' }}</h1>

        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
        <div class="flash-messages">
            {% for category, message in messages %}
            <p class="{{ category }}">{{ message | safe }}</p>
            {% endfor %}
        </div>
        {% endif %}
        {% endwith %}

        <form method="POST" action="{{ url_for('auth.login_route') }}" novalidate>
            {{ form.hidden_tag() }} {# Renders CSRF token and hidden fields #}

            <div>
                {{ form.username.label(style="display:none;") }} {# Hide label if placeholder is enough #}
                {{ form.username(placeholder="Username", autofocus=true, autocomplete="username") }}
                {% for error in form.username.errors %}
                <p class="form-field-error">{{ error }}</p>
                {% endfor %}
            </div>

            <div>
                {{ form.password.label(style="display:none;") }}
                {{ form.password(placeholder="Password", autocomplete="current-password") }}
                {% for error in form.password.errors %}
                <p class="form-field-error">{{ error }}</p>
                {% endfor %}
            </div>

            <label class="remember-me">
                {{ form.remember() }} {{ form.remember.label }}
            </label>

            {{ form.submit(class="button") }}
        </form>
        <p class="login-link">Need an account? <a href="{{ url_for('auth.register_route') }}">Register here</a></p>
    </div>

    <script>
        (function () { const theme = localStorage.getItem('theme') || 'system'; if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) { document.body.classList.add('dark-theme'); } })();
    </script>
</body>

</html>
// --------------------
// app\templates\logout_success.html
<!-- app/templates/logout_success.html -->
<!-- NEW FILE -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Redirect to login page after 2 seconds -->
    <meta http-equiv="refresh" content="2;url={{ url_for('auth.login_route') }}">
    <title>Logged Out - Find My Location</title>

    <link rel="preload" href="https://fonts.googleapis.com/icon?family=Material+Icons" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
        }

        .message-card {
            max-width: 450px;
            width: 90%;
            padding: 32px;
        }

        .message-icon {
            font-size: 48px;
            color: var(--primary-color);
            margin-bottom: 16px;
        }

        body.dark-theme .message-icon {
            color: var(--dark-primary-color);
        }

        .flash-messages {
            margin-top: 16px;
        }

        .flash-messages .info {
            color: var(--on-surface-color);
            opacity: 0.8;
        }

        body.dark-theme .flash-messages .info {
            color: var(--dark-on-surface-color);
        }

        .redirect-info {
            margin-top: 20px;
            font-size: var(--body-small-size);
            color: var(--outline-color);
        }

        body.dark-theme .redirect-info {
            color: var(--dark-outline-color);
        }
    </style>
</head>

<body>
    <div class="card message-card">
        <span class="material-icons message-icon">check_circle</span>
        <h1 class="card-title">Logout Successful</h1>

        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
        <div class="flash-messages">
            {% for category, message in messages %}
            {# Display only info messages here, errors handled differently if needed #}
            {% if category == 'info' %}
            <p class="{{ category }}">{{ message | safe }}</p>
            {% endif %}
            {% endfor %}
        </div>
        {% else %}
        <p>You have been successfully logged out.</p>
        {% endif %}
        {% endwith %}

        <p class="redirect-info">You will be redirected to the login page shortly...</p>
        <p class="redirect-info">(If not redirected automatically, <a href="{{ url_for('auth.login_route') }}">click
                here</a>.)</p>
    </div>

    <script>
        // Apply theme based on localStorage - Keep this, as backend prefs are gone
        (function () {
            const theme = localStorage.getItem('theme') || 'system';
            if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.body.classList.add('dark-theme');
            }
            // No need to add light-theme class explicitly if it's the default without dark-theme
        })();
    </script>
</body>

</html>
// --------------------
// app\templates\manage_apple_creds.html
<!-- templates/manage_apple_creds.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title or 'Manage Apple Credentials' }}</title> {# Use title variable #}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <style>
        .content {
            padding-top: 24px;
        }

        .flash-messages {
            margin-bottom: 16px;
            padding: 0 16px;
        }

        .flash-messages .error {
            color: var(--error-color);
        }

        .flash-messages .success {
            color: var(--primary-color);
        }

        .flash-messages .warning {
            color: var(--secondary-color);
        }

        .credential-info {
            font-size: var(--body-small-size);
            opacity: 0.7;
            margin-bottom: 8px;
        }

        .back-link {
            margin-left: 16px;
            margin-bottom: 16px;
            display: inline-block;
            color: var(--primary-color);
            text-decoration: none;
        }

        body.dark-theme .back-link {
            color: var(--dark-primary-color);
        }

        .asp-info {
            margin-top: 12px;
            padding: 12px;
            border: 1px solid var(--m3-sys-color-tertiary);
            /* Use tertiary color for emphasis */
            background-color: color-mix(in srgb, var(--m3-sys-color-tertiary-container) 40%, transparent);
            color: var(--m3-sys-color-on-tertiary-container);
            margin-top: 20px;
            /* More space */
            margin-bottom: 20px;
        }

        body.dark-theme .asp-info {
            border-color: var(--dark-outline-variant-color);
            background-color: var(--dark-surface-variant-color);
            color: var(--dark-on-surface-color);
        }

        .asp-info strong {
            color: var(--m3-sys-color-tertiary);
            /* Match border */
        }

        body.dark-theme .asp-info strong {
            color: var(--dark-primary-color);
        }

        .asp-info a {
            color: var(--m3-sys-color-tertiary);
            /* Match border */
            font-weight: 500;
        }

        body.dark-theme .asp-info a {
            color: var(--dark-primary-color);
        }

        .form-field-error {
            color: var(--error-color);
            font-size: var(--body-small-size);
            margin-top: 4px;
        }

        .flash-messages .login-failed-2fa {
            /* Add specific class */
            color: var(--m3-sys-color-error);
            font-weight: 500;
            border: 1px solid var(--m3-sys-color-error);
            padding: 8px;
            border-radius: 8px;
            background-color: color-mix(in srgb, var(--m3-sys-color-error-container) 50%, transparent);
            margin-top: 16px;
        }
    </style>
</head>

<body>
    <!-- App Bar -->
    <header class="app-bar">
        <a href="{{ url_for('main.index_route') }}" style="text-decoration: none; color: inherit;">
            <span class="material-icons menu-icon">arrow_back</span>
        </a>
        <h1>{{ title or 'Manage Apple Credentials' }}</h1>
    </header>

    <main class="content">
        <div class="flash-messages">
            {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
            {% for category, message in messages %}
            {# Add special styling for 2FA errors #}
            {% if 'Two-Factor Authentication required' in message %}
            <p class="login-failed-2fa">{{ message | safe }}</p>
            {% else %}
            <p class="{{ category }}">{{ message | safe }}</p>
            {% endif %}
            {% endfor %}
            {% endif %}
            {% endwith %}
        </div>

        <div class="card">
            <div class="card-title">Set Apple ID for Background Fetching</div>
            <p class="credential-info">These credentials are used by the background service...</p>
            <!-- ASP Info Box -->
            <div class="asp-info">
                <strong><span class="material-icons"
                        style="font-size: 1.2em; vertical-align: bottom; margin-right: 4px;">warning</span>Important:
                    2FA / App-Specific Password Required!</strong><br>
                If your Apple account has Two-Factor Authentication (2FA) enabled (most do!), you <strong>must</strong>
                generate and use an <strong>App-Specific Password (ASP)</strong> below. Using your regular password
                <strong>will fail</strong>.
                <ul>
                    <li>Generate an ASP at <a href="https://appleid.apple.com" target="_blank"
                            rel="noopener noreferrer">appleid.apple.com</a></li>
                    <li>Go to "Sign-In and Security" → "App-Specific Passwords".</li>
                    <li>Click "Generate an app-specific password" (you might need to verify your identity).</li>
                    <li>Enter a label (e.g., "FindMyWebApp") and copy the generated password (including hyphens).</li>
                    <li>Enter your Apple ID email above and the <strong>generated ASP</strong> in the password field
                        below.</li>
                </ul>
            </div>
            <!-- End ASP Info Box -->

            <form method="POST" action="{{ url_for('main.manage_apple_creds_route') }}" novalidate>
                {{ form.hidden_tag() }}

                <div class="settings-item" style="flex-direction: column; align-items: stretch; margin-top: 16px;">
                    <div class="settings-item-text">
                        {{ form.apple_id.label(class="settings-item-title") }}
                        {{ form.apple_id(placeholder="you@example.com", autocomplete="username") }}
                        {% for error in form.apple_id.errors %}
                        <p class="form-field-error">{{ error }}</p>
                        {% endfor %}
                    </div>

                    <div class="settings-item" style="flex-direction: column; align-items: stretch;">
                        <div class="settings-item-text">
                            {{ form.apple_password.label(class="settings-item-title") }}
                            <div class="settings-item-description">Enter the <strong>App-Specific Password</strong>
                                generated from appleid.apple.com.</div>
                        </div>
                        {{ form.apple_password(placeholder="App-Specific Password (e.g., xxxx-xxxx-xxxx-xxxx)",
                        autocomplete="current-password") }} {# Changed placeholder #}
                        {% for error in form.apple_password.errors %}
                        <p class="form-field-error">{{ error }}</p>
                        {% endfor %}
                    </div>

                    <div class="button-row">
                        {{ form.submit(class="button") }}
                    </div>
            </form>
        </div>
    </main>

    <script>
        (function () { const theme = localStorage.getItem('theme') || 'system'; if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) { document.body.classList.add('dark-theme'); const meta = document.createElement('meta'); meta.name = "theme-color"; meta.content = "#1E1B22"; document.head.appendChild(meta); } else { const meta = document.createElement('meta'); meta.name = "theme-color"; meta.content = "#6750A4"; document.head.appendChild(meta); } })();
    </script>
</body>

</html>
// --------------------
// app\templates\register.html
<!-- templates/register.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title or 'Register' }} - Find My Location</title> {# Use title variable #}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .login-card {
            max-width: 400px;
            width: 90%;
            padding: 32px;
            text-align: center;
        }

        .login-card input {
            width: 100%;
            padding: 12px;
            margin-bottom: 16px;
            border: 1px solid var(--outline-variant-color);
            border-radius: 8px;
            font-size: var(--body-medium-size);
        }

        .login-card .button {
            width: 100%;
            margin-top: 16px;
        }

        .flash-messages {
            margin-bottom: 16px;
        }

        .flash-messages .error {
            color: var(--error-color);
        }

        .flash-messages .success {
            color: var(--primary-color);
        }

        .login-link {
            margin-top: 20px;
            font-size: var(--body-small-size);
        }

        .form-field-error {
            color: var(--error-color);
            font-size: var(--body-small-size);
            margin-top: -12px;
            margin-bottom: 12px;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="card login-card">
        <h1 class="card-title">{{ title or 'Register New User' }}</h1>

        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
        <div class="flash-messages">
            {% for category, message in messages %}
            <p class="{{ category }}">{{ message | safe }}</p>
            {% endfor %}
        </div>
        {% endif %}
        {% endwith %}

        <form method="POST" action="{{ url_for('auth.register_route') }}" novalidate>
            {{ form.hidden_tag() }} {# Renders CSRF token #}

            <div>
                {{ form.username.label(style="display:none;") }}
                {{ form.username(placeholder="Username", autofocus=true, autocomplete="username") }}
                {% for error in form.username.errors %}
                <p class="form-field-error">{{ error }}</p>
                {% endfor %}
            </div>

            <div>
                {{ form.email.label(style="display:none;") }}
                {{ form.email(placeholder="Email Address", autocomplete="email") }}
                {% for error in form.email.errors %}
                <p class="form-field-error">{{ error }}</p>
                {% endfor %}
            </div>

            <div>
                {{ form.password.label(style="display:none;") }}
                {{ form.password(placeholder="Password", autocomplete="new-password") }}
                {% for error in form.password.errors %}
                <p class="form-field-error">{{ error }}</p>
                {% endfor %}
            </div>

            <div>
                {{ form.confirm_password.label(style="display:none;") }}
                {{ form.confirm_password(placeholder="Confirm Password", autocomplete="new-password") }}
                {% for error in form.confirm_password.errors %}
                <p class="form-field-error">{{ error }}</p>
                {% endfor %}
            </div>

            {{ form.submit(class="button") }}
        </form>
        <p class="login-link">Already have an account? <a href="{{ url_for('auth.login_route') }}">Login here</a></p>
    </div>
    <script>
        (function () { const theme = localStorage.getItem('theme') || 'system'; if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) { document.body.classList.add('dark-theme'); } })();
    </script>
</body>

</html>
// --------------------
// app\templates\share_map.html
<!-- app/templates/share_map.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shared Location</title>
    <link rel="stylesheet" id="leaflet-css" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Load Material Symbols -->
    <link rel="stylesheet" id="material-symbols-css"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&display=swap" />
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" sizes="any">
    <link rel="icon" href="{{ url_for('static', filename='icons/favicon.svg') }}" type="image/svg+xml">
    <meta name="theme-color" content="#6750A4" id="share-meta-theme-color"> <!-- Default M3 Purple -->
    <style>
        /* --- START: Core M3 Variables (Light/Dark Fallbacks) --- */
        :root {
            /* M3 Sys Color Roles (Light Theme Fallbacks - Purple Source #6750A4) */
            --m3-sys-color-primary: #6750A4;
            --m3-sys-color-on-primary: #FFFFFF;
            --m3-sys-color-primary-container: #EADDFF;
            --m3-sys-color-on-primary-container: #21005D;
            --m3-sys-color-secondary: #625B71;
            --m3-sys-color-on-secondary: #FFFFFF;
            --m3-sys-color-secondary-container: #E8DEF8;
            --m3-sys-color-on-secondary-container: #1D192B;
            --m3-sys-color-tertiary: #7D5260;
            --m3-sys-color-on-tertiary: #FFFFFF;
            --m3-sys-color-tertiary-container: #FFD8E4;
            --m3-sys-color-on-tertiary-container: #31111D;
            --m3-sys-color-error: #B3261E;
            --m3-sys-color-on-error: #FFFFFF;
            --m3-sys-color-error-container: #F9DEDC;
            --m3-sys-color-on-error-container: #410E0B;
            --m3-sys-color-background: #FFFBFE;
            --m3-sys-color-on-background: #1C1B1F;
            --m3-sys-color-surface: #FFFBFE;
            --m3-sys-color-surface-rgb: 255, 251, 254;
            --m3-sys-color-on-surface: #1C1B1F;
            --m3-sys-color-surface-variant: #E7E0EC;
            --m3-sys-color-on-surface-variant: #49454F;
            --m3-sys-color-outline: #79747E;
            --m3-sys-color-outline-variant: #CAC4D0;
            --m3-sys-color-shadow: #000000;
            --m3-sys-color-scrim: #000000;
            --m3-sys-color-scrim-rgb: 0, 0, 0;
            --m3-sys-color-inverse-surface: #313033;
            --m3-sys-color-inverse-on-surface: #F4EFF4;
            --m3-sys-color-inverse-primary: #D0BCFF;
            /* M3 Surface Tones (Light Theme Fallbacks) */
            --m3-sys-color-surface-dim: #DED8E1;
            --m3-sys-color-surface-bright: #FFFBFE;
            --m3-sys-color-surface-container-lowest: #FFFFFF;
            --m3-sys-color-surface-container-low: #F7F2FA;
            --m3-sys-color-surface-container: #F3EDF7;
            --m3-sys-color-surface-container-high: #EDEAF3;
            --m3-sys-color-surface-container-highest: #E6E0E9;
            --font-family: 'Roboto', 'Segoe UI', system-ui, sans-serif;
            --label-small-size: 11px;
            --body-small-size: 12px;
            --body-medium-size: 14px;
            --title-medium-size: 16px;
            --title-large-size: 22px;
        }

        /* Dark Theme Overrides */
        @media (prefers-color-scheme: dark) {
            :root {
                --m3-sys-color-primary: #D0BCFF;
                --m3-sys-color-on-primary: #381E72;
                --m3-sys-color-primary-container: #4F378B;
                --m3-sys-color-on-primary-container: #EADDFF;
                --m3-sys-color-secondary: #CCC2DC;
                --m3-sys-color-on-secondary: #332D41;
                --m3-sys-color-secondary-container: #4A4458;
                --m3-sys-color-on-secondary-container: #E8DEF8;
                --m3-sys-color-tertiary: #EFB8C8;
                --m3-sys-color-on-tertiary: #492532;
                --m3-sys-color-tertiary-container: #633B48;
                --m3-sys-color-on-tertiary-container: #FFD8E4;
                --m3-sys-color-error: #F2B8B5;
                --m3-sys-color-on-error: #601410;
                --m3-sys-color-error-container: #8C1D18;
                --m3-sys-color-on-error-container: #F9DEDC;
                --m3-sys-color-background: #1C1B1F;
                --m3-sys-color-on-background: #E6E1E5;
                --m3-sys-color-surface: #1C1B1F;
                --m3-sys-color-surface-rgb: 28, 27, 31;
                --m3-sys-color-on-surface: #E6E1E5;
                --m3-sys-color-surface-variant: #49454F;
                --m3-sys-color-on-surface-variant: #CAC4D0;
                --m3-sys-color-outline: #938F99;
                --m3-sys-color-outline-variant: #49454F;
                --m3-sys-color-shadow: #000000;
                --m3-sys-color-scrim: #000000;
                --m3-sys-color-scrim-rgb: 0, 0, 0;
                --m3-sys-color-inverse-surface: #E6E1E5;
                --m3-sys-color-inverse-on-surface: #313033;
                --m3-sys-color-inverse-primary: #6750A4;
                --m3-sys-color-surface-dim: #141218;
                --m3-sys-color-surface-bright: #3B383E;
                --m3-sys-color-surface-container-lowest: #0F0D13;
                --m3-sys-color-surface-container-low: #1C1B1F;
                --m3-sys-color-surface-container: #201F23;
                --m3-sys-color-surface-container-high: #2B292F;
                --m3-sys-color-surface-container-highest: #36343A;
            }
        }

        /* --- END: Core M3 Variables --- */

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: var(--font-family);
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--m3-sys-color-background);
            color: var(--m3-sys-color-on-background);
        }

        #share-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Simple App Bar */
        .share-app-bar {
            background-color: var(--m3-sys-color-surface-container-low);
            color: var(--m3-sys-color-on-surface);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            box-shadow: 0 1px 2px rgba(var(--m3-sys-color-shadow), 0.1);
            flex-shrink: 0;
            z-index: 10;
        }

        .share-app-bar-icon {
            font-size: 24px;
            color: var(--m3-sys-color-primary);
        }

        .share-app-bar-title {
            font-size: var(--title-large-size);
            font-weight: 500;
            margin-left: 16px;
        }

        /* Map Area */
        #share-map-wrapper {
            flex-grow: 1;
            position: relative;
            background-color: var(--m3-sys-color-surface-variant);
        }

        #share-map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* --- START: App-Style Map Controls --- */
        /* Hide Leaflet's default zoom control */
        .leaflet-control-zoom {
            display: none !important;
        }

        .map-controls {
            /* Container for buttons */
            position: absolute;
            right: 10px;
            /* Adjusted from 16px */
            top: 10px;
            /* Position top-right */
            display: flex;
            flex-direction: column;
            gap: 0px;
            /* No gap between buttons */
            z-index: 850;
            align-items: flex-end;
            background-color: var(--m3-sys-color-surface);
            border-radius: 28px;
            /* Fully rounded */
            box-shadow: 0 1px 5px rgba(var(--m3-sys-color-shadow), 0.2);
            overflow: hidden;
        }

        .map-control-button {
            /* Individual button styling */
            width: 40px;
            height: 40px;
            background-color: transparent;
            /* Button background transparent inside container */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border: none;
            padding: 0;
            color: var(--m3-sys-color-on-surface-variant);
            font-family: 'Material Symbols Outlined';
            /* Use symbols font */
            font-size: 22px;
            /* Material Symbol size */
            font-weight: 400;
        }

        .map-control-button:hover {
            background-color: var(--m3-sys-color-surface-container-high);
            color: var(--m3-sys-color-on-surface);
        }

        .map-control-button:first-child {
            /* Separator line */
            border-bottom: 1px solid var(--m3-sys-color-outline-variant);
        }

        .map-control-button:disabled {
            /* Disabled state */
            color: var(--m3-sys-color-outline);
            opacity: 0.5;
            cursor: default;
            background-color: transparent !important;
        }

        /* --- END: App-Style Map Controls --- */

        .custom-marker-share {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-marker-share svg {
            filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.4));
        }

        /* Info Card Overlay */
        .info-card {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            background-color: var(--m3-sys-color-surface-container-high);
            color: var(--m3-sys-color-on-surface);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(var(--m3-sys-color-shadow), 0.15);
            z-index: 900;
            max-width: 500px;
            margin: 0 auto;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none;
        }

        .info-card.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-card-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .info-card-icon {
            font-size: 20px;
            color: var(--m3-sys-color-secondary);
        }

        .info-card-title {
            font-size: var(--title-medium-size);
            font-weight: 500;
            margin-left: 8px;
            flex-grow: 1;
        }

        .info-card-details {
            font-size: var(--body-medium-size);
            color: var(--m3-sys-color-on-surface-variant);
            line-height: 1.5;
        }

        .info-card-details .material-symbols-outlined {
            font-size: 1.1em;
            vertical-align: bottom;
            margin-right: 6px;
            opacity: 0.8;
        }

        .info-card-note-container {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--m3-sys-color-outline-variant);
            display: none;
        }

        /* Hide note container by default */
        .info-card-note {
            font-size: var(--body-small-size);
            font-style: italic;
            color: var(--m3-sys-color-on-surface-variant);
        }

        /* Loading/Error Overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: color-mix(in srgb, var(--m3-sys-color-scrim) 40%, transparent);
            /* Use scrim color with alpha */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            transition: opacity 0.3s ease-out;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-overlay .material-symbols-outlined {
            font-size: 48px;
            color: var(--m3-sys-color-error);
            margin-bottom: 12px;
            display: none;
            /* Hide error icon by default */
        }

        .loading-overlay.error .material-symbols-outlined {
            display: inline-block;
        }

        /* Show error icon */
        .loading-overlay p {
            margin-top: 12px;
            color: var(--m3-sys-color-on-surface-variant);
            font-size: var(--body-medium-size);
        }

        .loading-overlay.error p {
            color: var(--m3-sys-color-error);
            font-weight: 500;
        }

        .spinner {
            border: 4px solid var(--m3-sys-color-surface-variant);
            border-top: 4px solid var(--m3-sys-color-primary);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-overlay.error .spinner {
            display: none;
        }

        /* Hide spinner on error */

        /* Leaflet Popup */
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: var(--m3-sys-color-surface-container-high);
            color: var(--m3-sys-color-on-surface);
            box-shadow: 0 1px 4px rgba(var(--m3-sys-color-shadow), 0.15);
            border-radius: 8px;
            border: 1px solid var(--m3-sys-color-outline-variant);
        }

        .leaflet-popup-content {
            margin: 12px;
            font-size: var(--body-medium-size);
            line-height: 1.5;
            max-width: 280px;
        }

        .leaflet-popup-content b {
            font-weight: 500;
            color: var(--m3-sys-color-primary);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .leaflet-popup-content b .marker-icon-popup {
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: middle;
        }

        /* Style for SVG in popup */
        .leaflet-popup-content .material-symbols-outlined {
            font-size: 1.1em;
            vertical-align: bottom;
            margin-right: 5px;
            opacity: 0.8;
            color: var(--m3-sys-color-on-surface-variant);
        }

        .leaflet-popup-content div {
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }

        .leaflet-popup-content div span:first-child {
            flex-shrink: 0;
        }

        /* Prevent icon shrinking */
        .leaflet-popup-content small {
            font-size: var(--body-small-size);
            color: var(--m3-sys-color-on-surface-variant);
            opacity: 0.9;
            display: block;
            margin-top: 2px;
        }

        .leaflet-popup-content hr {
            margin: 6px 0;
            border: none;
            border-top: 1px solid var(--m3-sys-color-outline-variant);
        }

        .leaflet-popup-content a {
            color: var(--m3-sys-color-primary);
            text-decoration: none;
        }

        .leaflet-popup-content a:hover {
            text-decoration: underline;
        }

        .leaflet-container a.leaflet-popup-close-button {
            color: var(--m3-sys-color-on-surface-variant);
        }
    </style>
</head>

<body>
    <div id="share-container">
        <header class="share-app-bar">
            <span class="material-symbols-outlined share-app-bar-icon">share_location</span>
            <h1 class="share-app-bar-title" id="share-title">Shared Location</h1>
        </header>

        <div id="share-map-wrapper">
            <div id="share-map"></div>
            <!-- App-Style Map Controls -->
            <div class="map-controls">
                <button class="map-control-button" id="zoom-in" title="Zoom in" aria-label="Zoom in">add</button>
                <button class="map-control-button" id="zoom-out" title="Zoom out" aria-label="Zoom out">remove</button>
            </div>
            <!-- Info Card Overlay -->
            <div class="info-card" id="info-card">
                <div class="info-card-header">
                    <span class="material-symbols-outlined info-card-icon" id="info-card-icon">devices</span>
                    <span class="info-card-title" id="info-card-title">Device Name</span>
                </div>
                <div class="info-card-details">
                    <div><span class="material-symbols-outlined">schedule</span> <span id="info-card-time">Loading
                            time...</span></div>
                    <div><span class="material-symbols-outlined" id="info-card-battery-icon">battery_unknown</span>
                        <span id="info-card-battery">Loading battery...</span></div>
                    <div id="info-card-note-container" style="display: none;">
                        <div class="info-card-note" id="info-card-note"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading/Error Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <span class="material-symbols-outlined"></span> <!-- Placeholder for error icon -->
        <div class="spinner"></div>
        <p id="loading-message">Loading shared location...</p>
    </div>

    <script id="leaflet-js" src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="{{ url_for('static', filename='js/share_page.js') }}"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const shareId = "{{ share_id }}";
            // Apply dark theme CSS variables if system prefers dark
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.style.setProperty('--m3-sys-color-primary', '#D0BCFF'); document.documentElement.style.setProperty('--m3-sys-color-on-primary', '#381E72'); document.documentElement.style.setProperty('--m3-sys-color-primary-container', '#4F378B'); document.documentElement.style.setProperty('--m3-sys-color-on-primary-container', '#EADDFF');
                document.documentElement.style.setProperty('--m3-sys-color-secondary', '#CCC2DC'); document.documentElement.style.setProperty('--m3-sys-color-on-secondary', '#332D41'); document.documentElement.style.setProperty('--m3-sys-color-secondary-container', '#4A4458'); document.documentElement.style.setProperty('--m3-sys-color-on-secondary-container', '#E8DEF8');
                document.documentElement.style.setProperty('--m3-sys-color-tertiary', '#EFB8C8'); document.documentElement.style.setProperty('--m3-sys-color-on-tertiary', '#492532'); document.documentElement.style.setProperty('--m3-sys-color-tertiary-container', '#633B48'); document.documentElement.style.setProperty('--m3-sys-color-on-tertiary-container', '#FFD8E4');
                document.documentElement.style.setProperty('--m3-sys-color-error', '#F2B8B5'); document.documentElement.style.setProperty('--m3-sys-color-on-error', '#601410'); document.documentElement.style.setProperty('--m3-sys-color-error-container', '#8C1D18'); document.documentElement.style.setProperty('--m3-sys-color-on-error-container', '#F9DEDC');
                document.documentElement.style.setProperty('--m3-sys-color-background', '#1C1B1F'); document.documentElement.style.setProperty('--m3-sys-color-on-background', '#E6E1E5');
                document.documentElement.style.setProperty('--m3-sys-color-surface', '#1C1B1F'); document.documentElement.style.setProperty('--m3-sys-color-surface-rgb', '28, 27, 31'); document.documentElement.style.setProperty('--m3-sys-color-on-surface', '#E6E1E5');
                document.documentElement.style.setProperty('--m3-sys-color-surface-variant', '#49454F'); document.documentElement.style.setProperty('--m3-sys-color-on-surface-variant', '#CAC4D0');
                document.documentElement.style.setProperty('--m3-sys-color-outline', '#938F99'); document.documentElement.style.setProperty('--m3-sys-color-outline-variant', '#49454F');
                document.documentElement.style.setProperty('--m3-sys-color-inverse-surface', '#E6E1E5'); document.documentElement.style.setProperty('--m3-sys-color-inverse-on-surface', '#313033'); document.documentElement.style.setProperty('--m3-sys-color-inverse-primary', '#6750A4');
                document.documentElement.style.setProperty('--m3-sys-color-surface-dim', '#141218'); document.documentElement.style.setProperty('--m3-sys-color-surface-bright', '#3B383E'); document.documentElement.style.setProperty('--m3-sys-color-surface-container-lowest', '#0F0D13'); document.documentElement.style.setProperty('--m3-sys-color-surface-container-low', '#1C1B1F'); document.documentElement.style.setProperty('--m3-sys-color-surface-container', '#201F23'); document.documentElement.style.setProperty('--m3-sys-color-surface-container-high', '#2B292F'); document.documentElement.style.setProperty('--m3-sys-color-surface-container-highest', '#36343A');
                document.getElementById('share-meta-theme-color').setAttribute('content', '#1C1B1F');
            }
            // Initialize Share Page
            if (window.SharePage && typeof window.SharePage.initialize === 'function') { window.SharePage.initialize(shareId); }
            else { console.error("SharePage object not found!"); document.getElementById('loading-message').innerHTML = '<span class="error-message">Error loading map script.</span>'; }
        });
    </script>
</body>

</html>
// --------------------
// app\utils\data_formatting.py
# app/utils/data_formatting.py
import logging
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any, Tuple

# Import helpers needed
from .helpers import getDefaultColorForId, generate_device_icon_svg  # Correct import

log = logging.getLogger(__name__)


def format_latest_report_for_api(
    user_id: str,
    device_id: str,
    report: Optional[Dict[str, Any]],
    config: Dict[str, Any],
    all_user_geofences: Dict[str, Dict[str, Any]],  # Pass loaded geofences
    low_battery_threshold: int = 15,  # Pass threshold from config
) -> Dict[str, Any]:
    """
    Formats the latest device report and configuration into a structure suitable for the API response.
    Includes the generated SVG icon.
    """
    config = config or {}  # Ensure config is a dict

    # Extract display info from config with defaults
    display_name = config.get("name", device_id) or device_id
    display_label = config.get("label", "❓") or "❓"
    display_color = config.get("color")
    model_name = config.get("model", "Accessory/Tag") or "Accessory/Tag"
    icon_name = (
        config.get("icon", "tag") or "tag"
    )  # Keep icon name if needed by frontend

    final_color = display_color if display_color else getDefaultColorForId(device_id)

    # --- Generate SVG Icon ---
    try:
        # Call the updated helper function
        device_svg_icon = generate_device_icon_svg(display_label, final_color)
    except Exception as e:
        log.error(f"Failed to generate SVG for device {device_id}: {e}")
        device_svg_icon = None  # Handle error case
    # --- ----------------- ---

    # Resolve linked geofences using the provided all_user_geofences map
    resolved_geofences = []
    linked_geofence_info = config.get("linked_geofences", [])
    if isinstance(linked_geofence_info, list):
        for link_info in linked_geofence_info:
            gf_id = link_info.get("id")
            if gf_id and gf_id in all_user_geofences:
                gf_def = all_user_geofences[gf_id]
                # Combine definition with link-specific notification flags
                resolved_gf = {
                    **gf_def,  # Includes id, name, lat, lng, radius from definition
                    "notify_on_entry": link_info.get("notify_entry", False),
                    "notify_on_exit": link_info.get("notify_exit", False),
                }
                resolved_geofences.append(resolved_gf)
            elif gf_id:
                log.warning(
                    f"User '{user_id}', Device '{device_id}': Linked geofence ID '{gf_id}' not found in loaded definitions."
                )

    # Base structure for the device, including resolved config and SVG
    base_info = {
        "id": device_id,
        "name": display_name,
        "model": model_name,
        "icon": icon_name,  # Frontend might use this name
        "label": display_label,
        "color": final_color,
        "svg_icon": device_svg_icon,  # <-- Include SVG in response
        "geofences": resolved_geofences,  # Include resolved geofences linked to this device
        "reports": [],  # Will be populated later if needed by the caller
    }

    # If no report is available, return base info with unknown status
    if not report:
        return {
            **base_info,
            "status": "Location Unknown",
            "batteryLevel": None,
            "batteryStatus": "Unknown",
            "lat": None,
            "lng": None,
            "locationTimestamp": None,
            "address": "Location Unavailable",
            "rawLocation": None,  # Add rawLocation field even if null
        }

    # Process the report data
    lat, lng = report.get("lat"), report.get("lon")
    battery_level_raw = report.get("battery")
    raw_status_code = report.get("status")
    timestamp_iso = report.get("timestamp")
    horizontal_accuracy = report.get("horizontalAccuracy")

    status_parts = []
    timestamp_str = None
    address_str = "Location Unavailable"  # Default address string
    relative_time_desc = "Unknown Time"  # Default relative time

    # Format timestamp and relative time
    if timestamp_iso:
        try:
            # Handle potential 'Z' for UTC and ensure timezone awareness
            timestamp_dt = datetime.fromisoformat(timestamp_iso.replace("Z", "+00:00"))
            if timestamp_dt.tzinfo is None:
                timestamp_dt = timestamp_dt.replace(tzinfo=timezone.utc)
            else:
                timestamp_dt = timestamp_dt.astimezone(timezone.utc)

            now = datetime.now(timezone.utc)
            delta = now - timestamp_dt
            delta = max(delta, timedelta(seconds=0))  # Ensure delta is not negative

            # Generate relative time description
            if delta < timedelta(minutes=2):
                relative_time_desc = "Just now"
            elif delta < timedelta(hours=1):
                relative_time_desc = f"{int(delta.total_seconds() / 60)} min ago"
            elif delta < timedelta(days=1):
                relative_time_desc = f"{int(delta.total_seconds() / 3600)} hr ago"
            else:
                relative_time_desc = (
                    f"{delta.days} day{'s' if delta.days > 1 else ''} ago"
                )

            timestamp_str = timestamp_dt.strftime("%Y-%m-%d %H:%M:%S UTC")
            address_str = f"Located {relative_time_desc}"
            status_parts.append(f"Located {relative_time_desc}")

            if horizontal_accuracy is not None:
                try:
                    address_str += f" (±{horizontal_accuracy:.0f}m)"
                except (ValueError, TypeError):
                    log.warning(
                        f"Invalid horizontalAccuracy format '{horizontal_accuracy}' for {device_id}"
                    )

        except Exception as time_err:
            log.warning(
                f"Error formatting report timestamp {timestamp_iso} for {device_id}: {time_err}"
            )
            timestamp_str = "Invalid Timestamp"
            address_str = "Location Available (Time Error)"
            status_parts.append("Location Available (Time Error)")
    else:
        status_parts.append("Location Unknown (No Time)")

    # Process battery information using helper
    mapped_battery_level, battery_status_str = _parse_battery_info(
        battery_level_raw, raw_status_code, low_battery_threshold
    )

    # Add battery info to status string
    if mapped_battery_level is not None:
        try:
            status_parts.append(
                f"Batt: {mapped_battery_level:.0f}% ({battery_status_str})"
            )
        except (ValueError, TypeError):
            status_parts.append(f"Batt: {battery_status_str}")
    elif battery_status_str != "Unknown":
        status_parts.append(f"Batt: {battery_status_str}")

    # Combine status parts
    final_status = " - ".join(filter(None, status_parts)) or "Status Unknown"

    # Assemble the final dictionary, including the raw report data
    return {
        **base_info,
        "status": final_status,
        "batteryLevel": mapped_battery_level,
        "batteryStatus": battery_status_str,
        "lat": lat,
        "lng": lng,
        "locationTimestamp": timestamp_str,
        "address": address_str,
        "rawLocation": report,  # Include the original report data
    }


def _parse_battery_info(
    battery_level_raw: Any, raw_status_code: Any, low_battery_threshold: int
) -> Tuple[Optional[float], str]:
    """Helper to parse battery level and status from report fields."""
    mapped_battery_level: Optional[float] = None
    battery_status_str: str = "Unknown"

    # Try parsing battery status code first
    if raw_status_code is not None:
        try:
            status_int = int(raw_status_code)
            if status_int == 0:
                mapped_battery_level, battery_status_str = 100.0, "Full"
            elif status_int == 32:
                mapped_battery_level, battery_status_str = 90.0, "High"
            elif status_int == 64:
                mapped_battery_level, battery_status_str = 50.0, "Medium"
            elif status_int == 128:
                mapped_battery_level, battery_status_str = 30.0, "Low"
            elif status_int == 192:
                mapped_battery_level, battery_status_str = 10.0, "Very Low"
        except (ValueError, TypeError):
            log.debug(
                f"Could not parse raw_status_code '{raw_status_code}' as integer."
            )
            pass  # Fall through

    # If status code didn't give a level, check the battery field
    if mapped_battery_level is None:
        if isinstance(battery_level_raw, (int, float)):
            mapped_battery_level = float(battery_level_raw)
            # Status string determined later based on final level
        elif isinstance(battery_level_raw, str):
            level_lower = battery_level_raw.lower()
            if level_lower == "very low":
                mapped_battery_level, battery_status_str = 10.0, "Very Low"
            elif level_lower == "low":
                mapped_battery_level, battery_status_str = 25.0, "Low"
            elif level_lower == "medium":
                mapped_battery_level, battery_status_str = 50.0, "Medium"
            elif level_lower == "high":
                mapped_battery_level, battery_status_str = 85.0, "High"
            elif level_lower == "full":
                mapped_battery_level, battery_status_str = 100.0, "Full"
            else:
                # Handle unknown string values by just displaying them
                battery_status_str = battery_level_raw.capitalize()
                log.debug(f"Unknown string battery level: '{battery_level_raw}'")

    # Final check: Determine status string based on calculated level
    if mapped_battery_level is not None:
        # Override status string based on threshold if level exists
        if mapped_battery_level < low_battery_threshold:
            battery_status_str = "Very Low"
        elif mapped_battery_level < 30:
            battery_status_str = "Low"
        elif mapped_battery_level < 70:
            battery_status_str = "Medium"
        elif mapped_battery_level < 95:
            battery_status_str = "High"
        else:
            battery_status_str = "Full"

    return mapped_battery_level, battery_status_str

// --------------------
// app\utils\helpers.py
# app/utils/helpers.py
import math
import uuid
import base64
import logging
import requests
import re
from cryptography.fernet import InvalidToken

try:
    import regex

    _REGEX_AVAILABLE = True
except ImportError:
    _REGEX_AVAILABLE = False


log = logging.getLogger(__name__)

DEFAULT_SOURCE_COLOR = '#6750A4'


def haversine(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth."""
    try:
        lat1, lon1, lat2, lon2 = map(
            math.radians, [float(lat1), float(lon1), float(lat2), float(lon2)]
        )
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = (
            math.sin(dlat / 2) ** 2
            + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
        )
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        r = 6371000  # Earth radius in meters
        return c * r
    except (ValueError, TypeError):
        log.warning(
            f"Invalid input for haversine calculation: ({lat1}, {lon1}), ({lat2}, {lon2})"
        )
        return float("inf")  # Return infinity or handle error appropriately


def generate_geofence_id():
    """Generates a unique ID for a geofence."""
    return f"gf_{uuid.uuid4()}"


def generate_device_icon_svg(label: str, color: str, size: int = 36) -> str:
    """
    Generates an SVG icon with a colored border, white background, and text label.
    Text color contrasts with the *border* color for better visual association.
    """
    label = label or "?"
    try:
        if _REGEX_AVAILABLE:
            label_chars = regex.findall(r"\X", label, regex.UNICODE)
            label = "".join(label_chars[:2]).upper()
        else:
            if len(label) > 0 and 0xD800 <= ord(label[0]) <= 0xDBFF:
                label = label[:2].upper()
            else:
                label = label[:1].upper()
    except Exception as e:
        log.warning(f"Error processing label '{label}' for SVG: {e}")
        label = (label or "?")[:2].upper()

    color = color or "#70757a"
    if not re.match(r"^#[0-9a-fA-F]{6}$", color):
        color = getDefaultColorForId(label)

    border_width = max(1, round(size * 0.1))
    inner_radius = max(1, round(size / 2) - border_width)
    text_size = size * (0.50 if len(label) == 1 else 0.40)
    # text_y_adjust = size * 0.04 # Keep text centered vertically

    # --- UPDATED TEXT COLOR LOGIC ---
    # Determine text color based on the BORDER color's luminance for contrast
    text_color = "#FFFFFF"  # Default to white text (contrasts with dark borders)
    try:
        r = int(color[1:3], 16)
        g = int(color[3:5], 16)
        b = int(color[5:7], 16)
        # Calculate luminance (0=black, 1=white)
        luminance = (
            0.2126 * r + 0.7152 * g + 0.0722 * b
        ) / 255  # More accurate luminance calculation
        # Use dark text (#333) if the BORDER color is light (high luminance)
        if luminance > 0.5:  # Threshold for light/dark background
            text_color = "#333333"
    except Exception as e:
        log.warning(f"Could not parse color '{color}' for luminance check: {e}")
    # --- ------------------------- ---

    label_safe = label.replace("&", "&").replace("<", "<").replace(">", ">")

    svg_template = f"""<svg xmlns="http://www.w3.org/2000/svg" width="{size}" height="{size}" viewBox="0 0 {size} {size}">
<circle cx="{size/2}" cy="{size/2}" r="{size/2}" fill="{color}" />
<circle cx="{size/2}" cy="{size/2}" r="{inner_radius}" fill="#FFFFFF" />
<text x="50%" y="50%" dominant-baseline="central" text-anchor="middle"
        font-family="sans-serif" font-size="{text_size}px" font-weight="bold" fill="{text_color}">
    {label_safe}
</text>
</svg>"""
    return svg_template


def getDefaultColorForId(id_str: str) -> str:
    """Generates a default hex color based on a string ID."""
    if not id_str:
        return "#70757a"  # Grey for empty ID
    try:
        hash_val = 0
        for char in str(id_str):  # Ensure it's a string
            hash_val = ord(char) + ((hash_val << 5) - hash_val)
            hash_val &= hash_val  # Convert to 32bit integer
        hash_val = abs(hash_val)

        # Extract RGB components
        r = (hash_val & 0xFF0000) >> 16
        g = (hash_val & 0x00FF00) >> 8
        b = hash_val & 0x0000FF

        # Simple adjustment to avoid extremely dark/light colors and increase saturation
        # Aim for a luminance range (approx 0.3 - 0.7) and ensure some color variance
        avg = (r + g + b) / 3.0
        min_comp = min(r, g, b)
        max_comp = max(r, g, b)

        # Adjust brightness/saturation slightly
        factor = 0.5  # Adjust factor to control brightness shift
        nr = min(255, max(0, r + (128 - avg) * factor))
        ng = min(255, max(0, g + (128 - avg) * factor))
        nb = min(255, max(0, b + (128 - avg) * factor))

        # Ensure minimum difference between components for saturation
        if max(nr, ng, nb) - min(nr, ng, nb) < 30:
            # If too gray, slightly boost the max component and reduce the min
            components = [(nr, "r"), (ng, "g"), (nb, "b")]
            components.sort()
            # Increase max, decrease min (crude saturation boost)
            max_val, max_idx = components[2]
            min_val, min_idx = components[0]
            components[2] = (min(255, max_val + 20), max_idx)
            components[0] = (max(0, min_val - 10), min_idx)
            # Reassign based on index
            for val, idx in components:
                if idx == "r":
                    nr = val
                elif idx == "g":
                    ng = val
                else:
                    nb = val

        return f"#{int(nr):02x}{int(ng):02x}{int(nb):02x}"
    except Exception as e:
        log.error(f"Error generating color for ID '{id_str}': {e}")
        return "#70757a"  # Fallback grey


def get_available_anisette_server(anisette_server_list: list[str]) -> str | None:
    """
    Finds the first responsive Anisette server from the provided list.
    Prioritizes localhost:6969 if present.
    """
    local_anisette = "http://localhost:6969"

    # Check local first if it's in the list or implicitly preferred
    if local_anisette in anisette_server_list:
        try:
            response = requests.get(local_anisette, timeout=1)
            response.raise_for_status()
            log.info(f"Using local Anisette server: {local_anisette}")
            return local_anisette
        except requests.exceptions.RequestException as e:
            log.warning(f"Local Anisette server ({local_anisette}) not responsive: {e}")
        except Exception as e:
            log.error(f"Unexpected error checking local Anisette server: {e}")

    # Check other configured servers
    for server_url in anisette_server_list:
        if server_url == local_anisette:
            continue  # Already checked or not present
        try:
            headers = {"User-Agent": "Mozilla/5.0 FindMyApp/2.0"}  # Identify client
            response = requests.get(server_url, timeout=3, headers=headers)
            if response.status_code == 200:
                # Optional: Add further validation? Check response content?
                log.info(f"Using public Anisette server: {server_url}")
                return server_url
            else:
                log.warning(
                    f"Public Anisette server {server_url} responded with status {response.status_code}"
                )
        except requests.exceptions.RequestException as e:
            log.warning(f"Public Anisette server {server_url} not responsive: {e}")
        except Exception as e:
            log.error(
                f"Unexpected error checking public Anisette server {server_url}: {e}"
            )

    log.error("No Anisette server configured or available.")
    return None


# --- Encryption Helpers ---
_cipher_suite = None


def _get_cipher_suite(config):
    """Initializes and returns the Fernet cipher suite."""
    global _cipher_suite
    if _cipher_suite is None and config.get("ENCRYPTION_ENABLED"):
        try:
            from cryptography.fernet import Fernet

            key = config.get("FERNET_KEY")
            if key:
                _cipher_suite = Fernet(key.encode())
                log.info("Fernet cipher suite initialized.")
            else:
                log.error("Encryption enabled but FERNET_KEY is missing.")
        except ImportError:
            log.error(
                "Cryptography library not installed. Cannot use Fernet encryption."
            )
            config["ENCRYPTION_ENABLED"] = False
        except Exception as e:
            log.error(f"Failed to initialize Fernet encryption (invalid key?): {e}")
            config["ENCRYPTION_ENABLED"] = False
            _cipher_suite = None
    return _cipher_suite


def encrypt_password(password: str, config) -> str:
    """Encrypts a password using Fernet or Base64 fallback."""
    if not password:
        return ""
    if config.get("ENCRYPTION_ENABLED"):
        cipher = _get_cipher_suite(config)
        if cipher:
            try:
                return cipher.encrypt(password.encode()).decode()
            except Exception as e:
                log.error(f"Fernet encryption failed: {e}")
                return ""
        else:
            log.warning(
                "Encryption enabled but cipher failed, falling back to Base64 (INSECURE)."
            )
            return base64.b64encode(password.encode()).decode()
    else:
        # Use Base64 if encryption is explicitly disabled
        return base64.b64encode(password.encode()).decode()


def decrypt_password(encrypted_password: str, config) -> str:
    """Decrypts a password using Fernet or Base64 fallback."""
    if not encrypted_password:
        return ""
    if config.get("ENCRYPTION_ENABLED"):
        cipher = _get_cipher_suite(config)
        if cipher:
            try:
                # Attempt Fernet decryption first
                return cipher.decrypt(encrypted_password.encode()).decode()
            except InvalidToken:
                log.warning(
                    "Fernet decryption failed (InvalidToken). Trying Base64 fallback."
                )
                try:
                    # Try Base64 only if Fernet fails with InvalidToken
                    return base64.b64decode(encrypted_password.encode()).decode()
                except Exception as b64_e:
                    log.error(f"Base64 fallback decryption also failed: {b64_e}")
                    return ""
            except Exception as e:
                log.error(f"Fernet decryption failed with unexpected error: {e}")
                return ""
        else:
            # If cipher init failed but encryption was enabled, try Base64
            log.warning(
                "Encryption enabled but cipher failed, attempting Base64 decryption."
            )
            try:
                return base64.b64decode(encrypted_password.encode()).decode()
            except Exception as e:
                log.error(f"Base64 decryption failed (cipher disabled): {e}")
                return ""
    else:
        # Fallback to Base64 if encryption was never enabled
        try:
            return base64.b64decode(encrypted_password.encode()).decode()
        except Exception as e:
            log.error(f"Base64 decryption failed: {e}")
            return ""

// --------------------
// app\utils\json_utils.py
# app/utils/json_utils.py
import json
import os
import logging
import threading
from pathlib import Path
from typing import Optional, Dict, Any

log = logging.getLogger(__name__)

def save_json_atomic(file_path: Path, data: Dict[str, Any], lock: threading.Lock, indent: Optional[int] = 2):
    """
    Atomically saves a dictionary to a JSON file using a temporary file and a lock.

    Args:
        file_path: The final path for the JSON file.
        data: The dictionary data to save.
        lock: The threading lock specific to this file/resource.
        indent: The indentation level for the JSON file (default: 2). Use None for no indentation.
    """
    temp_file_path = None
    try:
        # Create directory if it doesn't exist before acquiring lock
        file_path.parent.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        log.error(f"Failed to create directory {file_path.parent}: {e}")
        # Depending on severity, you might want to raise this exception
        return # Or raise e

    with lock:
        try:
            # Use a unique temporary file name in the same directory
            temp_file_path = file_path.with_suffix(f".{os.getpid()}.tmp")

            with open(temp_file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=indent, ensure_ascii=False) # ensure_ascii=False for proper unicode

            # Atomic replace operation
            os.replace(temp_file_path, file_path)
            log.debug(f"Successfully saved data to {file_path}")

        except (IOError, OSError, json.JSONDecodeError) as e:
            log.error(f"Failed to save JSON atomically to {file_path}: {e}")
            # Clean up temporary file if it exists and saving failed
            if temp_file_path and temp_file_path.exists():
                try:
                    os.remove(temp_file_path)
                    log.debug(f"Removed temporary file {temp_file_path} after save failure.")
                except OSError as cleanup_err:
                    log.error(f"Failed to remove temporary file {temp_file_path}: {cleanup_err}")
            # Re-raise the exception or handle it as needed
            raise # Or return False / specific error code

        except Exception as e:
            # Catch any other unexpected errors during the locked operation
            log.exception(f"Unexpected error during atomic JSON save to {file_path}")
            if temp_file_path and temp_file_path.exists():
                 try: os.remove(temp_file_path)
                 except OSError: pass
            raise # Re-raise unexpected errors


def load_json_file(file_path: Path, lock: threading.Lock) -> Optional[Dict[str, Any]]:
    """
    Loads data from a JSON file using a lock, returning None if file not found or invalid.

    Args:
        file_path: The path to the JSON file.
        lock: The threading lock specific to this file/resource.

    Returns:
        The loaded dictionary, or None if the file doesn't exist, is empty, or invalid.
    """
    with lock:
        if not file_path.exists():
            log.debug(f"JSON file not found: {file_path}")
            return None
        if file_path.stat().st_size == 0:
             log.warning(f"JSON file is empty: {file_path}")
             return None # Treat empty file as non-existent/invalid

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)

            if not isinstance(data, dict):
                log.warning(f"Invalid format (not a dict) in {file_path}. Content: {str(data)[:100]}...")
                # Optionally: Backup or rename the corrupted file here
                # e.g., file_path.rename(file_path.with_suffix(".invalid"))
                return None

            # log.debug(f"Successfully loaded JSON from {file_path}")
            return data

        except json.JSONDecodeError as e:
            log.error(f"Failed to parse JSON from {file_path}: {e}")
            # Optionally: Backup or rename the corrupted file
            return None
        except (IOError, OSError) as e:
            log.error(f"Failed to read file {file_path}: {e}")
            return None
        except Exception as e:
            log.exception(f"Unexpected error loading JSON from {file_path}")
            return None
// --------------------
// app\utils\key_utils.py
# app/utils/key_utils.py

import os
import logging
import base64
from typing import Optional, Tuple

# Cryptography imports
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.exceptions import InvalidSignature
from cryptography.fernet import InvalidToken

log = logging.getLogger(__name__)

# --- Key Derivation Constants ---
HKDF_SALT = b"findmyapp-hkdf-salt-v1.1"
DERIVED_KEY_LENGTH = 32

# --- Constants for SECP256R1 ---
# The order 'n' of the SECP256R1 curve (prime256v1). Needed for validation.
# Value from SEC 2: Recommended Elliptic Curve Domain Parameters (Version 2.0, Jan 27, 2010)
# http://www.secg.org/sec2-v2.pdf
SECP256R1_ORDER = (
    115792089210356248762697446949407573529996955224135760342422259061068512044369
)


# --- Helper Functions (urlsafe_b64encode_str, derive_key_hkdf - same as before) ---
def urlsafe_b64encode_str(data: bytes) -> str:
    """URL-safe Base64 encodes bytes and returns a UTF-8 decoded string."""
    return base64.urlsafe_b64encode(data).decode("utf-8")


def derive_key_hkdf(seed: Optional[str], info: bytes, length: int) -> Optional[bytes]:
    """
    Derives a key of specified length from a seed string using HKDF-SHA256.
    Returns None if the seed is empty or invalid.
    """
    if not seed or not isinstance(seed, str) or len(seed.strip()) == 0:
        log.error(
            f"Invalid or empty seed provided for HKDF derivation (info: {info.decode()})."
        )
        return None
    try:
        hkdf = HKDF(
            algorithm=hashes.SHA256(),
            length=length,
            salt=HKDF_SALT,
            info=info,
        )
        derived_key = hkdf.derive(seed.encode("utf-8"))
        log.debug(f"HKDF derived {length} bytes for info: {info.decode()}")
        return derived_key
    except Exception as e:
        log.exception(f"Error during HKDF derivation (info: {info.decode()}): {e}")
        return None


# --- Specific Key Generation Functions (generate_fernet_key_from_seed, generate_secret_key_bytes_from_seed - same as before) ---
def generate_fernet_key_from_seed(seed: Optional[str]) -> Optional[str]:
    """Generates a URL-safe Base64 encoded Fernet key (32 bytes) from a seed."""
    derived_bytes = derive_key_hkdf(seed, b"fernet-key", DERIVED_KEY_LENGTH)
    if derived_bytes:
        return urlsafe_b64encode_str(derived_bytes)
    return None


def generate_secret_key_bytes_from_seed(seed: Optional[str]) -> Optional[bytes]:
    """Generates Flask SECRET_KEY bytes (typically 32 bytes) from a seed."""
    return derive_key_hkdf(seed, b"flask-secret-key", DERIVED_KEY_LENGTH)


# --- VAPID Key Generation (Corrected) ---
def generate_vapid_keys_from_seed(seed: Optional[str]) -> Optional[Tuple[str, str]]:
    """
    Generates VAPID private/public key pair (URL-safe Base64) from a seed.
    Uses HKDF output to derive the private scalar for SECP256R1.
    Returns (private_key_b64, public_key_b64) or None on failure or invalid scalar.
    """
    curve = ec.SECP256R1()  # Use correct curve name
    private_key_seed_bytes = derive_key_hkdf(seed, b"vapid-private-key", 32)

    if not private_key_seed_bytes:
        log.error("Failed to derive seed bytes for VAPID private key.")
        return None

    private_scalar = int.from_bytes(private_key_seed_bytes, "big")

    # --- CRITICAL VALIDATION (Using the constant SECP256R1_ORDER) ---
    if not (1 <= private_scalar < SECP256R1_ORDER):  # <<< CORRECTED VALIDATION
        log.error(
            f"Derived VAPID private key scalar from seed is outside the valid range [1, n-1] for SECP256R1 curve (n={SECP256R1_ORDER}). "
            f"This specific seed cannot generate a valid VAPID key pair deterministically using this method. "
            f"VAPID will be disabled unless keys are provided directly via environment variables."
        )
        return None  # Indicate generation failure

    try:
        private_key = ec.derive_private_key(private_scalar, curve)
        public_key = private_key.public_key()
        private_key_bytes = private_key_seed_bytes  # Reuse derived bytes
        public_key_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.X962,
            format=serialization.PublicFormat.UncompressedPoint,
        )
        private_key_b64 = urlsafe_b64encode_str(private_key_bytes)
        public_key_b64 = urlsafe_b64encode_str(public_key_bytes)
        log.debug("Successfully generated VAPID key pair from seed.")
        return private_key_b64, public_key_b64

    except Exception as e:
        log.exception(f"Unexpected error generating VAPID keys from seed: {e}")
        return None

// --------------------
// app\utils\__init__.py
# app/utils/__init__.py
from . import helpers
from . import json_utils
from . import key_utils  # Add the new module
from . import data_formatting

// --------------------
// scripts\generate_vapid.py
# scripts/generate_vapid.py

from py_vapid import Vapid
import os
import sys
import logging
from pathlib import Path
# Import serialization enums directly
from cryptography.hazmat.primitives import serialization
from py_vapid.utils import b64urlencode

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

def generate_and_save_keys(output_dir: Path):
    """Generates VAPID keys and saves them as PEM-like strings (b64 encoded)"""
    try:
        log.info(f"Generating new VAPID keys in {output_dir}...")
        output_dir.mkdir(parents=True, exist_ok=True)

        priv_key_path = output_dir / "vapid_private_key.pem"
        pub_key_path = output_dir / "vapid_public_key.pem"

        # Check if keys already exist to avoid overwriting unnecessarily
        if priv_key_path.exists() and pub_key_path.exists():
             log.info("VAPID key files already exist. Skipping generation.")
             return True

        vapid = Vapid()
        vapid.generate_keys()

        # Get public key bytes in uncompressed format
        public_key_bytes = vapid.public_key.public_bytes(
            encoding=serialization.Encoding.X962,
            format=serialization.PublicFormat.UncompressedPoint
        )

        # Get private key value (integer) and convert to bytes
        private_key_value = vapid.private_key.private_numbers().private_value
        private_key_bytes = private_key_value.to_bytes(32, byteorder='big') # SECP256r1 uses 32 bytes

        # URL-safe Base64 encode
        public_key_b64 = b64urlencode(public_key_bytes)
        private_key_b64 = b64urlencode(private_key_bytes)

        # Save to files (just the base64 string)
        with open(priv_key_path, "w") as f:
            f.write(private_key_b64)
        with open(pub_key_path, "w") as f:
            f.write(public_key_b64)

        # Optional: Set permissions (e.g., restrict private key read access)
        # os.chmod(priv_key_path, 0o600)

        log.info(f"Successfully generated and saved VAPID keys to {output_dir}")
        return True

    except Exception as e:
        log.exception(f"Error generating/saving VAPID keys: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python generate_vapid.py <output_directory>")
        sys.exit(1)
    output_directory = Path(sys.argv[1])
    if not generate_and_save_keys(output_directory):
        sys.exit(1)
// --------------------
// scripts\hashed_pw.py
from werkzeug.security import generate_password_hash
password = 'user1_password' # Replace with a strong password
hashed_password = generate_password_hash(password)
print(hashed_password)
// --------------------
// scripts\__init__.py
# scripts/__init__.py
# This file can be empty
